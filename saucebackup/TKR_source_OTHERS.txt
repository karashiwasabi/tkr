----- C:\Users\wasab\OneDrive\デスクトップ\TKR\aggregation\aggregation.go -----
// C:\Users\wasab\OneDrive\デスクトップ\TKR\aggregation\aggregation.go
package aggregation

import (
	"fmt"
	"sort"
	"strings"
	"tkr/database"
	"tkr/model"
	"tkr/units"

	"github.com/jmoiron/sqlx"
)

func signedYjQty(flag int, yjQty float64) float64 {
	switch flag {
	case 1: // 納品
		return yjQty
	case 11: // 入庫
		return yjQty
	case 3: // 処方
		return -yjQty
	case 2: // 返品
		return -yjQty
	case 12: // 出庫
		return -yjQty
	default: // 棚卸(0), その他
		return 0
	}
}

func GetStockLedger(conn *sqlx.DB, filters model.AggregationFilters) ([]model.StockLedgerYJGroup, error) {
	// 1. マスタとYJコードの取得
	mastersByYjCode, yjCodes, err := GetFilteredMastersAndYjCodes(conn, filters)
	if err != nil {
		return nil, fmt.Errorf("failed to get filtered masters: %w", err)
	}
	if len(yjCodes) == 0 {
		return []model.StockLedgerYJGroup{}, nil
	}

	// 2. 全トランザクションの取得 (メモリ上でフィルタするため一旦全て取得)
	allProductCodes, err := getAllProductCodesForYjCodes(conn, yjCodes)
	if err != nil {
		return nil, fmt.Errorf("failed to get all product codes for yj codes: %w", err)
	}
	transactionsByProductCode, err := getTransactionsByProductCodes(conn, allProductCodes)
	if err != nil {
		return nil, fmt.Errorf("failed to get transactions: %w", err)
	}

	precompTotals, err := database.GetPreCompoundingTotals(conn)
	if err != nil {
		return nil, fmt.Errorf("failed to get pre-compounding totals: %w", err)
	}

	backordersMap, err := database.GetAllBackordersMap(conn)
	if err != nil {
		return nil, fmt.Errorf("failed to get backorders: %w", err)
	}

	// 3. PackageKey の生成と PackageStock の一括取得
	var targetPackageKeys []string
	mastersByPackageKeyGlobal := make(map[string][]*model.ProductMaster)

	for _, yjCode := range yjCodes {
		masters := mastersByYjCode[yjCode]
		for _, m := range masters {
			key := database.GeneratePackageKey(m)
			if _, exists := mastersByPackageKeyGlobal[key]; !exists {
				targetPackageKeys = append(targetPackageKeys, key)
			}
			mastersByPackageKeyGlobal[key] = append(mastersByPackageKeyGlobal[key], m)
		}
	}

	packageStockMap, err := database.GetPackageStocksByKeys(conn, targetPackageKeys)
	if err != nil {
		return nil, fmt.Errorf("failed to get package stocks by keys: %w", err)
	}

	// 4. 計算処理 (PackageKey単位)
	var result []model.StockLedgerYJGroup
	for _, yjCode := range yjCodes {
		mastersInYjGroup, ok := mastersByYjCode[yjCode]
		if !ok || len(mastersInYjGroup) == 0 {
			continue
		}

		var representativeProductName, representativeYjUnitName string
		representativeProductName = mastersInYjGroup[0].ProductName
		representativeYjUnitName = mastersInYjGroup[0].YjUnitName
		for _, m := range mastersInYjGroup {
			if m.Origin == "JCSHMS" {
				representativeProductName = m.ProductName
				representativeYjUnitName = m.YjUnitName
				break
			}
		}
		yjGroup := model.StockLedgerYJGroup{
			YjCode:      yjCode,
			ProductName: representativeProductName,
			YjUnitName:  units.ResolveName(representativeYjUnitName),
		}

		localMastersByPackageKey := make(map[string][]*model.ProductMaster)
		for _, m := range mastersInYjGroup {
			key := database.GeneratePackageKey(m)
			localMastersByPackageKey[key] = append(localMastersByPackageKey[key], m)
		}

		var allPackageLedgers []model.StockLedgerPackageGroup
		for key, mastersInPackageGroup := range localMastersByPackageKey {

			// =================================================================================
			// ステップ A: 【計算（正解）】 現在在庫の確定 (PackageStock起点)
			// =================================================================================

			var startingBalance float64
			var stockStartDate string

			if stockInfo, ok := packageStockMap[key]; ok {
				startingBalance = stockInfo.StockQuantityYj
				stockStartDate = stockInfo.LastInventoryDate
			} else {
				startingBalance = 0.0
				stockStartDate = "00000000" // データなし＝通算
			}

			// 関連する全トランザクションをマスタグループから集約
			var allRelatedTxs []*model.TransactionRecord
			for _, m := range mastersInPackageGroup {
				txs, ok := transactionsByProductCode[m.ProductCode]
				if !ok {
					continue
				}
				for i := range txs {
					allRelatedTxs = append(allRelatedTxs, &txs[i])
				}
			}

			// 日付順ソート
			sort.Slice(allRelatedTxs, func(i, j int) bool {
				if allRelatedTxs[i].TransactionDate != allRelatedTxs[j].TransactionDate {
					return allRelatedTxs[i].TransactionDate < allRelatedTxs[j].TransactionDate
				}
				return allRelatedTxs[i].ID < allRelatedTxs[j].ID
			})

			// PackageStock日より未来の変動を積み上げる（これが現在在庫の正解）
			currentTheoreticalStock := startingBalance
			for _, t := range allRelatedTxs {
				if t.TransactionDate > stockStartDate {
					if t.Flag != 0 { // 棚卸レコードは無視
						currentTheoreticalStock += signedYjQty(t.Flag, t.YjQuantity)
					}
				}
			}

			// =================================================================================
			// ステップ B: 【表示（リスト）】 90日分のリスト作成
			// =================================================================================

			var transactionsInPeriod []model.LedgerTransaction
			var txsForDisplay []*model.TransactionRecord
			netChangeInPeriod := 0.0
			var maxUsage float64

			// 表示期間（90日前）以降のデータを収集
			for _, t := range allRelatedTxs {
				if t.TransactionDate >= filters.StartDate && t.TransactionDate <= filters.EndDate {
					txsForDisplay = append(txsForDisplay, t)

					qty := 0.0
					if t.Flag != 0 {
						qty = signedYjQty(t.Flag, t.YjQuantity)
					}
					netChangeInPeriod += qty

					if t.Flag == 3 && t.YjQuantity > maxUsage {
						maxUsage = t.YjQuantity
					}
				}
			}

			// =================================================================================
			// ステップ C: 【つじつま合わせ】 表示用開始在庫の逆算
			// =================================================================================

			// 「現在在庫(正解)」から「期間内の変動」を引けば、「期間開始時点の在庫」になる
			// ※filters.EndDate が未来(99991231)の場合はこれでOK
			// もしfilters.EndDateが過去なら、EndDate以降の変動も考慮が必要だが、
			// 今回の要件（現在在庫を知る、直近90日を見る）ではこれで十分整合する

			// 全期間の変動を考慮した現在在庫から、表示期間の変動を引く
			// (厳密には、表示期間より「後」のデータがある場合はそれも引く必要がある)
			netChangeAfterPeriod := 0.0
			for _, t := range allRelatedTxs {
				if t.TransactionDate > filters.EndDate {
					if t.Flag != 0 {
						netChangeAfterPeriod += signedYjQty(t.Flag, t.YjQuantity)
					}
				}
			}

			// 期間開始在庫 = 現在在庫 - (期間内変動 + 期間後変動)
			periodStartingBalance := currentTheoreticalStock - (netChangeInPeriod + netChangeAfterPeriod)

			// 帳簿の作成（RunningBalanceの計算）
			runningBalance := periodStartingBalance
			for _, t := range txsForDisplay {
				qty := 0.0
				if t.Flag != 0 {
					qty = signedYjQty(t.Flag, t.YjQuantity)
				}
				runningBalance += qty

				transactionsInPeriod = append(transactionsInPeriod, model.LedgerTransaction{
					TransactionRecord: *t,
					RunningBalance:    runningBalance,
				})
			}

			// =================================================================================
			// ステップ D: 最終結果の格納
			// =================================================================================

			backorderQty := backordersMap[key]
			effectiveEndingBalance := currentTheoreticalStock + backorderQty // 現在在庫 + 発注残

			var precompTotalForPackage float64
			for _, master := range mastersInPackageGroup {
				if total, ok := precompTotals[master.ProductCode]; ok {
					precompTotalForPackage += total
				}
			}

			pkg := model.StockLedgerPackageGroup{
				PackageKey:             key,
				StartingBalance:        periodStartingBalance,   // 画面表示用（90日前）
				EndingBalance:          currentTheoreticalStock, // 現在在庫（計算の正解）
				Transactions:           transactionsInPeriod,    // 表示用リスト
				NetChange:              netChangeInPeriod,
				Masters:                mastersInPackageGroup,
				EffectiveEndingBalance: effectiveEndingBalance,
				MaxUsage:               maxUsage,
			}

			pkg.BaseReorderPoint = maxUsage * filters.Coefficient
			pkg.PrecompoundedTotal = precompTotalForPackage
			pkg.ReorderPoint = pkg.BaseReorderPoint + pkg.PrecompoundedTotal
			pkg.IsReorderNeeded = effectiveEndingBalance < pkg.ReorderPoint && pkg.MaxUsage > 0

			allPackageLedgers = append(allPackageLedgers, pkg)
		}

		if len(allPackageLedgers) > 0 {
			var yjTotalEnding, yjTotalNetChange, yjTotalStarting float64
			var yjTotalReorderPoint, yjTotalBaseReorderPoint, yjTotalPrecompounded float64
			var yjTotalEffectiveEnding float64
			isYjReorderNeeded := false

			for _, pkg := range allPackageLedgers {
				if start, ok := pkg.StartingBalance.(float64); ok {
					yjTotalStarting += start
				}
				if end, ok := pkg.EndingBalance.(float64); ok {
					yjTotalEnding += end
				}
				yjTotalEffectiveEnding += pkg.EffectiveEndingBalance
				yjTotalNetChange += pkg.NetChange
				yjTotalReorderPoint += pkg.ReorderPoint
				yjTotalBaseReorderPoint += pkg.BaseReorderPoint
				yjTotalPrecompounded += pkg.PrecompoundedTotal
				if pkg.IsReorderNeeded {
					isYjReorderNeeded = true
				}
			}
			yjGroup.StartingBalance = yjTotalStarting
			yjGroup.EndingBalance = yjTotalEnding
			yjGroup.NetChange = yjTotalNetChange
			yjGroup.PackageLedgers = allPackageLedgers
			yjGroup.TotalReorderPoint = yjTotalReorderPoint
			yjGroup.TotalBaseReorderPoint = yjTotalBaseReorderPoint
			yjGroup.TotalPrecompounded = yjTotalPrecompounded
			yjGroup.IsReorderNeeded = isYjReorderNeeded
			result = append(result, yjGroup)
		}
	}
	sort.Slice(result, func(i, j int) bool {
		prio := map[string]int{"内": 1, "外": 2, "歯": 3, "注": 4, "機": 5, "他": 6}
		masterI := mastersByYjCode[result[i].YjCode][0]
		masterJ := mastersByYjCode[result[j].YjCode][0]
		prioI, okI := prio[strings.TrimSpace(masterI.UsageClassification)]
		if !okI {
			prioI = 7
		}
		prioJ, okJ := prio[strings.TrimSpace(masterJ.UsageClassification)]
		if !okJ {
			prioJ = 7
		}
		if prioI != prioJ {
			return prioI < prioJ
		}
		return masterI.KanaName < masterJ.KanaName
	})
	return result, nil
}


----- C:\Users\wasab\OneDrive\デスクトップ\TKR\aggregation\helpers.go -----
// C:\Users\wasab\OneDrive\デスクトップ\TKR\aggregation\helpers.go
package aggregation

import (
	"fmt"
	"tkr/database"
	"tkr/model"

	"github.com/jmoiron/sqlx"
)

func GetFilteredMastersAndYjCodes(conn *sqlx.DB, filters model.AggregationFilters) (map[string][]*model.ProductMaster, []string, error) {
	query := `SELECT * FROM product_master p WHERE 1=1 ` //
	var args []interface{}
	if filters.YjCode != "" { //
		query += " AND p.yj_code = ? " //
		args = append(args, filters.YjCode)
	}
	if filters.KanaName != "" {
		query += " AND p.kana_name LIKE ? "       //
		args = append(args, filters.KanaName+"%") //
	}
	if filters.GenericName != "" {
		query += " AND p.generic_name LIKE ?" //
		args = append(args, "%"+filters.GenericName+"%")
	}
	if filters.DosageForm != "" && filters.DosageForm != "all" {
		query += " AND p.usage_classification = ?" //
		args = append(args, filters.DosageForm)
	}
	if filters.ShelfNumber != "" {
		query += " AND p.shelf_number LIKE ? " //
		args = append(args, "%"+filters.ShelfNumber+"%")
	}

	query += " ORDER BY p.kana_name " //

	rows, err := conn.Queryx(query, args...)
	if err != nil {
		return nil, nil, err
	}
	defer rows.Close()

	mastersByYjCode := make(map[string][]*model.ProductMaster)
	yjCodeMap := make(map[string]bool)
	var yjCodes []string //

	for rows.Next() {
		var m model.ProductMaster
		if err := rows.StructScan(&m); err != nil {
			return nil, nil, err
		}
		if m.YjCode != "" {
			mastersByYjCode[m.YjCode] = append(mastersByYjCode[m.YjCode], &m) //
			if !yjCodeMap[m.YjCode] {
				yjCodeMap[m.YjCode] = true
				yjCodes = append(yjCodes, m.YjCode) //
			}
		}
	}

	return mastersByYjCode, yjCodes, nil
}

func getAllProductCodesForYjCodes(conn *sqlx.DB, yjCodes []string) ([]string, error) { //
	if len(yjCodes) == 0 {
		return []string{}, nil
	}
	query, args, err := sqlx.In(`
		SELECT DISTINCT product_code FROM product_master WHERE yj_code IN (?)
		UNION
		SELECT DISTINCT jan_code FROM transaction_records WHERE yj_code IN (?)`, yjCodes, yjCodes) //
	if err != nil {
		return nil, fmt.Errorf("failed to create IN query for all product codes: %w", err)
	}
	query = conn.Rebind(query)
	var codes []string
	if err := conn.Select(&codes, query, args...); err != nil { //
		return nil, err
	}
	var validCodes []string
	for _, code := range codes {
		if code != "" {
			validCodes = append(validCodes, code)
		}
	}
	return validCodes, nil
}

func getTransactionsByProductCodes(conn *sqlx.DB, productCodes []string) (map[string][]model.TransactionRecord, error) { //
	transactionsMap := make(map[string][]model.TransactionRecord)
	if len(productCodes) == 0 {
		return transactionsMap, nil
	}
	const batchSize = 500
	for i := 0; i < len(productCodes); i += batchSize { //
		end := i + batchSize
		if end > len(productCodes) {
			end = len(productCodes)
		}
		batch := productCodes[i:end]
		if len(batch) > 0 {
			query, args, err := sqlx.In("SELECT "+database.TransactionColumns+" FROM transaction_records WHERE jan_code IN (?) ORDER BY transaction_date, id", batch) //
			if err != nil {
				return nil, err
			}
			query = conn.Rebind(query)
			rows, err := conn.Query(query, args...)
			if err != nil {
				return nil, err
			}
			for rows.Next() {
				t, err := database.ScanTransactionRecord(rows)
				if err != nil {
					rows.Close()
					return nil, err
				}
				transactionsMap[t.JanCode] = append(transactionsMap[t.JanCode], *t)
			}
			rows.Close()
		}
	}
	return transactionsMap, nil
}


----- C:\Users\wasab\OneDrive\デスクトップ\TKR\automation\automation.go -----
// C:\Users\wasab\OneDrive\デスクトップ\TKR\automation\automation.go
package automation

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/go-rod/rod"
	"github.com/go-rod/rod/lib/input"
	"github.com/go-rod/rod/lib/launcher"
)

// DownloadDat はMEDICODE-Webにログインし、DATファイルをダウンロードします。
func DownloadDat(userId, password, saveDir string) (string, error) {
	// 保存先ディレクトリの確保
	if _, err := os.Stat(saveDir); os.IsNotExist(err) {
		if err := os.MkdirAll(saveDir, 0755); err != nil {
			return "", fmt.Errorf("保存先フォルダの作成に失敗: %v", err)
		}
	}

	// 1. ブラウザ起動
	// Leakless(false) でセキュリティソフト対策
	u := launcher.New().
		Headless(false).
		Leakless(false).
		MustLaunch()

	browser := rod.New().ControlURL(u).MustConnect()
	defer browser.MustClose()

	// 2. ログイン画面へ
	fmt.Println("MEDICODE-Webにアクセス中...")
	page := browser.MustPage("https://www.e-mednet.jp/")
	page.MustWaitStable()

	// 3. ログイン操作
	fmt.Println("ログイン情報を入力中...")

	if err := rod.Try(func() {
		page.MustElement("[name='userid']").MustInput(userId)
	}); err != nil {
		return "", fmt.Errorf("ユーザーID入力欄が見つかりません: %v", err)
	}

	if err := rod.Try(func() {
		page.MustElement("[name='userpsw']").MustInput(password)
	}); err != nil {
		return "", fmt.Errorf("パスワード入力欄が見つかりません: %v", err)
	}

	fmt.Println("ログインボタンをクリック...")
	loginBtn, err := page.ElementR("input, button, a, img", "ログイン")
	if err == nil {
		loginBtn.MustClick()
	} else {
		page.KeyActions().Press(input.Enter).MustDo()
	}

	page.MustWaitStable()

	// 4. メニュー移動
	fmt.Println("メニュー[納品処理]を検索中...")
	if err := rod.Try(func() {
		page.MustElementR("a, span, div, img", "納品処理").MustClick()
	}); err != nil {
		return "", fmt.Errorf("メニュー[納品処理]が見つかりません（ログイン失敗の可能性あり）: %v", err)
	}
	page.MustWaitStable()

	// 5. サブメニュー
	fmt.Println("メニュー[納品...受信...JAN]を検索中...")
	if err := rod.Try(func() {
		// URLの一部で検索 (最も確実な方法)
		page.MustElement("a[href*='SrDeliveryJanDownload']").MustClick()
	}); err != nil {
		return "", fmt.Errorf("メニュー[納品受信(JAN)]が見つかりません: %v", err)
	}
	page.MustWaitStable()

	// 6. ダウンロード準備
	wait := browser.MustWaitDownload()

	// ダイアログ（アラート）が出たら自動的にOKを押して閉じる設定
	go page.MustHandleDialog()

	// 7. ボタンクリック
	fmt.Println("ダウンロードボタンをクリック...")
	clicked := false
	selectors := []string{
		"input[value*='未受信データ']",
		"input[type='button']",
		"button",
	}

	for _, sel := range selectors {
		if el, err := page.ElementR(sel, "未受信"); err == nil {
			el.MustClick()
			clicked = true
			break
		}
	}

	if !clicked {
		return "", fmt.Errorf("「未受信データ全件受信」ボタンが見つかりませんでした")
	}

	// 8. 監視ループ (ダウンロード開始 vs 画面メッセージ変化)
	fmt.Println("ダウンロード待機中...")

	var fileData []byte
	resultChan := make(chan string)

	// A. ダウンロード監視
	go func() {
		// パニック対策
		defer func() {
			_ = recover()
		}()
		data := wait()
		fileData = data
		resultChan <- "downloaded"
	}()

	// B. 画面メッセージ監視
	go func() {
		// 最大30秒待つ
		for i := 0; i < 60; i++ {
			time.Sleep(500 * time.Millisecond)

			if body, err := page.Element("body"); err == nil {
				text, _ := body.Text()

				if strings.Contains(text, "ありませんでした") {
					resultChan <- "no_data"
					return
				}
			}
		}
	}()

	// どちらかが来るのを待つ
	select {
	case res := <-resultChan:
		if res == "no_data" {
			// 正常終了ステータスを返す
			return "NO_DATA", nil
		}
		// "downloaded" の場合は下に続く

	case <-time.After(60 * time.Second):
		return "", fmt.Errorf("処理がタイムアウトしました（ダウンロードもメッセージも確認できず）")
	}

	if len(fileData) == 0 {
		return "", fmt.Errorf("ダウンロードデータが空です")
	}

	// 9. ファイル保存
	fileName := fmt.Sprintf("MEDICODE_%s.DAT", time.Now().Format("20060102150405"))
	destPath := filepath.Join(saveDir, fileName)

	if err := os.WriteFile(destPath, fileData, 0644); err != nil {
		return "", fmt.Errorf("ファイルの書き込みに失敗: %v", err)
	}

	fmt.Printf("ダウンロード完了: %s\n", destPath)
	return destPath, nil
}


----- C:\Users\wasab\OneDrive\デスクトップ\TKR\automation\handler.go -----
// C:\Users\wasab\OneDrive\デスクトップ\TKR\automation\handler.go
package automation

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"os"
	"path/filepath"
	"tkr/config"
	"tkr/dat" // ★ ここで正しく dat パッケージをインポート

	"github.com/jmoiron/sqlx"
)

func writeJSONError(w http.ResponseWriter, message string, statusCode int) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	json.NewEncoder(w).Encode(map[string]string{"message": message})
}

func DownloadMedicodeDatHandler(db *sqlx.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		if r.Method != http.MethodPost {
			writeJSONError(w, "Method Not Allowed", http.StatusMethodNotAllowed)
			return
		}

		cfg, err := config.LoadConfig()
		if err != nil {
			writeJSONError(w, "設定の読み込みに失敗しました: "+err.Error(), http.StatusInternalServerError)
			return
		}

		if cfg.MedicodeUserID == "" || cfg.MedicodePassword == "" {
			writeJSONError(w, "MEDICODEのIDまたはパスワードが設定されていません。設定画面で入力してください。", http.StatusBadRequest)
			return
		}

		saveDir := cfg.DatFolderPath
		if saveDir == "" {
			saveDir = os.TempDir()
			log.Printf("DAT保存先設定がないため、一時フォルダを使用します: %s", saveDir)
		}

		log.Println("Starting MEDICODE automation...")
		filePath, err := DownloadDat(cfg.MedicodeUserID, cfg.MedicodePassword, saveDir)

		if err != nil {
			log.Printf("Automation Error: %v", err)
			writeJSONError(w, "自動受信エラー: "+err.Error(), http.StatusInternalServerError)
			return
		}

		if filePath == "NO_DATA" {
			w.Header().Set("Content-Type", "application/json")
			json.NewEncoder(w).Encode(map[string]string{
				"status":  "no_data",
				"message": "未受信のデータはありませんでした。",
			})
			return
		}

		// ▼▼▼ 共通関数 ImportDatStream を呼び出し ▼▼▼
		log.Printf("Importing downloaded file via dat.ImportDatStream: %s", filePath)
		file, err := os.Open(filePath)
		if err != nil {
			writeJSONError(w, "ダウンロードファイルのオープンに失敗: "+err.Error(), http.StatusInternalServerError)
			return
		}
		defer file.Close()

		// ▼▼▼ 引数追加: false (消込を行う) ▼▼▼
		insertedTransactions, err := dat.ImportDatStream(db, file, filepath.Base(filePath), false)
		// ▲▲▲
		if err != nil {
			writeJSONError(w, "DAT取込処理(dat.ImportDatStream)でエラー: "+err.Error(), http.StatusInternalServerError)
			return
		}
		// ▲▲▲ ここまで ▲▲▲

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]interface{}{
			"status":   "success",
			"message":  fmt.Sprintf("ダウンロード＆登録完了: %d件", len(insertedTransactions)),
			"filePath": filePath,
			"records":  insertedTransactions,
		})
	}
}


----- C:\Users\wasab\OneDrive\デスクトップ\TKR\backorder\handler.go -----
// C:\Users\wasab\OneDrive\デスクトップ\TKR\backorder\handler.go
package backorder

import (
	"encoding/json"
	"fmt" // TKRはlogの代わりにfmtを使うことが多い
	"net/http"
	"tkr/database" // TKRのdatabase
	"tkr/mappers"  // TKRのmappers
	"tkr/model"    // TKRのmodel

	"github.com/jmoiron/sqlx"
)

// BackorderView は発注残データを画面表示用に整形します。
// (WASABI: backorder/handler.go より)
type BackorderView struct {
	model.Backorder
	FormattedPackageSpec string `json:"formattedPackageSpec"`
}

/**
 * @brief 全ての発注残リストを取得し、画面表示用に整形して返すためのHTTPハンドラです。
 * (WASABI: backorder/handler.go を TKR 用に修正)
 */
func GetBackordersHandler(conn *sqlx.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// TKRのDB関数を呼ぶ
		backorders, err := database.GetAllBackordersList(conn)
		if err != nil {
			http.Error(w, "Failed to get backorder list", http.StatusInternalServerError)
			return
		}

		backorderViews := make([]BackorderView, 0, len(backorders))
		for _, bo := range backorders {
			// TKRの JcshmsInfo 構造体（units.FormatPackageSpec が要求する型）に合わせる
			// TKRの mappers.ToProductMasterView が TKRの JcshmsInfo 形式のラッパーを使っている
			// TKRの mappers/view.go を参考に、model.ProductMaster を一時的に作成
			tempMaster := model.ProductMaster{
				PackageForm:     bo.PackageForm,
				YjUnitName:      bo.YjUnitName,
				YjPackUnitQty:   bo.YjPackUnitQty,
				JanPackInnerQty: bo.JanPackInnerQty,
				JanPackUnitQty:  bo.JanPackUnitQty,
				JanUnitCode:     bo.JanUnitCode,
			}

			// TKRの ToProductMasterView を使って包装仕様を取得
			// (この関数は内部で TKRの units.FormatPackageSpec を呼んでいる)
			view := mappers.ToProductMasterView(&tempMaster)

			backorderViews = append(backorderViews, BackorderView{
				Backorder:            bo,
				FormattedPackageSpec: view.FormattedPackageSpec, // TKRのマッパーが生成した包装仕様
			})
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(backorderViews)
	}
}

/**
 * @brief 単一の発注残レコードを削除するためのHTTPハンドラです。
 * (WASABI: backorder/handler.go を TKR 用に修正)
 */
func DeleteBackorderHandler(conn *sqlx.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var payload struct {
			ID int `json:"id"`
		}
		if err := json.NewDecoder(r.Body).Decode(&payload); err != nil {
			http.Error(w, "Invalid request body", http.StatusBadRequest)
			return
		}

		tx, err := conn.Beginx()
		if err != nil {
			http.Error(w, "Failed to start transaction", http.StatusInternalServerError)
			return
		}
		defer tx.Rollback()

		// TKRのDB関数を呼ぶ
		if err := database.DeleteBackorderInTx(tx, payload.ID); err != nil {
			http.Error(w, "Failed to delete backorder: "+err.Error(), http.StatusInternalServerError)
			return
		}

		if err := tx.Commit(); err != nil {
			http.Error(w, "Failed to commit transaction", http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]string{"message": "発注残を削除しました。"})
	}
}

/**
 * @brief 複数の発注残レコード（ID指定）を一括で削除するためのHTTPハンドラです。
 * (旧 BulkDeleteBackordersHandler)
 */
func BulkDeleteBackordersByIDHandler(conn *sqlx.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var payload []struct {
			ID int `json:"id"`
		}
		if err := json.NewDecoder(r.Body).Decode(&payload); err != nil {
			http.Error(w, "Invalid request body", http.StatusBadRequest)
			return
		}

		if len(payload) == 0 {
			w.Header().Set("Content-Type", "application/json")
			json.NewEncoder(w).Encode(map[string]string{"message": "削除する項目がありません。"})
			return
		}

		tx, err := conn.Beginx()
		if err != nil {
			http.Error(w, "Failed to start transaction", http.StatusInternalServerError)
			return
		}
		defer tx.Rollback()

		for _, bo := range payload {
			// TKRのDB関数を呼ぶ
			if err := database.DeleteBackorderInTx(tx, bo.ID); err != nil {
				// 1件でも失敗したらエラーを返し、トランザクション全体をロールバック
				http.Error(w, fmt.Sprintf("Failed to delete backorder (ID: %d): %s", bo.ID, err.Error()), http.StatusInternalServerError)
				return
			}
		}

		if err := tx.Commit(); err != nil {
			http.Error(w, "Failed to commit transaction", http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]string{"message": "選択された発注残を削除しました。"})
	}
}

/**
 * @brief 指定された発注日時(order_date)の発注残レコードをすべて削除するためのHTTPハンドラです。
 */
func BulkDeleteBackordersByDateHandler(conn *sqlx.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var payload struct {
			OrderDate string `json:"orderDate"`
		}
		if err := json.NewDecoder(r.Body).Decode(&payload); err != nil {
			http.Error(w, "Invalid request body", http.StatusBadRequest)
			return
		}
		if payload.OrderDate == "" {
			http.Error(w, "orderDate is required", http.StatusBadRequest)
			return
		}

		tx, err := conn.Beginx()
		if err != nil {
			http.Error(w, "Failed to start transaction", http.StatusInternalServerError)
			return
		}
		defer tx.Rollback()

		// TKRのDB関数を呼ぶ
		rowsAffected, err := database.DeleteBackordersByOrderDateInTx(tx, payload.OrderDate)
		if err != nil {
			http.Error(w, "Failed to delete backorders: "+err.Error(), http.StatusInternalServerError)
			return
		}

		if err := tx.Commit(); err != nil {
			http.Error(w, "Failed to commit transaction", http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]string{
			"message": fmt.Sprintf("発注 (日時: %s) に関連する %d 件の品目を削除しました。", payload.OrderDate, rowsAffected),
		})
	}
}


----- C:\Users\wasab\OneDrive\デスクトップ\TKR\barcode\barcode.go -----
// C:\Users\wasab\OneDrive\デスクトップ\TKR\barcode\barcode.go
package barcode

import (
	"fmt"
	"strings"
)

// Result はバーコードの解析結果を格納します
type Result struct {
	Gtin14     string // (01) GTIN (14桁)
	ExpiryDate string // (17) 有効期限 (YYMMDD)
	LotNumber  string // (10) ロット番号
}

// aiLengths は可変長AIの最大長を定義します (ロット(10)のみ)
var aiLengths = map[string]int{
	"10": 20, // ロット番号 (最大20桁)
}

// Parse はスキャンされた文字列を自動判別して解析します。
func Parse(code string) (*Result, error) {
	length := len(code)

	if length == 0 {
		return nil, fmt.Errorf("バーコードが空です")
	}

	// 仕様 1: 15桁以上は AI付き文字列
	if length >= 15 {
		// 01から始まるかチェック
		if strings.HasPrefix(code, "01") {
			return parseAIString(code)
		}
		// 01から始まらない15桁以上は不正とみなす
		return nil, fmt.Errorf("15桁以上ですが、AI(01)で始まっていません")
	}

	// 仕様 2: 14桁は GTIN-14
	if length == 14 {
		return &Result{
			Gtin14: code,
		}, nil
	}

	// 仕様 3: 13桁は JAN-13
	if length == 13 {
		return &Result{
			Gtin14: "0" + code, // 先頭に0を加えて14桁にする
		}, nil
	}

	// 仕様 4: 13桁未満は JAN-8 など
	if length < 13 {
		return &Result{
			Gtin14: fmt.Sprintf("%014s", code), // 先頭から0で埋めて14桁にする
		}, nil
	}

	// (ここに来ることはないはずだが、念のため)
	return nil, fmt.Errorf("不明なバーコード形式です")
}

// parseAIString は 15桁以上のAI付き文字列を解析する内部関数です。
// (旧 parsers/gs1_parser.go のロジック)
func parseAIString(code string) (*Result, error) {
	result := &Result{}
	i := 0
	length := len(code)

	for i < length {
		// (01) GTIN (14桁固定)
		if strings.HasPrefix(code[i:], "01") {
			if i+16 > length { // AI(2) + Data(14)
				return nil, fmt.Errorf("AI(01)のデータが不足しています")
			}
			result.Gtin14 = code[i+2 : i+16]
			i += 16
			continue
		}

		// (17) 有効期限 (6桁固定)
		if strings.HasPrefix(code[i:], "17") {
			if i+8 > length { // AI(2) + Data(6)
				return nil, fmt.Errorf("AI(17)のデータが不足しています")
			}

			// ▼▼▼【ここから修正】YYMMDD を YYYYMM 形式に正規化 ▼▼▼
			expiryYYMMDD := code[i+2 : i+8] // YYMMDD (例: "280100")
			if len(expiryYYMMDD) == 6 {
				yy := expiryYYMMDD[0:2] // "28"
				mm := expiryYYMMDD[2:4] // "01"
				// DB保存形式 (YYYYMM) に変換
				result.ExpiryDate = "20" + yy + mm // "202801"
			} else {
				result.ExpiryDate = expiryYYMMDD // 予期せぬ形式の場合はそのまま
			}
			// ▲▲▲【修正ここまで】▲▲▲

			i += 8
			continue
		}

		// (10) ロット番号 (可変長)
		if strings.HasPrefix(code[i:], "10") {
			if i+2 > length { // AI(2)
				return nil, fmt.Errorf("AI(10)のデータが不足しています")
			}

			dataStart := i + 2
			dataEnd := dataStart
			maxLength := aiLengths["10"]

			for dataEnd < length {
				if (dataEnd - dataStart) >= maxLength { // 最大長
					break
				}

				remaining := code[dataEnd:]

				// 次のAIが「完全な形」で存在する場合のみ区切る
				if len(remaining) >= 2 {
					nextAI := remaining[:2]

					// 次が AI(01) か？ (01 + 14桁データ)
					if nextAI == "01" {
						if len(remaining) >= 16 {
							break
						}
					}
					// 次が AI(17) か？ (17 + 6桁データ)
					if nextAI == "17" {
						if len(remaining) >= 8 {
							break
						}
					}
				}
				dataEnd++
			}

			result.LotNumber = code[dataStart:dataEnd]
			i = dataEnd
			continue
		}

		// 不明なAIまたはデータ部分
		i++
	}

	if result.Gtin14 == "" {
		return nil, fmt.Errorf("バーコードからAI(01)GTINが見つかりませんでした")
	}

	return result, nil
}


----- C:\Users\wasab\OneDrive\デスクトップ\TKR\client\handler.go -----
// C:\Users\wasab\OneDrive\デスクトップ\TKR\client\handler.go
package client

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"regexp"  // ▼▼▼【追加】正規表現パッケージをインポート ▼▼▼
	"strings" // ▼▼▼【追加】strings パッケージをインポート ▼▼▼
	"tkr/database"
	"tkr/parsers"

	"github.com/jmoiron/sqlx"
)

// ▼▼▼【ここに追加】コード形式を判定するための正規表現 ▼▼▼
var (
	// 「CL」で始まるコード（得意先コード）
	clientCodeRegex = regexp.MustCompile(`^CL`)
	// 9桁の数字（卸コード）
	wholesalerCodeRegex = regexp.MustCompile(`^[0-9]{9}$`)
)

// ▲▲▲【追加ここまで】▲▲▲

// ImportClientsHandler は得意先マスタCSVのインポートを処理します。
func ImportClientsHandler(db *sqlx.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		file, _, err := r.FormFile("file")
		if err != nil {
			http.Error(w, "CSVファイルの読み取りに失敗: "+err.Error(), http.StatusBadRequest)
			return
		}
		defer file.Close()

		records, err := parsers.ParseClientCSV(file)
		if err != nil {
			http.Error(w, "CSVファイルの解析に失敗: "+err.Error(), http.StatusBadRequest)
			return
		}

		if len(records) == 0 {
			http.Error(w, "CSVから読み込むデータがありません。", http.StatusBadRequest)
			return
		}

		tx, err := db.Beginx()
		if err != nil {
			http.Error(w, "データベーストランザクションの開始に失敗: "+err.Error(), http.StatusInternalServerError)
			return
		}
		defer tx.Rollback()

		var importedClients int
		var importedWholesalers int
		var errors []string

		for _, rec := range records {
			// ▼▼▼【ここから修正】振り分けロジック ▼▼▼
			clientCode := strings.TrimSpace(rec.ClientCode)
			clientName := strings.TrimSpace(rec.ClientName)

			if clientCodeRegex.MatchString(clientCode) {
				// 1. 得意先コードの条件 ("CL"で始まる) に一致
				if err := database.UpsertClientInTx(tx, clientCode, clientName); err != nil {
					log.Printf("ERROR: Failed to upsert client %s (Name: %s): %v", clientCode, clientName, err)
					errors = append(errors, fmt.Sprintf("得意先 コード %s (名称: %s): %v", clientCode, clientName, err))
				} else {
					importedClients++
				}
			} else if wholesalerCodeRegex.MatchString(clientCode) {
				// 2. 卸コードの条件 (9桁の数字) に一致
				if err := database.UpsertWholesalerInTx(tx, clientCode, clientName); err != nil {
					log.Printf("ERROR: Failed to upsert wholesaler %s (Name: %s): %v", clientCode, clientName, err)
					errors = append(errors, fmt.Sprintf("卸 コード %s (名称: %s): %v", clientCode, clientName, err))
				} else {
					importedWholesalers++
				}
			} else {
				// 3. どちらの条件にも一致しない (スキップ)
				log.Printf("WARN: Skipped CSV row. Code '%s' is neither a client code (CL...) nor a wholesaler code (9 digits).", clientCode)
				errors = append(errors, fmt.Sprintf("スキップ: コード %s (形式不正)", clientCode))
			}
			// ▲▲▲【修正ここまで】▲▲▲
		}

		if err := tx.Commit(); err != nil { //
			http.Error(w, "データベースのコミットに失敗: "+err.Error(), http.StatusInternalServerError)
			return
		}

		// ▼▼▼【ここから修正】メッセージを変更 ▼▼▼
		message := fmt.Sprintf("インポート完了。\n得意先: %d件\n卸: %d件", importedClients, importedWholesalers)
		// ▲▲▲【修正ここまで】▲▲▲
		if len(errors) > 0 {
			message += fmt.Sprintf("\n%d件のエラーまたはスキップが発生しました。", len(errors))
		}

		// (JSの handleFileUpload は results 配列を期待するため、空でも追加)
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]interface{}{
			"message": message,
			"results": []interface{}{}, // 空の results を返す
		})
	}
}


----- C:\Users\wasab\OneDrive\デスクトップ\TKR\config\config.go -----
package config

import (
	"encoding/json"
	"os"
	"sync"
)

type Config struct {
	UsageFolderPath       string `json:"usageFolderPath"`
	DatFolderPath         string `json:"datFolderPath"`
	CalculationPeriodDays int    `json:"calculationPeriodDays"`
	MedicodeUserID        string `json:"medicodeUserID"`
	MedicodePassword      string `json:"medicodePassword"`
}

var (
	cfg Config
	mu  sync.RWMutex
)

const configFilePath = "./tkr_config.json"

func LoadConfig() (Config, error) {
	mu.RLock()
	defer mu.RUnlock()

	file, err := os.ReadFile(configFilePath)
	if err != nil {
		if os.IsNotExist(err) {
			return Config{
				CalculationPeriodDays: 90,
			}, nil
		}
		return Config{}, err
	}

	var tempCfg Config
	if err := json.Unmarshal(file, &tempCfg); err != nil {
		return Config{}, err
	}
	cfg = tempCfg

	if cfg.CalculationPeriodDays == 0 {
		cfg.CalculationPeriodDays = 90
	}

	return cfg, nil
}

func SaveConfig(newCfg Config) error {
	mu.Lock()
	defer mu.Unlock()

	if newCfg.CalculationPeriodDays == 0 {
		newCfg.CalculationPeriodDays = 90
	}

	file, err := json.MarshalIndent(newCfg, "", "  ")
	if err != nil {
		return err
	}

	if err := os.WriteFile(configFilePath, file, 0644); err != nil {
		return err
	}
	cfg = newCfg
	return nil
}

func GetConfig() Config {
	mu.RLock()
	defer mu.RUnlock()
	return cfg
}


----- C:\Users\wasab\OneDrive\デスクトップ\TKR\dat\dat_search_handler.go -----
// C:\Users\wasab\OneDrive\デスクトップ\TKR\dat\dat_search_handler.go
package dat

import (
	"database/sql"
	"encoding/json"
	"errors"
	"fmt"
	"log"
	"net/http"
	"tkr/barcode"
	"tkr/database"

	"github.com/jmoiron/sqlx"
)

// ▼▼▼【ここから削除】dat_utils.go に移管するため ▼▼▼
/*
func respondJSONError(w http.ResponseWriter, message string, statusCode int) {
	log.Println("Error response:", message)
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	json.NewEncoder(w).Encode(map[string]interface{}{
		"message": message,
		"results": []interface{}{},
	})
}
*/
// ▲▲▲【削除ここまで】▲▲▲

func SearchDatHandler(db *sqlx.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		if r.Method != http.MethodGet {
			respondJSONError(w, "Method Not Allowed", http.StatusMethodNotAllowed)
			return
		}

		barcodeStr := r.URL.Query().Get("barcode")
		log.Printf("Received DAT search request... Barcode: [%s]", barcodeStr)

		if barcodeStr == "" {
			respondJSONError(w, "バーコードを入力してください。", http.StatusBadRequest)
			return
		}

		master, err := database.GetProductMasterByBarcode(db, barcodeStr)
		if err != nil {
			if errors.Is(err, sql.ErrNoRows) {
				log.Printf("Product master not found for Barcode: %s", barcodeStr)
				respondJSONError(w, "バーコードに対応するマスターが見つかりません。", http.StatusNotFound)
			} else {
				log.Printf("Error searching product master by Barcode %s: %v", barcodeStr, err)
				respondJSONError(w, fmt.Sprintf("マスター検索エラー: %v", err), http.StatusInternalServerError)
			}
			return
		}

		productCode := master.ProductCode

		var expiryYYYYMM, lotNumber string
		if len(barcodeStr) > 14 {
			gs1Result, parseErr := barcode.Parse(barcodeStr)
			if parseErr == nil && gs1Result != nil {
				expiryYYYYMM = gs1Result.ExpiryDate
				lotNumber = gs1Result.LotNumber
			}
		}

		log.Printf("Search criteria: ProductCode(JAN)='%s', Expiry(YYYYMM)='%s', Lot='%s'",
			productCode, expiryYYYYMM, lotNumber)

		transactions, err := database.SearchTransactions(db, productCode, expiryYYYYMM, lotNumber)

		if err != nil {
			log.Printf("Error searching transactions: %v", err)
			respondJSONError(w, "トランザクション検索中にエラーが発生しました。", http.StatusInternalServerError)
			return
		}

		log.Printf("Found %d transactions matching criteria.", len(transactions))

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]interface{}{
			"message":      fmt.Sprintf("%d 件のデータが見つかりました。", len(transactions)),
			"transactions": transactions,
		})
	}
}


----- C:\Users\wasab\OneDrive\デスクトップ\TKR\dat\dat_upload_handler.go -----
// C:\Users\wasab\OneDrive\デスクトップ\TKR\dat\dat_upload_handler.go
package dat

import (
	"bufio"
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"mime/multipart"
	"net/http"
	"os"
	"path/filepath"
	"strings"
	"time"
	"tkr/database"
	"tkr/mappers"
	"tkr/mastermanager"
	"tkr/model"
	"tkr/parsers"

	"github.com/jmoiron/sqlx"
)

// UploadDatHandler はブラウザからのアップロードを受け付けます
func UploadDatHandler(db *sqlx.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		log.Println("Received DAT upload request...")

		err := r.ParseMultipartForm(32 << 20)
		if err != nil {
			respondJSONError(w, "File upload error: "+err.Error(), http.StatusBadRequest)
			return
		}
		defer r.MultipartForm.RemoveAll()

		// ▼▼▼ 追加: 修正モードかどうかの判定 ▼▼▼
		mode := r.FormValue("mode")
		skipReconcile := (mode == "fix_only")
		if skipReconcile {
			log.Println("Mode: fix_only (Skipping backorder reconciliation)")
		}
		// ▲▲▲ 追加ここまで ▲▲▲

		var processedFiles []string
		var successfullyInsertedTransactions []model.TransactionRecord
		var allResults []map[string]interface{}

		for _, fileHeader := range r.MultipartForm.File["file"] {
			log.Printf("Processing file: %s", fileHeader.Filename)
			processedFiles = append(processedFiles, fileHeader.Filename)
			fileResult := map[string]interface{}{"filename": fileHeader.Filename}

			file, openErr := fileHeader.Open()
			if openErr != nil {
				log.Printf("Failed to open uploaded file %s: %v", fileHeader.Filename, openErr)
				fileResult["error"] = fmt.Sprintf("Failed to open file: %v", openErr)
				allResults = append(allResults, fileResult)
				continue
			}

			// ▼▼▼ 修正: アーカイブと共通関数呼び出し ▼▼▼
			// 1. ファイルをメモリに読み込む（アーカイブ用とパース用）
			fileBytes, readErr := io.ReadAll(file)
			file.Close()
			if readErr != nil {
				fileResult["error"] = fmt.Sprintf("Failed to read file: %v", readErr)
				allResults = append(allResults, fileResult)
				continue
			}

			// 2. アーカイブ保存 (Sレコード解析)
			archivePath, archiveErr := archiveDatFile(fileBytes)
			if archiveErr != nil {
				log.Printf("WARN: Failed to archive DAT file: %v", archiveErr)
			} else if archivePath != "" {
				log.Printf("Archived DAT file to: %s", archivePath)
			} else {
				log.Printf("File already archived (skipped save).")
			}

			// 3. 共通関数を呼び出す (バイト列からReaderを作成)
			inserted, err := ImportDatStream(db, bytes.NewReader(fileBytes), fileHeader.Filename, skipReconcile)
			// ▲▲▲ 修正ここまで ▲▲▲

			if err != nil {
				log.Printf("Failed to process DAT file %s: %v", fileHeader.Filename, err)
				fileResult["error"] = fmt.Sprintf("Failed to process: %v", err)
				allResults = append(allResults, fileResult)
				continue
			}

			successfullyInsertedTransactions = append(successfullyInsertedTransactions, inserted...)
			log.Printf("Successfully inserted %d records from %s", len(inserted), fileHeader.Filename)
			fileResult["success"] = true
			fileResult["records_inserted"] = len(inserted)
			allResults = append(allResults, fileResult)
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]interface{}{
			"message": fmt.Sprintf("Processed %d DAT file(s). See results for details.", len(processedFiles)),
			"results": allResults,
			"records": successfullyInsertedTransactions,
		})
		log.Println("Finished DAT upload request.")
	}
}

// archiveDatFile はSレコードを解析してファイルを保存します
func archiveDatFile(data []byte) (string, error) {
	// 保存先ディレクトリ
	archiveDir := "archive/dat"
	if err := os.MkdirAll(archiveDir, 0755); err != nil {
		return "", err
	}

	// Sレコードを探す
	scanner := bufio.NewScanner(bytes.NewReader(data))
	var sRecord string
	for scanner.Scan() {
		line := scanner.Text()
		if strings.HasPrefix(line, "S") {
			sRecord = line
			break
		}
	}

	if sRecord == "" || len(sRecord) < 39 {
		// Sレコードがない、または短すぎる場合は現在時刻で保存
		fileName := fmt.Sprintf("UNKNOWN_%s.DAT", time.Now().Format("20060102_150405"))
		return saveFileIfNotExists(filepath.Join(archiveDir, fileName), data)
	}

	// 解析: S20902020014 05262978172736251112050241
	// 日付: 27-33文字目 (251112)
	// 時刻: 33-39文字目 (050241)
	datePart := sRecord[27:33] // YYMMDD
	timePart := sRecord[33:39] // HHMMSS

	// 西暦補完 (25 -> 2025)
	fullDate := "20" + datePart

	fileName := fmt.Sprintf("%s_%s.DAT", fullDate, timePart)
	savePath := filepath.Join(archiveDir, fileName)

	return saveFileIfNotExists(savePath, data)
}

func saveFileIfNotExists(path string, data []byte) (string, error) {
	if _, err := os.Stat(path); err == nil {
		// ファイルが既に存在する -> 内容を確認すべきだが、今回は名前重複＝保存済みとみなす
		return "", nil
	}
	if err := os.WriteFile(path, data, 0644); err != nil {
		return "", err
	}
	return path, nil
}

// ▼▼▼ 修正: skipReconcile 引数を追加 ▼▼▼
func ImportDatStream(db *sqlx.DB, r io.Reader, filename string, skipReconcile bool) ([]model.TransactionRecord, error) {
	parsedRecords, parseErr := parsers.ParseDat(r)
	if parseErr != nil {
		return nil, fmt.Errorf("DAT parse error: %w", parseErr)
	}

	tx, txErr := db.Beginx()
	if txErr != nil {
		return nil, fmt.Errorf("failed to start transaction: %w", txErr)
	}
	defer tx.Rollback()

	insertedTransactions, processErr := ProcessDatRecords(tx, parsedRecords)
	if processErr != nil {
		return nil, fmt.Errorf("process records error: %w", processErr)
	}

	// 発注残消込処理 (skipReconcileがfalseの場合のみ実行)
	if !skipReconcile && len(insertedTransactions) > 0 {
		var deliveredItems []model.Backorder
		for _, rec := range insertedTransactions {
			if rec.Flag == 1 { // 納品
				deliveredItems = append(deliveredItems, model.Backorder{
					YjCode:          rec.YjCode,
					PackageForm:     rec.PackageForm,
					JanPackInnerQty: rec.JanPackInnerQty,
					YjUnitName:      rec.YjUnitName,
					YjQuantity:      rec.YjQuantity,
				})
			}
		}

		if len(deliveredItems) > 0 {
			if err := database.ReconcileBackorders(tx, deliveredItems); err != nil {
				log.Printf("WARN: Failed to reconcile backorders after DAT import (%s): %v", filename, err)
			}
		}
	}

	if commitErr := tx.Commit(); commitErr != nil {
		return nil, fmt.Errorf("commit error: %w", commitErr)
	}

	return insertedTransactions, nil
}

// ▲▲▲ 修正ここまで ▲▲▲

// ... (removeDatDuplicates, ProcessDatRecords, OpenFileHeader は前回の回答と同じ内容のため省略可能ですが、全体を要求されている場合は含めます)
// 前回の回答で修正した「マスタからの補完ロジック削除」済みの ProcessDatRecords を使用します。

func removeDatDuplicates(records []model.DatRecord) []model.DatRecord {
	seen := make(map[string]struct{})
	var result []model.DatRecord
	for _, r := range records {
		key := fmt.Sprintf("%s|%s|%s|%s|%s", r.Date, r.ClientCode, r.ReceiptNumber, r.JanCode, r.LineNumber)
		if _, ok := seen[key]; ok {
			continue
		}
		seen[key] = struct{}{}
		result = append(result, r)
	}
	return result
}

func ProcessDatRecords(tx *sqlx.Tx, parsedRecords []model.DatRecord) ([]model.TransactionRecord, error) {
	var insertedTransactions []model.TransactionRecord

	recordsToProcess := removeDatDuplicates(parsedRecords)

	if len(recordsToProcess) == 0 {
		return insertedTransactions, nil
	}

	receiptKeysToDelete := make(map[string]struct {
		Date       string
		ClientCode string
	})
	for _, rec := range recordsToProcess {
		if rec.Flag == 1 || rec.Flag == 2 {
			receiptKeysToDelete[rec.ReceiptNumber] = struct {
				Date       string
				ClientCode string
			}{
				Date:       rec.Date,
				ClientCode: rec.ClientCode,
			}
		}
	}

	for receiptNumber, keyInfo := range receiptKeysToDelete {
		log.Printf("Deleting existing DAT records for Receipt: %s, Date: %s, Client: %s", receiptNumber, keyInfo.Date, keyInfo.ClientCode)
		const q = `DELETE FROM transaction_records WHERE receipt_number = ? AND transaction_date = ? AND client_code = ? AND flag IN (1, 2)`
		_, err := tx.Exec(q, receiptNumber, keyInfo.Date, keyInfo.ClientCode)
		if err != nil {
			return nil, fmt.Errorf("failed to delete existing DAT records for receipt %s: %w", receiptNumber, err)
		}
	}

	for _, rec := range recordsToProcess {
		key := rec.JanCode

		master, err := mastermanager.FindOrCreateMaster(tx, key, rec.ProductName)
		if err != nil {
			return nil, fmt.Errorf("master creation failed for key %s: %w", key, err)
		}

		if master.Origin != "JCSHMS" && master.KanaNameShort != rec.ProductName {
			log.Printf("Updating non-JCSHMS master (ProductCode: %s) KanaNameShort from '%s' to '%s'",
				master.ProductCode, master.KanaNameShort, rec.ProductName)

			input := mastermanager.MasterToInput(master)
			input.KanaNameShort = rec.ProductName

			updatedMaster, upsertErr := mastermanager.UpsertProductMasterSqlx(tx, input)
			if upsertErr != nil {
				return nil, fmt.Errorf("failed to update kana_name_short for existing master %s: %w", master.ProductCode, upsertErr)
			}
			*master = *updatedMaster
		}

		transaction := model.TransactionRecord{
			TransactionDate: rec.Date,
			ClientCode:      rec.ClientCode,
			ReceiptNumber:   rec.ReceiptNumber,
			LineNumber:      rec.LineNumber,
			Flag:            rec.Flag,
			DatQuantity:     rec.DatQuantity,
			UnitPrice:       rec.UnitPrice,
			Subtotal:        rec.Subtotal,
			ExpiryDate:      rec.ExpiryDate,
			LotNumber:       rec.LotNumber,
		}

		transaction.YjQuantity = rec.DatQuantity * master.YjPackUnitQty

		if master.JanPackInnerQty > 0 {
			transaction.JanQuantity = transaction.YjQuantity / master.JanPackInnerQty
		} else {
			transaction.JanQuantity = 0
		}

		// マスタからの補完ロジックは削除済み

		mappers.MapMasterToTransaction(&transaction, master)

		if err := database.InsertTransactionRecord(tx, transaction); err != nil {
			return nil, fmt.Errorf("transaction insert failed for key %s: %w", key, err)
		}
		insertedTransactions = append(insertedTransactions, transaction)
	}
	return insertedTransactions, nil
}

func OpenFileHeader(fh *multipart.FileHeader) (multipart.File, error) {
	return fh.Open()
}


----- C:\Users\wasab\OneDrive\デスクトップ\TKR\dat\dat_utils.go -----
// C:\Users\wasab\OneDrive\デスクトップ\TKR\dat\dat_utils.go
package dat

import (
	"encoding/json"
	"log"
	"net/http"
)

// respondJSONError は dat パッケージ共有のエラーレスポンス関数です
func respondJSONError(w http.ResponseWriter, message string, statusCode int) {
	log.Println("Error response:", message)
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	json.NewEncoder(w).Encode(map[string]interface{}{
		"message": message,
		"results": []interface{}{},
	})
}


----- C:\Users\wasab\OneDrive\デスクトップ\TKR\database\backorders.go -----
// C:\Users\wasab\OneDrive\デスクトップ\TKR\database\backorders.go
package database

import (
	"database/sql"
	"fmt"
	"tkr/model"

	"github.com/jmoiron/sqlx"
)

func InsertBackordersInTx(tx *sqlx.Tx, backorders []model.Backorder) error {
	const q = `
		INSERT INTO backorders (
			order_date, jan_code, yj_code, product_name, package_form, jan_pack_inner_qty, 
			yj_unit_name, order_quantity, remaining_quantity, wholesaler_code,
			yj_pack_unit_qty, jan_pack_unit_qty, jan_unit_code
		) 
		VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`

	stmt, err := tx.Prepare(q)
	if err != nil {
		return fmt.Errorf("failed to prepare backorder insert statement: %w", err)
	}
	defer stmt.Close()

	for _, bo := range backorders {
		_, err := stmt.Exec(
			bo.OrderDate, bo.JanCode, bo.YjCode, bo.ProductName, bo.PackageForm, bo.JanPackInnerQty,
			bo.YjUnitName, bo.OrderQuantity, bo.RemainingQuantity, bo.WholesalerCode,
			bo.YjPackUnitQty, bo.JanPackUnitQty, bo.JanUnitCode,
		)
		if err != nil {
			return fmt.Errorf("failed to execute backorder insert for yj %s: %w", bo.YjCode, err)
		}
	}
	return nil
}

func ReconcileBackorders(tx *sqlx.Tx, deliveredItems []model.Backorder) error {
	for _, item := range deliveredItems {
		deliveryQty := item.YjQuantity

		// 消込処理では予約分(_RSV)を対象外にする（勝手に消されないように保護）
		rows, err := tx.Query(`
			SELECT id, remaining_quantity FROM backorders 
			WHERE yj_code = ? AND package_form = ? AND jan_pack_inner_qty = ? AND yj_unit_name = ?
			AND wholesaler_code NOT LIKE '%_RSV'
			ORDER BY order_date, id`,
			item.YjCode, item.PackageForm, item.JanPackInnerQty, item.YjUnitName,
		)
		if err != nil {
			return fmt.Errorf("failed to query backorders for reconciliation: %w", err)
		}

		type updateAction struct {
			id           int
			deleteRecord bool
			newRemaining float64
		}
		var actions []updateAction

		for rows.Next() {
			if deliveryQty <= 0 {
				break
			}
			var id int
			var remainingQty float64
			if err := rows.Scan(&id, &remainingQty); err != nil {
				rows.Close()
				return fmt.Errorf("failed to scan backorder row: %w", err)
			}

			if deliveryQty >= remainingQty {
				actions = append(actions, updateAction{id: id, deleteRecord: true})
				deliveryQty -= remainingQty
			} else {
				newRemaining := remainingQty - deliveryQty
				actions = append(actions, updateAction{id: id, deleteRecord: false, newRemaining: newRemaining})
				deliveryQty = 0
			}
		}
		rows.Close()

		for _, action := range actions {
			if action.deleteRecord {
				if _, err := tx.Exec(`DELETE FROM backorders WHERE id = ?`, action.id); err != nil {
					return fmt.Errorf("failed to delete reconciled backorder id %d: %w", action.id, err)
				}
			} else {
				if _, err := tx.Exec(`UPDATE backorders SET remaining_quantity = ? WHERE id = ?`, action.newRemaining, action.id); err != nil {
					return fmt.Errorf("failed to update partially reconciled backorder id %d: %w", action.id, err)
				}
			}
		}
	}
	return nil
}

func GetAllBackordersMap(dbtx DBTX) (map[string]float64, error) {
	// ★修正: WHERE句を削除しました。これで予約分も集計に含まれます。
	const q = `
		SELECT yj_code, package_form, jan_pack_inner_qty, yj_unit_name, SUM(remaining_quantity)
		FROM backorders
		GROUP BY yj_code, package_form, jan_pack_inner_qty, yj_unit_name`

	rows, err := dbtx.Query(q)
	if err != nil {
		return nil, fmt.Errorf("failed to query all backorders map: %w", err)
	}
	defer rows.Close()

	backordersMap := make(map[string]float64)
	for rows.Next() {
		var yjCode, packageForm, yjUnitName string
		var janPackInnerQty, totalRemaining float64
		if err := rows.Scan(&yjCode, &packageForm, &janPackInnerQty, &yjUnitName, &totalRemaining); err != nil {
			return nil, err
		}
		key := fmt.Sprintf("%s|%s|%g|%s", yjCode, packageForm, janPackInnerQty, yjUnitName)
		backordersMap[key] = totalRemaining
	}
	return backordersMap, nil
}

func GetAllBackordersList(dbtx DBTX) ([]model.Backorder, error) {
	const q = `
		SELECT
			id, order_date, jan_code, yj_code, product_name, package_form, jan_pack_inner_qty, 
			yj_unit_name, order_quantity, remaining_quantity, wholesaler_code,
			yj_pack_unit_qty, jan_pack_unit_qty, jan_unit_code
		FROM backorders
		ORDER BY order_date, wholesaler_code, product_name, id
	`

	rows, err := dbtx.Query(q)
	if err != nil {
		return nil, fmt.Errorf("failed to query all backorders list: %w", err)
	}
	defer rows.Close()

	var backorders []model.Backorder
	for rows.Next() {
		var bo model.Backorder
		var wholesalerCode sql.NullString
		var janCode sql.NullString

		if err := rows.Scan(
			&bo.ID, &bo.OrderDate, &janCode, &bo.YjCode, &bo.ProductName, &bo.PackageForm, &bo.JanPackInnerQty,
			&bo.YjUnitName, &bo.OrderQuantity, &bo.RemainingQuantity, &wholesalerCode,
			&bo.YjPackUnitQty, &bo.JanPackUnitQty, &bo.JanUnitCode,
		); err != nil {
			return nil, err
		}

		bo.WholesalerCode = wholesalerCode.String
		bo.JanCode = janCode.String

		backorders = append(backorders, bo)
	}
	return backorders, nil
}

func DeleteBackorderInTx(tx *sqlx.Tx, id int) error {
	const q = `DELETE FROM backorders WHERE id = ?`
	res, err := tx.Exec(q, id)
	if err != nil {
		return fmt.Errorf("failed to delete backorder for id %d: %w", id, err)
	}
	rowsAffected, err := res.RowsAffected()
	if err != nil {
		return fmt.Errorf("failed to get rows affected for backorder id %d: %w", id, err)
	}
	if rowsAffected == 0 {
		return fmt.Errorf("no backorder found to delete for id %d", id)
	}
	return nil
}

func DeleteBackordersByOrderDateInTx(tx *sqlx.Tx, orderDate string) (int64, error) {
	const q = `DELETE FROM backorders WHERE order_date = ?`
	res, err := tx.Exec(q, orderDate)
	if err != nil {
		return 0, fmt.Errorf("failed to delete backorders for orderDate %s: %w", orderDate, err)
	}
	rowsAffected, err := res.RowsAffected()
	if err != nil {
		return 0, fmt.Errorf("failed to get rows affected for orderDate %s: %w", orderDate, err)
	}
	if rowsAffected == 0 {
		return 0, fmt.Errorf("no backorder found to delete for orderDate %s", orderDate)
	}
	return rowsAffected, nil
}

// 予約解除判定用の関数
func GetExpiredReservationsInTx(tx *sqlx.Tx, nowStr string) ([]model.Backorder, error) {
	const q = `
		SELECT
			id, order_date, jan_code, yj_code, product_name, package_form, jan_pack_inner_qty, 
			yj_unit_name, order_quantity, remaining_quantity, wholesaler_code,
			yj_pack_unit_qty, jan_pack_unit_qty, jan_unit_code
		FROM backorders
		WHERE REPLACE(order_date, 'T', '') <= ? AND wholesaler_code LIKE '%_RSV'
	`
	var records []model.Backorder
	rows, err := tx.Query(q, nowStr)
	if err != nil {
		return nil, fmt.Errorf("failed to query expired reservations: %w", err)
	}
	defer rows.Close()

	for rows.Next() {
		var bo model.Backorder
		var wholesalerCode sql.NullString
		var janCode sql.NullString

		if err := rows.Scan(
			&bo.ID, &bo.OrderDate, &janCode, &bo.YjCode, &bo.ProductName, &bo.PackageForm, &bo.JanPackInnerQty,
			&bo.YjUnitName, &bo.OrderQuantity, &bo.RemainingQuantity, &wholesalerCode,
			&bo.YjPackUnitQty, &bo.JanPackUnitQty, &bo.JanUnitCode,
		); err != nil {
			return nil, fmt.Errorf("failed to scan expired reservation: %w", err)
		}
		bo.WholesalerCode = wholesalerCode.String
		bo.JanCode = janCode.String
		records = append(records, bo)
	}

	return records, nil
}


----- C:\Users\wasab\OneDrive\デスクトップ\TKR\database\clients.go -----
// C:\Users\wasab\OneDrive\デスクトップ\TKR\database\clients.go (全体)
package database

import (
	"database/sql"
	"fmt"
	"tkr/model"

	"github.com/jmoiron/sqlx"
)

// ▼▼▼【ここから追加】GetClientMap ▼▼▼
// GetClientMap は全ての得意先（卸として使用）をマップで取得します。
func GetClientMap(db *sqlx.DB) (map[string]string, error) {
	clients, err := GetAllClients(db)
	if err != nil {
		return nil, fmt.Errorf("failed to get client list for map: %w", err)
	}

	clientMap := make(map[string]string)
	for _, c := range clients {
		clientMap[c.ClientCode] = c.ClientName
	}
	return clientMap, nil
}

// ▲▲▲【追加ここまで】▲▲▲

// UpsertClientInTx は得意先マスタにデータを挿入または置換します。
func UpsertClientInTx(tx *sqlx.Tx, code, name string) error {
	// client_master の client_name は UNIQUE
	// client_code が競合した場合は、client_name を更新します。
	const q = `
		INSERT INTO client_master (client_code, client_name) 
		VALUES (?, ?)
		ON CONFLICT(client_code) DO UPDATE SET
			client_name = excluded.client_name
	`
	_, err := tx.Exec(q, code, name)
	if err != nil {
		// client_name の UNIQUE 制約違反も考慮
		return fmt.Errorf("UpsertClientInTx (Code: %s, Name: %s) failed: %w", code, name, err)
	}
	return nil
}

func CreateClientInTx(tx *sqlx.Tx, code, name string) error {
	const q = `INSERT INTO client_master (client_code, client_name) VALUES (?, ?)`
	_, err := tx.Exec(q, code, name)
	if err != nil {
		return fmt.Errorf("CreateClientInTx failed: %w", err)
	}
	return nil
}

func CheckClientExistsByName(tx *sqlx.Tx, name string) (bool, error) {
	var exists int
	const q = `SELECT 1 FROM client_master WHERE client_name = ? LIMIT 1`
	err := tx.QueryRow(q, name).Scan(&exists)
	if err != nil {
		if err == sql.ErrNoRows {
			return false, nil
		}
		return false, fmt.Errorf("CheckClientExistsByName failed: %w", err)
	}
	return true, nil
}

func GetAllClients(db *sqlx.DB) ([]model.Client, error) {
	var clients []model.Client
	err := db.Select(&clients, "SELECT client_code, client_name FROM client_master ORDER BY client_code")
	if err != nil {
		return nil, fmt.Errorf("failed to get all clients: %w", err)
	}
	return clients, nil
}


----- C:\Users\wasab\OneDrive\デスクトップ\TKR\database\deadstock_query.go -----
// C:\Users\wasab\OneDrive\デスクトップ\TKR\database\deadstock_query.go
package database

import (
	"fmt"
	"log"
	"time"
	"tkr/model"
	"tkr/units"

	"github.com/jmoiron/sqlx"
)

// GetDeadStockList は、指定された期間に処方(flag=3)されていない在庫品目（不動在庫）のリストを取得します。
func GetDeadStockList(db *sqlx.DB, startDate, endDate string, excludeZeroStock bool) ([]model.DeadStockItem, error) {

	// B: 期間内に処方(flag=3)された package_key のリストを作成
	const movedKeysQuery = `
		SELECT DISTINCT 
			T.yj_code || '|' || 
			COALESCE(T.package_form, '不明') || '|' || 
			PRINTF('%g', COALESCE(T.jan_pack_inner_qty, 0)) || '|' ||
			COALESCE(U.name, T.yj_unit_name, '不明') AS package_key
		FROM transaction_records AS T
		LEFT JOIN units AS U ON T.yj_unit_name = U.code
		WHERE T.flag = 3 
		  AND T.transaction_date BETWEEN ? AND ?
	`

	// A: product_master から構築した全 package_key
	const allMasterKeysQuery = `
		SELECT
			P.yj_code || '|' || 
			COALESCE(P.package_form, '不明') || '|' ||
			PRINTF('%g', COALESCE(P.jan_pack_inner_qty, 0)) || '|' || 
			COALESCE(U.name, P.yj_unit_name, '不明') AS package_key,
			P.yj_code,
			MIN(P.kana_name) as kana_name, 
			MIN(P.usage_classification) as usage_classification,
			MIN(P.jan_pack_inner_qty) as jan_pack_inner_qty
		FROM product_master AS P
		LEFT JOIN units AS U ON P.yj_unit_name = U.code
		WHERE P.yj_code != "" 
		GROUP BY package_key, P.yj_code
	`

	// メインクエリ
	// StockQuantityYj には「前回棚卸数(package_stock)」を取得する
	query := `
		SELECT 
			A.package_key, 
			A.yj_code, 
			COALESCE(PS.stock_quantity_yj, 0) AS stock_quantity_yj, -- 前回棚卸数
			A.kana_name,
			A.usage_classification,
			A.jan_pack_inner_qty
		FROM (
			` + allMasterKeysQuery + `
		) AS A
		LEFT JOIN (
			` + movedKeysQuery + `
		) AS B ON A.package_key = B.package_key
		LEFT JOIN package_stock AS PS ON A.package_key = PS.package_key
		WHERE 
			B.package_key IS NULL -- 期間内に動きがなかったもの
	`

	// SQL段階での除外判定には前回棚卸数を使用（参考程度）
	// 厳密な excludeZeroStock 判定は後続のGoロジックで現在在庫を計算してから行う
	query += `
		ORDER BY 
			CASE COALESCE(A.usage_classification, '他')
				WHEN '内' THEN 1
				WHEN '外' THEN 2
				WHEN '歯' THEN 3
				WHEN '注' THEN 4
				WHEN '機' THEN 5
				WHEN '他' THEN 6
				ELSE 7
			END,
			A.kana_name,
			A.package_key
	`

	var items []model.DeadStockItem
	if err := db.Select(&items, query, startDate, endDate); err != nil {
		return nil, fmt.Errorf("failed to select dead stock list (A-B): %w", err)
	}

	if len(items) == 0 {
		return []model.DeadStockItem{}, nil
	}

	// 2. 詳細情報取得のための準備
	yjCodesMap := make(map[string]bool)
	for _, item := range items {
		if item.YjCode != "" {
			yjCodesMap[item.YjCode] = true
		}
	}
	var yjCodes []string
	for yj := range yjCodesMap {
		yjCodes = append(yjCodes, yj)
	}

	// 関連マスタの取得
	productCodes, err := GetProductCodesByYjCodes(db, yjCodes)
	if err != nil {
		return nil, fmt.Errorf("failed to get product codes for dead stock details: %w", err)
	}
	mastersMap, err := GetProductMastersByCodesMap(db, productCodes)
	if err != nil {
		return nil, fmt.Errorf("failed to get product masters map for dead stock details: %w", err)
	}
	var masters []*model.ProductMaster
	for _, m := range mastersMap {
		masters = append(masters, m)
	}

	// マスタを PackageKey ごとにグルーピング
	janCodesByPackageKey := make(map[string][]string)
	masterInfoByPackageKey := make(map[string]*model.ProductMaster)
	representativeJanByPackageKey := make(map[string]string)

	for _, m := range masters {
		key := GeneratePackageKey(m)
		janCodesByPackageKey[key] = append(janCodesByPackageKey[key], m.ProductCode)

		// 表示用・計算用の代表マスタを選定
		if current, exists := masterInfoByPackageKey[key]; !exists {
			masterInfoByPackageKey[key] = m
			representativeJanByPackageKey[key] = m.ProductCode
		} else if current.Origin != "JCSHMS" && m.Origin == "JCSHMS" {
			masterInfoByPackageKey[key] = m
			representativeJanByPackageKey[key] = m.ProductCode
		}
	}

	today := time.Now().Format("20060102")
	var resultItems []model.DeadStockItem

	// 3. 各項目の詳細設定と現在在庫計算
	for i := range items {
		item := &items[i]

		// 代表JANを使って「現在の正確な理論在庫」を計算
		repJan, hasRep := representativeJanByPackageKey[item.PackageKey]
		if hasRep {
			currentStock, err := CalculateStockOnDate(db, repJan, today)
			if err != nil {
				log.Printf("WARN: Failed to calculate stock for %s: %v", repJan, err)
				item.CurrentStockYj = item.StockQuantityYj // エラー時は前回棚卸数を入れる
			} else {
				item.CurrentStockYj = currentStock
			}
		} else {
			item.CurrentStockYj = 0
		}

		// 「在庫0を除外」オプションの適用（現在在庫で判定）
		if excludeZeroStock && item.CurrentStockYj <= 0 {
			continue
		}

		// 代表品名などの設定
		if master, ok := masterInfoByPackageKey[item.PackageKey]; ok {
			item.ProductName = master.ProductName
			item.PackageSpec = fmt.Sprintf("%s %g%s", master.PackageForm, master.YjPackUnitQty, units.ResolveName(master.YjUnitName))
			if master.JanPackInnerQty > 0 {
				item.PackageSpec += fmt.Sprintf(" (%g%s×%g%s)",
					master.JanPackInnerQty, units.ResolveName(master.YjUnitName), master.JanPackUnitQty, units.ResolveName(fmt.Sprintf("%d", master.JanUnitCode)))
			}
		}

		// ロット詳細（前回棚卸時の明細）を取得
		targetJanCodes := janCodesByPackageKey[item.PackageKey]
		if len(targetJanCodes) > 0 {
			q := `
				SELECT 
					T.jan_code, 
					COALESCE(P.gs1_code, '') AS gs1_code, 
					T.package_spec, 
					T.expiry_date, 
					T.lot_number, 
					T.jan_quantity, 
					T.jan_unit_name
				FROM transaction_records AS T
				LEFT JOIN product_master AS P ON T.jan_code = P.product_code
				WHERE T.jan_code IN (?) 
				  AND T.flag = 0 
				  AND T.transaction_date = (
					  SELECT MAX(last_inventory_date) 
					  FROM package_stock 
					  WHERE package_key = ?
				)
				ORDER BY T.expiry_date, T.lot_number
			`
			query, args, err := sqlx.In(q, targetJanCodes, item.PackageKey)
			if err != nil {
				log.Printf("WARN: Failed to build IN query for dead stock details: %v", err)
				item.LotDetails = []model.LotDetail{}
			} else {
				query = db.Rebind(query)
				err = db.Select(&item.LotDetails, query, args...)
				if err != nil {
					item.LotDetails = []model.LotDetail{}
				}
			}
		} else {
			item.LotDetails = []model.LotDetail{}
		}

		resultItems = append(resultItems, *item)
	}

	return resultItems, nil
}


----- C:\Users\wasab\OneDrive\デスクトップ\TKR\database\deadstock.go -----
// C:\Users\wasab\OneDrive\デスクトップ\TKR\database\deadstock.go
package database

import (
	"fmt"
	"time"
	"tkr/model"

	"github.com/jmoiron/sqlx"
)

// GetDeadStockByYjCode は指定されたYJコードに紐づくロット・期限情報を取得します。
// (WASABI: db/deadstock.go  より移植)
func GetDeadStockByYjCode(tx *sqlx.Tx, yjCode string) ([]model.DeadStockRecord, error) {
	const q = `
		SELECT id, product_code, stock_quantity_jan, expiry_date, lot_number,
		       yj_code, package_form, jan_pack_inner_qty, yj_unit_name
		FROM dead_stock_list 
		WHERE yj_code = ?
		ORDER BY product_code, expiry_date, lot_number`

	rows, err := tx.Queryx(q, yjCode)
	if err != nil {
		return nil, fmt.Errorf("failed to query dead stock by yj_code: %w", err)
	}
	defer rows.Close()

	var records []model.DeadStockRecord
	for rows.Next() {
		var r model.DeadStockRecord
		if err := rows.Scan(&r.ID, &r.ProductCode, &r.StockQuantityJan, &r.ExpiryDate, &r.LotNumber, &r.YjCode, &r.PackageForm, &r.JanPackInnerQty, &r.YjUnitName); err != nil {
			return nil, err
		}
		records = append(records, r)
	}
	return records, nil
}

// DeleteDeadStockByProductCodesInTx は指定された製品コード群のロット・期限情報を削除します。
// (WASABI: db/deadstock.go  より移植)
func DeleteDeadStockByProductCodesInTx(tx *sqlx.Tx, productCodes []string) error {
	if len(productCodes) == 0 {
		return nil
	}
	query, args, err := sqlx.In("DELETE FROM dead_stock_list WHERE product_code IN (?)", productCodes)
	if err != nil {
		return fmt.Errorf("failed to create IN query for deleting dead stock: %w", err)
	}
	query = tx.Rebind(query)
	_, err = tx.Exec(query, args...)
	if err != nil {
		return fmt.Errorf("failed to delete dead stock records by product codes: %w", err)
	}
	return nil
}

// SaveDeadStockListInTx はロット・期限情報のリストを保存（UPSERT）します。
// (WASABI: db/deadstock.go  より移植)
func SaveDeadStockListInTx(tx *sqlx.Tx, records []model.DeadStockRecord) error {
	const q = `
        INSERT INTO dead_stock_list 
        (product_code, yj_code, package_form, jan_pack_inner_qty, yj_unit_name, 
        stock_quantity_jan, expiry_date, lot_number, created_at)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
		ON CONFLICT(product_code, expiry_date, lot_number) DO UPDATE SET
		stock_quantity_jan = excluded.stock_quantity_jan,
		yj_code = excluded.yj_code,
		package_form = excluded.package_form,
		jan_pack_inner_qty = excluded.jan_pack_inner_qty,
		yj_unit_name = excluded.yj_unit_name,
		created_at = excluded.created_at`

	stmt, err := tx.Prepare(q)
	if err != nil {
		return fmt.Errorf("failed to prepare statement for dead_stock_list: %w", err)
	}
	defer stmt.Close()

	createdAt := time.Now().Format("2006-01-02 15:04:05")

	for _, rec := range records {
		_, err := stmt.Exec(
			rec.ProductCode, rec.YjCode, rec.PackageForm, rec.JanPackInnerQty, rec.YjUnitName,
			rec.StockQuantityJan, rec.ExpiryDate, rec.LotNumber, createdAt,
		)
		if err != nil {
			return fmt.Errorf("failed to insert/replace dead_stock_list for product %s: %w", rec.ProductCode, err)
		}
	}
	return nil
}


----- C:\Users\wasab\OneDrive\デスクトップ\TKR\database\guided_inventory.go -----
// C:\Users\wasab\OneDrive\デスクトップ\TKR\database\guided_inventory.go
package database

import (
	"database/sql"
	"fmt"
	"strconv"
	"tkr/mappers"
	"tkr/model"
	"tkr/units"

	"github.com/jmoiron/sqlx"
)

func DeleteTransactionsByFlagAndDateAndCodes(tx *sqlx.Tx, flag int, date string, productCodes []string) error {
	if len(productCodes) == 0 {
		return nil
	}

	query, args, err := sqlx.In(`DELETE FROM transaction_records WHERE flag = ?
AND transaction_date = ? AND jan_code IN (?)`, flag, date, productCodes)
	if err != nil {
		return fmt.Errorf("failed to create IN query for deleting transactions: %w", err)
	}
	query = tx.Rebind(query)

	_, err = tx.Exec(query, args...)
	if err != nil {
		return fmt.Errorf("failed to delete transactions by flag, date, and codes: %w", err)
	}
	return nil
}

func SaveGuidedInventoryData(tx *sqlx.Tx, date string, yjCode string, allPackagings []*model.ProductMaster, inventoryData map[string]float64, deadstockData []model.DeadStockRecord) error {

	var allProductCodes []string
	mastersMap := make(map[string]*model.ProductMaster)
	for _, pkg := range allPackagings {
		allProductCodes = append(allProductCodes, pkg.ProductCode)
		mastersMap[pkg.ProductCode] = pkg
	}

	if len(allProductCodes) > 0 {
		if err := DeleteTransactionsByFlagAndDateAndCodes(tx, 0, date, allProductCodes); err != nil {
			return fmt.Errorf("failed to delete old inventory records for the same day: %w", err)
		}
	}

	var lastSeq int
	var dateYYMMDD string
	if len(date) >= 8 {
		dateYYMMDD = date[2:8]
	} else if len(date) == 6 {
		dateYYMMDD = date
	} else {
		return fmt.Errorf("invalid date format for receipt number: %s", date)
	}

	prefix := "AJ" + dateYYMMDD

	q := `SELECT receipt_number FROM transaction_records 
		  WHERE receipt_number LIKE ?
ORDER BY receipt_number DESC LIMIT 1`
	var lastReceiptNumber string
	err := tx.Get(&lastReceiptNumber, q, prefix+"%")

	if err != nil && err != sql.ErrNoRows {
		return fmt.Errorf("failed to get last receipt number sequence for prefix %s: %w", prefix, err)
	}

	lastSeq = 0
	if lastReceiptNumber != "" {
		if len(lastReceiptNumber) == 13 {
			seqStr := lastReceiptNumber[8:]
			lastSeq, _ = strconv.Atoi(seqStr)
		}
	}

	newSeq := lastSeq + 1

	packageStockTotalsYj := make(map[string]float64)

	for productCode, janQty := range inventoryData {
		master, ok := mastersMap[productCode]
		if !ok {
			continue
		}
		yjQty := janQty * master.JanPackInnerQty
		packageKey := fmt.Sprintf("%s|%s|%g|%s", master.YjCode, master.PackageForm, master.JanPackInnerQty, units.ResolveName(master.YjUnitName))
		packageStockTotalsYj[packageKey] += yjQty

	}

	for i, ds := range deadstockData {
		master, ok := mastersMap[ds.ProductCode]
		if !ok {
			continue
		}

		receiptNumber := fmt.Sprintf("%s%05d", prefix, newSeq+i)

		janQty := ds.StockQuantityJan
		yjQty := janQty * master.JanPackInnerQty

		tr := model.TransactionRecord{
			TransactionDate: date,
			Flag:            0,
			ReceiptNumber:   receiptNumber,
			LineNumber:      fmt.Sprintf("%d", i+1),
			JanCode:         master.ProductCode,
			YjCode:          master.YjCode,
			JanQuantity:     janQty,
			YjQuantity:      yjQty,

			ExpiryDate: ds.ExpiryDate,
			LotNumber:  ds.LotNumber,
		}

		tr.UnitPrice = master.NhiPrice
		tr.Subtotal = tr.YjQuantity * tr.UnitPrice

		mappers.MapMasterToTransaction(&tr, master)

		if err := InsertTransactionRecord(tx, tr); err != nil {
			return fmt.Errorf("failed to insert inventory record for %s: %w", ds.ProductCode, err)
		}
	}

	for key, totalYjQty := range packageStockTotalsYj {
		if err := UpsertPackageStockInTx(tx, key, yjCode, totalYjQty, date); err != nil {
			return fmt.Errorf("failed to upsert package_stock for key %s: %w", key, err)
		}
	}

	return nil
}


----- C:\Users\wasab\OneDrive\デスクトップ\TKR\database\jcshms_query.go -----
// C:\Users\wasab\OneDrive\デスクトップ\TKR\database\jcshms_query.go
package database

import (
	"database/sql"
	"fmt"
	"strings"

	"tkr/model"
)

// GetJcshmsInfoByJan は JAN コードをキーに jcshms と jancode テーブルを結合して検索します。
func GetJcshmsInfoByJan(dbtx DBTX, janCode string) (*model.JcshmsInfo, error) {
	var info model.JcshmsInfo
	query := `
		SELECT
			j.JC000, j.JC009, j.JC018, j.JC019, j.JC020, j.JC022, j.JC024, j.JC030, j.JC013, j.JC037, j.JC039,
			j.JC044, j.JC049, j.JC050, j.JC122, j.JC124,
			j.JC061, j.JC062, j.JC063, j.JC064, j.JC065, j.JC066,
			ja.JA006, ja.JA007, ja.JA008
		FROM jcshms AS j
		LEFT JOIN jancode AS ja ON j.JC000 = ja.JA001
		WHERE j.JC000 = ?`

	err := dbtx.Get(&info, query, janCode)

	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, fmt.Errorf("GetJcshmsInfoByJan failed for jan %s: %w", janCode, err)
	}

	return &info, nil
}

func GetJcshmsInfoByGs1Code(dbtx DBTX, gs1Code string) (*model.JcshmsInfo, error) {
	var info model.JcshmsInfo
	query := `
		SELECT
			j.JC000, j.JC009, j.JC018, j.JC019, j.JC020, j.JC022, j.JC024, j.JC030, j.JC013, j.JC037, j.JC039,
			j.JC044, j.JC049, j.JC050, j.JC122, j.JC124,
			j.JC061, j.JC062, j.JC063, j.JC064, j.JC065, j.JC066,
			ja.JA006, ja.JA007, ja.JA008
		FROM jcshms AS j
		LEFT JOIN jancode AS ja ON j.JC000 = ja.JA001
		WHERE j.JC122 = ?`

	err := dbtx.Get(&info, query, gs1Code)

	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, fmt.Errorf("GetJcshmsInfoByGs1Code failed for gs1_code %s: %w", gs1Code, err)
	}

	return &info, nil
}

func GetFilteredJcshmsInfo(dbtx DBTX, usageClass, kanaName, genericName, productName string, drugTypes []string) ([]*model.JcshmsInfo, error) {
	var jcshmsList []*model.JcshmsInfo
	query := `
        SELECT
            j.JC000, j.JC009, j.JC018, j.JC019, j.JC020, j.JC022, j.JC024, j.JC030, j.JC013, j.JC037, j.JC039,
            j.JC044, j.JC049, j.JC050, j.JC122, j.JC124,
            j.JC061, j.JC062, j.JC063, j.JC064, j.JC065, j.JC066,
            ja.JA006, ja.JA007, ja.JA008
        FROM jcshms AS j
		LEFT JOIN jancode AS ja ON j.JC000 = ja.JA001
		WHERE 1=1 `

	var args []interface{}

	if usageClass != "" && usageClass != "all" {
		query += " AND j.JC013 = ?"
		args = append(args, usageClass)
	}
	if kanaName != "" {
		query += " AND j.JC022 LIKE ?"
		args = append(args, kanaName+"%")
	}
	if genericName != "" {
		query += " AND j.JC024 LIKE ?"
		args = append(args, "%"+genericName+"%")
	}
	if productName != "" {
		query += " AND j.JC018 LIKE ?"
		args = append(args, "%"+productName+"%")
	}

	if len(drugTypes) > 0 {
		var drugConditions []string
		for _, dt := range drugTypes {
			switch dt {
			case "poison":
				drugConditions = append(drugConditions, "j.JC061 = 1")
			case "deleterious":
				drugConditions = append(drugConditions, "j.JC062 = 1")
			case "narcotic":
				drugConditions = append(drugConditions, "j.JC063 = 1")
			case "psycho1":
				drugConditions = append(drugConditions, "j.JC064 = 1")
			case "psycho2":
				drugConditions = append(drugConditions, "j.JC064 = 2")
			case "psycho3":
				drugConditions = append(drugConditions, "j.JC064 = 3")
			case "stimulant":
				drugConditions = append(drugConditions, "j.JC065 = 1")
			case "stimulant_raw":
				drugConditions = append(drugConditions, "j.JC066 = 1")
			}
		}
		if len(drugConditions) > 0 {
			query += " AND (" + strings.Join(drugConditions, " OR ") + ")"
		}
	}

	query += " ORDER BY j.JC022 LIMIT 500"

	err := dbtx.Select(&jcshmsList, query, args...)
	if err != nil {
		return nil, fmt.Errorf("failed to select filtered jcshms info: %w", err)
	}

	return jcshmsList, nil
}


----- C:\Users\wasab\OneDrive\デスクトップ\TKR\database\package_keys.go -----
// C:\Users\wasab\OneDrive\デスクトップ\TKR\database\package_keys.go
package database

import (
	"fmt"
	"tkr/model"
	"tkr/units"
)

// GeneratePackageKey はプロダクトマスタから一意のパッケージキーを生成します。
// システム全体でこの関数を使用することで、キーの生成ルールを統一します。
func GeneratePackageKey(m *model.ProductMaster) string {
	// YjCode | PackageForm | JanPackInnerQty | YjUnitName(Resolved)
	return fmt.Sprintf("%s|%s|%g|%s",
		m.YjCode,
		m.PackageForm,
		m.JanPackInnerQty,
		units.ResolveName(m.YjUnitName),
	)
}


----- C:\Users\wasab\OneDrive\デスクトップ\TKR\database\package_stock.go -----
// C:\Users\wasab\OneDrive\デスクトップ\TKR\database\package_stock.go
package database

import (
	"fmt"
	"strconv"
	"strings"
	"tkr/model"

	"github.com/jmoiron/sqlx"
)

func UpsertPackageStockInTx(tx *sqlx.Tx, packageKey string, yjCode string, quantityYj float64, inventoryDate string) error {
	const q = `
		INSERT INTO package_stock (package_key, yj_code, stock_quantity_yj, last_inventory_date)
		VALUES (?, ?, ?, ?)
		ON CONFLICT(package_key) DO UPDATE SET
			stock_quantity_yj = excluded.stock_quantity_yj,
			last_inventory_date = excluded.last_inventory_date,
			yj_code = excluded.yj_code
	`
	_, err := tx.Exec(q, packageKey, yjCode, quantityYj, inventoryDate)
	if err != nil {
		return fmt.Errorf("failed to upsert package_stock for key %s: %w", packageKey, err)
	}
	return nil
}

// GetPackageStockByYjCode は単一のYJコードで検索します（既存互換用）
func GetPackageStockByYjCode(dbtx DBTX, yjCode string) (map[string]model.PackageStock, error) {
	var stocks []model.PackageStock
	const q = `
		SELECT package_key, yj_code, stock_quantity_yj, last_inventory_date
		FROM package_stock
		WHERE yj_code = ?`
	err := dbtx.Select(&stocks, q, yjCode)
	if err != nil {
		return nil, fmt.Errorf("failed to get package_stock by yj_code %s: %w", yjCode, err)
	}

	stockMap := make(map[string]model.PackageStock)
	for _, s := range stocks {
		stockMap[s.PackageKey] = s
	}
	return stockMap, nil
}

// ▼▼▼【追加】複数のPackageKeyで一括取得する関数 ▼▼▼
func GetPackageStocksByKeys(dbtx DBTX, keys []string) (map[string]model.PackageStock, error) {
	stockMap := make(map[string]model.PackageStock)
	if len(keys) == 0 {
		return stockMap, nil
	}

	// sqlx.In を使用して IN 句を構築
	query, args, err := sqlx.In(`
		SELECT package_key, yj_code, stock_quantity_yj, last_inventory_date
		FROM package_stock
		WHERE package_key IN (?)`, keys)
	if err != nil {
		return nil, fmt.Errorf("failed to construct IN query for package_stock keys: %w", err)
	}

	if rebinder, ok := dbtx.(interface{ Rebind(string) string }); ok {
		query = rebinder.Rebind(query)
	}

	var stocks []model.PackageStock
	err = dbtx.Select(&stocks, query, args...)
	if err != nil {
		return nil, fmt.Errorf("failed to get package_stocks by keys: %w", err)
	}

	for _, s := range stocks {
		stockMap[s.PackageKey] = s
	}
	return stockMap, nil
}

// ▲▲▲【追加ここまで】▲▲▲

type ParsedPackageKey struct {
	YjCode          string
	PackageForm     string
	JanPackInnerQty float64
	YjUnitName      string
}

func ParsePackageKey(key string) (*ParsedPackageKey, error) {
	parts := strings.Split(key, "|")
	if len(parts) != 4 {
		return nil, fmt.Errorf("invalid package key format: %s", key)
	}

	innerQty, err := strconv.ParseFloat(parts[2], 64)
	if err != nil {
		return nil, fmt.Errorf("invalid JanPackInnerQty in package key (%s): %w", parts[2], err)
	}

	return &ParsedPackageKey{
		YjCode:          parts[0],
		PackageForm:     parts[1],
		JanPackInnerQty: innerQty,
		YjUnitName:      parts[3],
	}, nil
}


----- C:\Users\wasab\OneDrive\デスクトップ\TKR\database\precomp.go -----
// C:\Users\wasab\OneDrive\デスクトップ\TKR\database\precomp.go
package database

import (
	"database/sql"
	"fmt"
	"strings"
	"time"
	"tkr/mappers" // TKRのmappersを参照
	"tkr/model"   // TKRのmodelを参照

	"github.com/jmoiron/sqlx"
)

// PrecompRecordInput はフロントエンドから受け取る予製レコードの構造体です。
// (WASABI: db/precomp.go  より)
type PrecompRecordInput struct {
	ProductCode string  `json:"productCode"`
	JanQuantity float64 `json:"janQuantity"`
}

// PrecompRecordView は予製データを画面に表示するための構造体です。
// (WASABI: db/precomp.go  より)
type PrecompRecordView struct {
	model.TransactionRecord
	FormattedPackageSpec string `json:"formattedPackageSpec"`
	JanUnitName          string `json:"janUnitName"`
}

/**
 * @brief 特定の患者の予製レコードをデータベースと安全に同期します。
 * (WASABI: db/precomp.go  より)
 */
func UpsertPreCompoundingRecordsInTx(tx DBTX, patientNumber string, records []PrecompRecordInput) error {
	if len(records) == 0 {
		// レコードが0件の場合、該当患者の予製をすべて削除
		if _, err := tx.Exec("DELETE FROM precomp_records WHERE client_code = ?", patientNumber); err != nil {
			return fmt.Errorf("failed to delete all precomp records for patient %s: %w", patientNumber, err)
		}
		return nil
	}

	// 1. ペイロードに含まれない製品コードをDBから削除
	productCodesInPayload := make([]interface{}, len(records)+1)
	placeholders := make([]string, len(records))
	productCodesInPayload[0] = patientNumber
	for i, rec := range records {
		placeholders[i] = "?"
		productCodesInPayload[i+1] = rec.ProductCode
	}

	deleteQuery := fmt.Sprintf("DELETE FROM precomp_records WHERE client_code = ? AND jan_code NOT IN (%s)", strings.Join(placeholders, ","))
	if _, err := tx.Exec(deleteQuery, productCodesInPayload...); err != nil {
		return fmt.Errorf("failed to delete removed precomp records for patient %s: %w", patientNumber, err)
	}

	// 2. 必要なマスター情報を取得
	var productCodes []string
	for _, rec := range records {
		productCodes = append(productCodes, rec.ProductCode)
	}
	mastersMap, err := GetProductMastersByCodesMap(tx, productCodes)
	if err != nil {
		return fmt.Errorf("failed to get product masters for precomp: %w", err)
	}

	// 3. レコードを挿入または更新 (UPSERT)
	const q = `INSERT INTO precomp_records (
		transaction_date, client_code, receipt_number, line_number, jan_code, yj_code, product_name, kana_name,
		usage_classification, package_form, package_spec, maker_name, jan_pack_inner_qty, jan_quantity,
		jan_pack_unit_qty, jan_unit_name, jan_unit_code, yj_quantity, yj_pack_unit_qty, yj_unit_name,
		purchase_price, supplier_wholesale, created_at, status
	) VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
	ON CONFLICT(client_code, jan_code) DO UPDATE SET
		jan_quantity = excluded.jan_quantity,
		yj_quantity = excluded.yj_quantity,
		created_at = excluded.created_at,
		status = excluded.status`

	stmt, err := tx.Prepare(q)
	if err != nil {
		return fmt.Errorf("failed to prepare precomp upsert statement: %w", err)
	}
	defer stmt.Close()

	now := time.Now()
	dateStr := now.Format("20060102")
	receiptNumber := fmt.Sprintf("PRECOMP-%s", patientNumber)

	for i, rec := range records {
		master, ok := mastersMap[rec.ProductCode]
		if !ok {
			continue // マスターがないものは無視
		}

		tr := model.TransactionRecord{
			TransactionDate: dateStr,
			ClientCode:      patientNumber,
			ReceiptNumber:   receiptNumber,
			LineNumber:      fmt.Sprintf("%d", i+1),
			JanCode:         rec.ProductCode,
			JanQuantity:     rec.JanQuantity,
		}
		if master.JanPackInnerQty > 0 {
			tr.YjQuantity = rec.JanQuantity * master.JanPackInnerQty
		}

		mappers.MapMasterToTransaction(&tr, master) // TKRのマッパーを使用

		_, err := stmt.Exec(
			tr.TransactionDate, tr.ClientCode, tr.ReceiptNumber, tr.LineNumber, tr.JanCode, tr.YjCode, tr.ProductName, tr.KanaName,
			tr.UsageClassification, tr.PackageForm, tr.PackageSpec, tr.MakerName, tr.JanPackInnerQty, tr.JanQuantity,
			tr.JanPackUnitQty, tr.JanUnitName, tr.JanUnitCode, tr.YjQuantity, tr.YjPackUnitQty, tr.YjUnitName,
			tr.PurchasePrice, tr.SupplierWholesale, now.Format("2006-01-02 15:04:05"), "active",
		)
		if err != nil {
			return fmt.Errorf("failed to upsert precomp record for product %s: %w", rec.ProductCode, err)
		}
	}

	return nil
}

/**
 * @brief 特定の患者の予製レコードをリストで取得します。
 * (WASABI: db/precomp.go  より)
 */
func GetPreCompoundingRecordsByPatient(conn DBTX, patientNumber string) ([]model.TransactionRecord, error) {
	// TKRの TransactionColumns  と同じ38列をSELECT
	const q = `SELECT
		id, transaction_date, client_code, receipt_number, line_number, 5 AS flag,
		jan_code, yj_code, product_name, kana_name, usage_classification, package_form, package_spec, maker_name,
		0.0 AS dat_quantity, jan_pack_inner_qty, jan_quantity, jan_pack_unit_qty, jan_unit_name, jan_unit_code,
		yj_quantity, yj_pack_unit_qty, yj_unit_name, 0.0 AS unit_price, purchase_price, supplier_wholesale,
		0.0 AS subtotal, 0.0 AS tax_amount, 0.0 AS tax_rate, '' AS expiry_date, '' AS lot_number, 
		0 AS flag_poison, 0 AS flag_deleterious, 0 AS flag_narcotic, 0 AS flag_psychotropic, 0 AS flag_stimulant, 
		0 AS flag_stimulant_raw, '' AS process_flag_ma
		FROM precomp_records WHERE client_code = ?
		ORDER BY id`

	rows, err := conn.Query(q, patientNumber)
	if err != nil {
		return nil, fmt.Errorf("failed to query precomp records for patient %s: %w", patientNumber, err)
	}
	defer rows.Close()

	var records []model.TransactionRecord
	for rows.Next() {
		r, err := ScanTransactionRecord(rows) // TKRのScanTransactionRecordを使用
		if err != nil {
			return nil, fmt.Errorf("failed to scan precomp record: %w", err)
		}
		records = append(records, *r)
	}
	return records, nil
}

/**
 * @brief 特定の患者の予製レコードをすべて削除します。
 * (WASABI: db/precomp.go  より)
 */
func DeletePreCompoundingRecordsByPatient(conn DBTX, patientNumber string) error {
	const q = `DELETE FROM precomp_records WHERE client_code = ?`
	if _, err := conn.Exec(q, patientNumber); err != nil {
		return fmt.Errorf("failed to delete precomp records for patient %s: %w", patientNumber, err)
	}
	return nil
}

/**
 * @brief 全製品の有効な予製引当数量の合計をマップで返します。
 * (WASABI: db/precomp.go  より)
 */
func GetPreCompoundingTotals(conn DBTX) (map[string]float64, error) {
	const q = `SELECT jan_code, SUM(yj_quantity) FROM precomp_records WHERE status = 'active' GROUP BY jan_code`
	rows, err := conn.Query(q)
	if err != nil {
		return nil, fmt.Errorf("failed to query precomp totals: %w", err)
	}
	defer rows.Close()

	totals := make(map[string]float64)
	for rows.Next() {
		var productCode string
		var totalQuantity float64
		if err := rows.Scan(&productCode, &totalQuantity); err != nil {
			return nil, fmt.Errorf("failed to scan precomp total: %w", err)
		}
		totals[productCode] = totalQuantity
	}
	return totals, nil
}

/**
 * @brief 複数の製品コードに紐づく有効な予製レコードを全て取得します。
 * (WASABI: db/precomp.go  より)
 */
func GetPreCompoundingDetailsByProductCodes(conn DBTX, productCodes []string) ([]model.TransactionRecord, error) {
	if len(productCodes) == 0 {
		return []model.TransactionRecord{}, nil
	}

	query, args, err := sqlx.In(`
		SELECT
			p.id, p.transaction_date, p.client_code, p.receipt_number, p.line_number, 5 AS flag,
			p.jan_code, p.yj_code, p.product_name, p.kana_name, p.usage_classification, p.package_form, p.package_spec, p.maker_name,
			0.0 AS dat_quantity, p.jan_pack_inner_qty, p.jan_quantity, p.jan_pack_unit_qty, p.jan_unit_name, p.jan_unit_code,
			p.yj_quantity, p.yj_pack_unit_qty, p.yj_unit_name, 0.0 AS unit_price, p.purchase_price, p.supplier_wholesale,
			0.0 AS subtotal, 0.0 AS tax_amount, 0.0 AS tax_rate, '' AS expiry_date, '' AS lot_number,
			0 AS flag_poison, 0 AS flag_deleterious, 0 AS flag_narcotic, 0 AS flag_psychotropic, 0 AS flag_stimulant, 
			0 AS flag_stimulant_raw, '' AS process_flag_ma
		FROM precomp_records AS p
		WHERE p.jan_code IN (?)
		ORDER BY p.created_at, p.client_code`, productCodes)

	if err != nil {
		return nil, fmt.Errorf("failed to create IN query for precomp details: %w", err)
	}

	query = conn.Rebind(query)
	rows, err := conn.Query(query, args...)
	if err != nil {
		return nil, fmt.Errorf("failed to query precomp details by product codes: %w", err)
	}
	defer rows.Close()

	var records []model.TransactionRecord
	for rows.Next() {
		r, err := ScanTransactionRecord(rows) // TKRのScanTransactionRecordを使用
		if err != nil {
			return nil, fmt.Errorf("failed to scan precomp detail record: %w", err)
		}
		records = append(records, *r)
	}
	return records, nil
}

/**
 * @brief 全患者の有効な予製レコードを全て取得します。
 * (WASABI: db/precomp.go  より)
 */
func GetAllPreCompoundingRecords(conn DBTX) ([]model.TransactionRecord, error) {
	const q = `SELECT
		id, transaction_date, client_code, receipt_number, line_number, 5 AS flag,
		jan_code, yj_code, product_name, kana_name, usage_classification, package_form, package_spec, maker_name,
		0.0 AS dat_quantity, jan_pack_inner_qty, jan_quantity, jan_pack_unit_qty, jan_unit_name, jan_unit_code,
		yj_quantity, yj_pack_unit_qty, yj_unit_name, 0.0 AS unit_price, purchase_price, supplier_wholesale,
		0.0 AS subtotal, 0.0 AS tax_amount, 0.0 AS tax_rate, '' AS expiry_date, '' AS lot_number, 
		0 AS flag_poison, 0 AS flag_deleterious, 0 AS flag_narcotic, 0 AS flag_psychotropic, 0 AS flag_stimulant, 
		0 AS flag_stimulant_raw, '' AS process_flag_ma
		FROM precomp_records 
		ORDER BY client_code, id`

	rows, err := conn.Query(q)
	if err != nil {
		return nil, fmt.Errorf("failed to query all precomp records: %w", err)
	}
	defer rows.Close()

	var records []model.TransactionRecord
	for rows.Next() {
		r, err := ScanTransactionRecord(rows) // TKRのScanTransactionRecordを使用
		if err != nil {
			return nil, fmt.Errorf("failed to scan precomp record: %w", err)
		}
		records = append(records, *r)
	}
	return records, nil
}

/**
 * @brief 指定された患者の予製レコードを中断状態（inactive）にします。
 * (WASABI: db/precomp.go  より)
 */
func SuspendPreCompoundingRecordsByPatient(tx DBTX, patientNumber string) error {
	const q = `UPDATE precomp_records SET status = 'inactive' WHERE client_code = ?`
	if _, err := tx.Exec(q, patientNumber); err != nil {
		return fmt.Errorf("failed to suspend precomp records for patient %s: %w", patientNumber, err)
	}
	return nil
}

/**
 * @brief 指定された患者の予製レコードを再開状態（active）にします。
 * (WASABI: db/precomp.go  より)
 */
func ResumePreCompoundingRecordsByPatient(tx DBTX, patientNumber string) error {
	const q = `UPDATE precomp_records SET status = 'active' WHERE client_code = ?`
	if _, err := tx.Exec(q, patientNumber); err != nil {
		return fmt.Errorf("failed to resume precomp records for patient %s: %w", patientNumber, err)
	}
	return nil
}

/**
 * @brief 指定された患者の現在の予製ステータスを取得します。
 * (WASABI: db/precomp.go  より)
 */
func GetPreCompoundingStatusByPatient(conn DBTX, patientNumber string) (string, error) {
	var status string
	const q = `SELECT status FROM precomp_records WHERE client_code = ? LIMIT 1`
	err := conn.QueryRow(q, patientNumber).Scan(&status)
	if err != nil {
		if err == sql.ErrNoRows {
			return "none", nil // レコードが存在しない
		}
		return "", fmt.Errorf("failed to get precomp status for patient %s: %w", patientNumber, err)
	}
	return status, nil
}


----- C:\Users\wasab\OneDrive\デスクトップ\TKR\database\pricing_queries.go -----
package database

import (
	"fmt"
	"tkr/model"

	"github.com/jmoiron/sqlx"
)

// UpsertProductQuotesInTx は複数の見積データをトランザクション内でUPSERTします。
func UpsertProductQuotesInTx(tx *sqlx.Tx, quotes []model.ProductQuote) error {
	const q = `
		INSERT INTO product_quotes (
			product_code, wholesaler_code, quote_price, quote_date
		) VALUES (
			:product_code, :wholesaler_code, :quote_price, :quote_date
		)
		ON CONFLICT(product_code, wholesaler_code) DO UPDATE SET
			quote_price = excluded.quote_price,
			quote_date = excluded.quote_date
	`
	// NamedExecでスライスをバルクインサート
	_, err := tx.NamedExec(q, quotes)
	if err != nil {
		return fmt.Errorf("failed to bulk upsert product quotes: %w", err)
	}
	return nil
}

// GetAllProductQuotes は全ての見積データを取得し、[product_code][wholesaler_code] -> price のマップを返します。
func GetAllProductQuotes(dbtx DBTX) (map[string]map[string]float64, error) {
	var quotes []model.ProductQuote
	const q = `SELECT product_code, wholesaler_code, quote_price FROM product_quotes`

	err := dbtx.Select(&quotes, q)
	if err != nil {
		return nil, fmt.Errorf("failed to get all product quotes: %w", err)
	}

	resultMap := make(map[string]map[string]float64)
	for _, q := range quotes {
		if _, ok := resultMap[q.ProductCode]; !ok {
			resultMap[q.ProductCode] = make(map[string]float64)
		}
		resultMap[q.ProductCode][q.WholesalerCode] = q.QuotePrice
	}
	return resultMap, nil
}


----- C:\Users\wasab\OneDrive\デスクトップ\TKR\database\product_master_query.go -----
// C:\Users\wasab\OneDrive\デスクトップ\TKR\database\product_master_query.go
package database

import (
	"database/sql"
	"fmt"
	"strings"
	"tkr/barcode"
	"tkr/model"
	"tkr/units"

	"github.com/jmoiron/sqlx"
)

type DBTX interface {
	Get(dest interface{}, query string, args ...interface{}) error
	Select(dest interface{}, query string, args ...interface{}) error
	NamedExec(query string, arg interface{}) (sql.Result, error)
	Query(query string, args ...interface{}) (*sql.Rows, error)
	QueryRow(query string, args ...interface{}) *sql.Row
	Rebind(query string) string
	Exec(query string, args ...interface{}) (sql.Result, error)
	Prepare(query string) (*sql.Stmt, error)
}

const SelectColumns = `
	product_code, yj_code, gs1_code, product_name, kana_name, kana_name_short, 
	generic_name, maker_name,
	specification, usage_classification, package_form, yj_unit_name, yj_pack_unit_qty,
	jan_pack_inner_qty, jan_unit_code, jan_pack_unit_qty, origin,
	nhi_price, purchase_price,
	flag_poison, flag_deleterious, flag_narcotic, flag_psychotropic, flag_stimulant, flag_stimulant_raw,
	is_order_stopped, supplier_wholesale,
	group_code, shelf_number, category, user_notes
`

func ScanProductMaster(row interface{ Scan(...interface{}) error }) (*model.ProductMaster, error) {
	var m model.ProductMaster
	err := row.Scan(
		// 基本情報
		&m.ProductCode, &m.YjCode, &m.Gs1Code, &m.ProductName, &m.KanaName, &m.KanaNameShort,
		&m.GenericName, &m.MakerName,
		// 製品仕様情報
		&m.Specification, &m.UsageClassification, &m.PackageForm, &m.YjUnitName, &m.YjPackUnitQty,
		&m.JanPackInnerQty, &m.JanUnitCode, &m.JanPackUnitQty, &m.Origin,
		// 価格情報
		&m.NhiPrice, &m.PurchasePrice,
		// 管理フラグ・情報
		&m.FlagPoison, &m.FlagDeleterious, &m.FlagNarcotic, &m.FlagPsychotropic, &m.FlagStimulant, &m.FlagStimulantRaw,
		&m.IsOrderStopped, &m.SupplierWholesale,
		// ユーザー定義項目
		&m.GroupCode, &m.ShelfNumber, &m.Category, &m.UserNotes,
	)
	if err != nil {
		return nil, err
	}
	return &m, nil
}

func GetProductMastersByCodesMap(dbtx DBTX, codes []string) (map[string]*model.ProductMaster, error) {
	if len(codes) == 0 {
		return make(map[string]*model.ProductMaster), nil
	}
	q := `SELECT ` + SelectColumns + ` FROM product_master WHERE product_code IN (?` + strings.Repeat(",?", len(codes)-1) + `)`

	args := make([]interface{}, len(codes))
	for i, code := range codes {
		args[i] = code
	}

	rows, err := dbtx.Query(q, args...)
	if err != nil {
		return nil, fmt.Errorf("query for masters by codes failed: %w", err)
	}
	defer rows.Close()

	mastersMap := make(map[string]*model.ProductMaster)
	for rows.Next() {
		m, err := ScanProductMaster(rows)
		if err != nil {
			return nil, err
		}
		mastersMap[m.ProductCode] = m
	}
	return mastersMap, nil
}

func GetAllProductMasters(dbtx DBTX) ([]*model.ProductMaster, error) {
	var masters []*model.ProductMaster
	query := `SELECT * FROM product_master`
	err := dbtx.Select(&masters, query)
	if err != nil {
		if err == sql.ErrNoRows {
			return []*model.ProductMaster{}, nil
		}
		return nil, fmt.Errorf("failed to select all product masters: %w", err)
	}
	if masters == nil {
		masters = []*model.ProductMaster{}
	}
	return masters, nil
}

func GetAllAdoptedProductCodesMap(dbtx DBTX) (map[string]bool, error) {
	rows, err := dbtx.Query(`SELECT product_code FROM product_master`)
	if err != nil {
		if err == sql.ErrNoRows {
			return make(map[string]bool), nil
		}
		return nil, fmt.Errorf("failed to query all product codes: %w", err)
	}
	defer rows.Close()

	codeMap := make(map[string]bool)
	for rows.Next() {
		var code string
		if err := rows.Scan(&code); err != nil {
			return nil, fmt.Errorf("failed to scan product code: %w", err)
		}
		if code != "" {
			codeMap[code] = true
		}
	}
	return codeMap, nil
}

// GetFilteredProductMasters は条件に基づいて製品マスタを検索します。
func GetFilteredProductMasters(dbtx DBTX, usageClass, kanaName, genericName, shelfNumber, productName string, drugTypes []string) ([]model.ProductMaster, error) {
	var masters []model.ProductMaster

	query := `SELECT * FROM product_master WHERE 1=1`
	var args []interface{}

	if usageClass != "" && usageClass != "all" {
		query += " AND usage_classification = ?"
		args = append(args, usageClass)
	}

	if kanaName != "" {
		query += " AND kana_name LIKE ?"
		args = append(args, kanaName+"%")
	}
	if genericName != "" {
		query += " AND generic_name LIKE ?"
		args = append(args, "%"+genericName+"%")
	}
	if productName != "" {
		query += " AND product_name LIKE ?"
		args = append(args, "%"+productName+"%")
	}

	if shelfNumber != "" {
		query += " AND shelf_number LIKE ?"
		args = append(args, "%"+shelfNumber+"%")
	}

	if len(drugTypes) > 0 {
		var drugConditions []string
		for _, dt := range drugTypes {
			switch dt {
			case "poison":
				drugConditions = append(drugConditions, "flag_poison = 1")
			case "deleterious":
				drugConditions = append(drugConditions, "flag_deleterious = 1")
			case "narcotic":
				drugConditions = append(drugConditions, "flag_narcotic = 1")
			case "psycho1":
				drugConditions = append(drugConditions, "flag_psychotropic = 1")
			case "psycho2":
				drugConditions = append(drugConditions, "flag_psychotropic = 2")
			case "psycho3":
				drugConditions = append(drugConditions, "flag_psychotropic = 3")
			case "stimulant":
				drugConditions = append(drugConditions, "flag_stimulant = 1")
			case "stimulant_raw":
				drugConditions = append(drugConditions, "flag_stimulant_raw = 1")
			}
		}
		if len(drugConditions) > 0 {
			query += " AND (" + strings.Join(drugConditions, " OR ") + ")"
		}
	}

	query += " ORDER BY kana_name LIMIT 500"

	err := dbtx.Select(&masters, query, args...)
	if err != nil {
		if err == sql.ErrNoRows {
			return []model.ProductMaster{}, nil
		}
		return nil, fmt.Errorf("failed to select filtered product masters: %w", err)
	}

	if masters == nil {
		masters = []model.ProductMaster{}
	}

	return masters, nil
}

func GetProductMasterByCode(dbtx DBTX, code string) (*model.ProductMaster, error) {
	var master model.ProductMaster
	query := `SELECT * FROM product_master WHERE product_code = ?`
	err := dbtx.Get(&master, query, code)
	if err != nil {
		return nil, fmt.Errorf("failed to get product master by code %s: %w", code, err)
	}
	return &master, nil
}

func GetProductMasterByGs1Code(dbtx DBTX, gs1Code string) (*model.ProductMaster, error) {
	var master model.ProductMaster
	query := `SELECT * FROM product_master WHERE gs1_code = ?`
	err := dbtx.Get(&master, query, gs1Code)
	if err != nil {
		return nil, fmt.Errorf("failed to get product master by gs1_code %s: %w", gs1Code, err)
	}
	return &master, nil
}

func GetProductMasterByBarcode(dbtx DBTX, barcodeStr string) (*model.ProductMaster, error) {
	if barcodeStr == "" {
		return nil, fmt.Errorf("バーコードが空です")
	}

	if len(barcodeStr) <= 13 {
		return GetProductMasterByCode(dbtx, barcodeStr)
	}

	gs1Result, parseErr := barcode.Parse(barcodeStr)
	if parseErr != nil {
		return nil, fmt.Errorf("バーコード解析エラー: %w", parseErr)
	}

	gtin14 := gs1Result.Gtin14
	if gtin14 == "" {
		return nil, fmt.Errorf("バーコードからGTIN(14桁)が抽出できませんでした")
	}

	return GetProductMasterByGs1Code(dbtx, gtin14)
}

func GetProductMastersByYjCode(dbtx DBTX, yjCode string) ([]*model.ProductMaster, error) {
	var masters []*model.ProductMaster
	query := `SELECT * FROM product_master WHERE yj_code = ? ORDER BY product_code`
	err := dbtx.Select(&masters, query, yjCode)
	if err != nil {
		if err == sql.ErrNoRows {
			return []*model.ProductMaster{}, nil
		}
		return nil, fmt.Errorf("failed to select product masters by yj_code %s: %w", yjCode, err)
	}
	if masters == nil {
		masters = []*model.ProductMaster{}
	}
	return masters, nil
}

func GetProductCodesByYjCodes(dbtx DBTX, yjCodes []string) ([]string, error) {
	if len(yjCodes) == 0 {
		return []string{}, nil
	}
	query, args, err := sqlx.In(`SELECT DISTINCT product_code FROM product_master WHERE yj_code IN (?)`, yjCodes)
	if err != nil {
		return nil, fmt.Errorf("failed to create IN query for GetProductCodesByYjCodes: %w", err)
	}
	query = dbtx.Rebind(query)
	var codes []string
	if err := dbtx.Select(&codes, query, args...); err != nil {
		return nil, err
	}
	return codes, nil
}

func GetProductMasterByKanaNameShort(dbtx DBTX, kanaNameShort string) (*model.ProductMaster, error) {
	var master model.ProductMaster
	query := `SELECT * FROM product_master WHERE kana_name_short = ?`
	err := dbtx.Get(&master, query, kanaNameShort)
	if err != nil {
		return nil, fmt.Errorf("failed to get product master by kana_name_short %s: %w", kanaNameShort, err)
	}
	return &master, nil
}

const insertProductMasterQuery = `
INSERT INTO product_master (
    product_code, yj_code, gs1_code, product_name, kana_name, kana_name_short, 
    generic_name, maker_name, specification, usage_classification, package_form, 
    yj_unit_name, yj_pack_unit_qty, jan_pack_inner_qty, jan_unit_code, jan_pack_unit_qty, 
    origin, nhi_price, purchase_price, flag_poison, flag_deleterious, flag_narcotic, 
    flag_psychotropic, flag_stimulant, flag_stimulant_raw, is_order_stopped, 
    supplier_wholesale, group_code, shelf_number, category, user_notes
) VALUES (
    :product_code, :yj_code, :gs1_code, :product_name, :kana_name, :kana_name_short, 
    :generic_name, :maker_name, :specification, :usage_classification, :package_form, 
    :yj_unit_name, :yj_pack_unit_qty, :jan_pack_inner_qty, :jan_unit_code, :jan_pack_unit_qty, 
    :origin, :nhi_price, :purchase_price, :flag_poison, :flag_deleterious, :flag_narcotic, 
    :flag_psychotropic, :flag_stimulant, :flag_stimulant_raw, :is_order_stopped, 
    :supplier_wholesale, :group_code, :shelf_number, :category, :user_notes
)`

func InsertProductMaster(dbtx DBTX, master *model.ProductMaster) error {
	_, err := dbtx.NamedExec(insertProductMasterQuery, master)
	if err != nil {
		return fmt.Errorf("failed to insert product master: %w", err)
	}
	return nil
}

type MasterPackageKeyInfo struct {
	PackageKey     string
	YjCode         string
	Representative *model.ProductMaster
}

func GetAllPackageKeysFromMasters(dbtx DBTX) (map[string]MasterPackageKeyInfo, error) {
	var allMasters []*model.ProductMaster
	query := `SELECT * FROM product_master WHERE yj_code != ''`
	err := dbtx.Select(&allMasters, query)
	if err != nil {
		return nil, fmt.Errorf("failed to select all product masters for package key generation: %w", err)
	}

	mastersByPackageKey := make(map[string][]*model.ProductMaster)
	keyInfoMap := make(map[string]MasterPackageKeyInfo)

	for _, m := range allMasters {
		key := fmt.Sprintf("%s|%s|%g|%s", m.YjCode, m.PackageForm, m.JanPackInnerQty, units.ResolveName(m.YjUnitName))
		mastersByPackageKey[key] = append(mastersByPackageKey[key], m)

		if info, ok := keyInfoMap[key]; !ok {
			keyInfoMap[key] = MasterPackageKeyInfo{
				PackageKey:     key,
				YjCode:         m.YjCode,
				Representative: m,
			}
		} else {
			if info.Representative.Origin != "JCSHMS" && m.Origin == "JCSHMS" {
				info.Representative = m
				keyInfoMap[key] = info
			}
		}
	}

	return keyInfoMap, nil
}

func UpdatePricesAndSuppliersInTx(tx *sqlx.Tx, updates []model.PriceUpdate) error {
	const q = `UPDATE product_master SET purchase_price = :newPrice, supplier_wholesale = :newWholesaler
WHERE product_code = :productCode`

	_, err := tx.NamedExec(q, updates)
	if err != nil {
		return fmt.Errorf("UpdatePricesAndSuppliersInTx failed (NamedExec): %w", err)
	}
	return nil
}


----- C:\Users\wasab\OneDrive\デスクトップ\TKR\database\sequence.go -----
// C:\Users\wasab\OneDrive\デスクトップ\TKR\database\sequence.go
package database

import (
	"database/sql"
	"fmt"
	"log"
	"strconv"
	"strings"

	"github.com/jmoiron/sqlx"
)

func NextSequenceInTx(tx *sqlx.Tx, name, prefix string, padding int) (string, error) {
	var lastNo int
	err := tx.Get(&lastNo, "SELECT last_no FROM code_sequences WHERE name = ?", name)
	if err != nil {
		if err == sql.ErrNoRows {
			return "", fmt.Errorf("sequence '%s' not found", name)
		}
		return "", fmt.Errorf("failed to get sequence '%s': %w", name, err)
	}

	newNo := lastNo + 1
	_, err = tx.Exec(`UPDATE code_sequences SET last_no = ? WHERE name = ?`, newNo, name)
	if err != nil {
		return "", fmt.Errorf("failed to update sequence '%s': %w", name, err)
	}

	format := fmt.Sprintf("%s%%0%dd", prefix, padding)
	newCode := fmt.Sprintf(format, newNo)

	if name == "MA2Y" || name == "MA2J" {
		log.Printf("INFO: [Sequence] Auto-incrementing '%s'. Fetched last_no: %d. Generated new code: %s", name, lastNo, newCode)
	}

	return newCode, nil
}

// ▼▼▼【ここから修正】ログ出力のロジックを 'CL' にも追加 ▼▼▼
func InitializeSequenceFromMaxClientCode(tx *sqlx.Tx) error {
	var maxCode sql.NullString
	err := tx.Get(&maxCode, "SELECT client_code FROM client_master ORDER BY client_code DESC LIMIT 1")

	maxNum := 0 // デフォルト (該当レコードなしの場合)
	if err != nil {
		if err == sql.ErrNoRows {
			// レコードなし (ErrNoRows自体はエラーではない)
		} else {
			return err // その他のDBエラー
		}
	}

	// レコードが見つかった場合
	if maxCode.Valid && strings.HasPrefix(maxCode.String, "CL") {
		numPart := strings.TrimPrefix(maxCode.String, "CL")
		maxNum, _ = strconv.Atoi(numPart) // maxNum に代入
	}

	// ログを出力
	log.Printf("INFO: [Sequence] Setting 'CL' last_no to %d", maxNum)

	// maxNum を使用
	_, err = tx.Exec(`UPDATE code_sequences SET last_no = ? WHERE name = 'CL'`, maxNum)
	return err
}

// ▲▲▲【修正ここまで】▲▲▲

func InitializeSequenceFromMaxYjCode(tx *sqlx.Tx) error {
	var maxYj sql.NullString
	err := tx.Get(&maxYj,
		"SELECT yj_code FROM product_master WHERE yj_code LIKE 'MA2Y%' ORDER BY yj_code DESC LIMIT 1")

	maxNum := 0 // デフォルト (該当レコードなしの場合)
	if err != nil {
		if err == sql.ErrNoRows {
			// レコードなし (ErrNoRows自体はエラーではない)
		} else {
			return err // その他のDBエラー
		}
	}

	// レコードが見つかった場合
	if maxYj.Valid && strings.HasPrefix(maxYj.String, "MA2Y") {
		numPart := strings.TrimPrefix(maxYj.String, "MA2Y")
		maxNum, _ = strconv.Atoi(numPart)
	}

	// ログを出力（何番に設定しようとしているか）
	log.Printf("INFO: [Sequence] Setting 'MA2Y' last_no to %d", maxNum)

	_, err = tx.Exec(`UPDATE code_sequences SET last_no = ? WHERE name = 'MA2Y'`, maxNum)
	return err
}

func InitializeSequenceFromMaxProductCode(tx *sqlx.Tx) error {
	var maxCode sql.NullString
	// product_code カラムから MA2J... の最大値を取得
	err := tx.Get(&maxCode, "SELECT product_code FROM product_master WHERE product_code LIKE 'MA2J%' ORDER BY product_code DESC LIMIT 1")

	maxNum := 0 // デフォルト (該当レコードなしの場合)
	if err != nil {
		if err == sql.ErrNoRows {
			// レコードなし (ErrNoRows自体はエラーではない)
		} else {
			return err
		}
	}

	// レコードが見つかった場合
	if maxCode.Valid && strings.HasPrefix(maxCode.String, "MA2J") {
		numPart := strings.TrimPrefix(maxCode.String, "MA2J")
		maxNum, _ = strconv.Atoi(numPart)
	}

	// ログを出力（何番に設定しようとしているか）
	log.Printf("INFO: [Sequence] Setting 'MA2J' last_no to %d", maxNum)

	_, err = tx.Exec(`UPDATE code_sequences SET last_no = ? WHERE name = 'MA2J'`, maxNum)
	return err
}


----- C:\Users\wasab\OneDrive\デスクトップ\TKR\database\stock_migration.go -----
// C:\Users\wasab\OneDrive\デスクトップ\TKR\database\stock_migration.go
package database

import (
	"database/sql"
	"fmt"
	"tkr/model"

	"github.com/jmoiron/sqlx"
)

func ClearAllPackageStockInTx(tx *sqlx.Tx) error {
	_, err := tx.Exec("DELETE FROM package_stock")
	if err !=
		nil {
		return fmt.Errorf("failed to clear package_stock: %w", err)
	}
	_, err = tx.Exec("DELETE FROM transaction_records WHERE flag = 0")
	if err != nil {
		return fmt.Errorf("failed to clear old inventory transactions (flag=0): %w", err)
	}
	return nil
}

func GetAllPackageStock(db *sqlx.DB) ([]model.PackageStock, error) {
	var stocks []model.PackageStock
	const q = `
		SELECT package_key, yj_code, stock_quantity_yj, last_inventory_date
		FROM package_stock
		ORDER BY yj_code
	`
	err := db.Select(&stocks, q)
	if err != nil {
		return nil, fmt.Errorf("failed to get all package_stock: %w", err)
	}
	return stocks, nil
}

func GetRepresentativeProductNameMap(db *sqlx.DB) (map[string]string, error) {
	var results []struct {
		YjCode      string `db:"yj_code"`
		ProductName string `db:"product_name"`
	}

	const q = `
		SELECT yj_code, product_name
		FROM product_master
		WHERE (yj_code, origin = 'JCSHMS') IN (
			SELECT yj_code, MAX(origin = 'JCSHMS')
			FROM product_master
			WHERE yj_code 
!= ''
			GROUP BY yj_code
		)
	`
	err := db.Select(&results, q)
	if err != nil {
		return nil, fmt.Errorf("failed to get representative product names: %w", err)
	}

	nameMap := make(map[string]string)
	for _, r := range results {
		nameMap[r.YjCode] = r.ProductName
	}
	return nameMap, nil
}

type StockDetailItem struct {
	JanCode     string  `db:"jan_code"`
	Gs1Code     string  `db:"gs1_code"`
	ProductName string  `db:"product_name"`
	JanQuantity float64 `db:"jan_quantity"`
	ExpiryDate  string  `db:"expiry_date"`
	LotNumber   string  `db:"lot_number"`
}

func GetCurrentStockDetails(db *sqlx.DB) ([]StockDetailItem, error) {
	var items []StockDetailItem

	var latestInventoryDate string
	err := db.Get(&latestInventoryDate, `
		SELECT MAX(last_inventory_date) 
		FROM package_stock
	`)
	if err != nil {
		if err == sql.ErrNoRows {
			return items, nil
		}
		return nil, fmt.Errorf("failed to get latest inventory date from package_stock: %w", err)
	}

	if latestInventoryDate == "" {
		return items, nil
	}

	query := `
		SELECT 
			T.jan_code, 
			COALESCE(P.gs1_code, '') AS gs1_code, 
			T.product_name, 
			T.jan_quantity, 
			T.expiry_date, 
			T.lot_number
		FROM transaction_records AS T
		LEFT JOIN product_master AS P ON T.jan_code = P.product_code
		WHERE T.flag = 0 
		  AND T.transaction_date = ?
AND T.jan_quantity > 0
		ORDER BY P.kana_name, T.jan_code, T.expiry_date, T.lot_number
	`

	if err := db.Select(&items, query, latestInventoryDate); err != nil {
		return nil, fmt.Errorf("failed to select current stock details: %w", err)
	}

	return items, nil
}

// ▼▼▼【ここから修正】製品ごとの最新日以外を削除するロジックに変更 ▼▼▼
func DeleteOldInventoryTransactions(tx *sqlx.Tx) (int64, error) {
	// package_stock に (yj_code, last_inventory_date) のペアで存在する
	// 最新の棚卸履歴(flag=0) *以外* の、古い履歴を削除する
	const q = `
		DELETE FROM transaction_records
		WHERE flag = 0 AND id IN (
			SELECT T.id
			FROM transaction_records AS T
			LEFT JOIN package_stock AS P ON T.yj_code = P.yj_code AND T.transaction_date = P.last_inventory_date
			WHERE T.flag = 0 AND P.package_key IS NULL
		)
	`
	res, err := tx.Exec(q)
	if err != nil {
		return 0, fmt.Errorf("failed to delete old inventory transactions: %w", err)
	}

	rowsAffected, err := res.RowsAffected()
	if err != nil {
		return 0, fmt.Errorf("failed to get affected rows: %w", err)
	}

	return rowsAffected, nil
}

// ▲▲▲【修正ここまで】▲▲▲


----- C:\Users\wasab\OneDrive\デスクトップ\TKR\database\stock.go -----
// C:\Users\wasab\OneDrive\デスクトップ\TKR\database\stock.go
package database

import (
	"database/sql"
	"fmt"
	"tkr/model"
)

func CalculateStockOnDate(dbtx DBTX, productCode string, targetDate string) (float64, error) {

	master, err := GetProductMasterByCode(dbtx, productCode)
	if err != nil {
		if err == sql.ErrNoRows {
			return 0, nil
		}
		return 0, fmt.Errorf("failed to get master for stock calculation (ProductCode: %s): %w", productCode, err)
	}

	// ▼▼▼ 修正: GeneratePackageKey を使用して、DB保存済みのキー（単位名変換済み）と一致させる ▼▼▼
	packageKey := GeneratePackageKey(master)
	// ▲▲▲ 修正ここまで ▲▲▲

	var latestInvDate string
	var baseStock float64

	var stockInfo model.PackageStock
	err = dbtx.Get(&stockInfo, `
		SELECT package_key, stock_quantity_yj, last_inventory_date 
		FROM package_stock 
		WHERE package_key = ? AND last_inventory_date <= ?
		ORDER BY last_inventory_date DESC LIMIT 1`,
		packageKey, targetDate)

	if err != nil && err != sql.ErrNoRows {
		return 0, fmt.Errorf("failed to get package_stock for %s on or before %s: %w", packageKey, targetDate, err)
	}

	if err == nil {
		baseStock = stockInfo.StockQuantityYj
		latestInvDate = stockInfo.LastInventoryDate

		if latestInvDate == targetDate {
			return baseStock, nil
		}

		var netChangeAfterInvDate sql.NullFloat64
		err = dbtx.Get(&netChangeAfterInvDate, `
			SELECT SUM(CASE WHEN flag IN (1, 11) THEN yj_quantity WHEN flag IN (2, 3, 12) THEN -yj_quantity ELSE 0 END)
			FROM transaction_records
			WHERE jan_code = ? AND flag IN (1, 2, 3, 11, 12) AND transaction_date > ? AND transaction_date <= ?`,
			productCode, latestInvDate, targetDate)

		if err != nil && err != sql.ErrNoRows {
			return 0, fmt.Errorf("failed to calculate net change after inventory date for %s: %w", productCode, err)
		}

		return baseStock + netChangeAfterInvDate.Float64, nil

	} else {
		var totalNetChange sql.NullFloat64

		err = dbtx.Get(&totalNetChange, `
			SELECT SUM(CASE WHEN flag IN (1, 11) THEN yj_quantity WHEN flag IN (2, 3, 12) THEN -yj_quantity ELSE 0 END)
			FROM transaction_records
			WHERE jan_code = ? AND flag IN (1, 2, 3, 11, 12) AND transaction_date <= ?`,
			productCode, targetDate)

		if err != nil && err != sql.ErrNoRows {
			return 0, fmt.Errorf("failed to calculate total net change for %s: %w", productCode, err)
		}
		return totalNetChange.Float64, nil
	}
}


----- C:\Users\wasab\OneDrive\デスクトップ\TKR\database\transaction_records_query.go -----
// C:\Users\wasab\OneDrive\デスクトップ\TKR\database\transaction_records_query.go
package database

import (
	"database/sql"
	"fmt"
	"strings"
	"tkr/model"

	"github.com/jmoiron/sqlx"
)

const TransactionColumns = `
    id, transaction_date, client_code, 

receipt_number, line_number, flag,
    jan_code, yj_code, product_name, kana_name, usage_classification, package_form, package_spec, maker_name,
    dat_quantity, jan_pack_inner_qty, jan_quantity, jan_pack_unit_qty, jan_unit_name, jan_unit_code,
    yj_quantity, yj_pack_unit_qty, yj_unit_name, unit_price, purchase_price, supplier_wholesale,
    subtotal, tax_amount, tax_rate, expiry_date, lot_number, flag_poison,
    flag_deleterious, flag_narcotic, flag_psychotropic, flag_stimulant,
    flag_stimulant_raw, process_flag_ma`

func ScanTransactionRecord(row interface{ Scan(...interface{}) error }) (*model.TransactionRecord, error) {
	var r model.TransactionRecord
	err := row.Scan(
		&r.ID, &r.TransactionDate, &r.ClientCode, &r.ReceiptNumber, &r.LineNumber, &r.Flag,
		&r.JanCode, &r.YjCode, &r.ProductName, &r.KanaName, &r.UsageClassification, &r.PackageForm, &r.PackageSpec, &r.MakerName,
		&r.DatQuantity, &r.JanPackInnerQty, &r.JanQuantity, &r.JanPackUnitQty, &r.JanUnitName, &r.JanUnitCode,
		&r.YjQuantity, &r.YjPackUnitQty, &r.YjUnitName, &r.UnitPrice, &r.PurchasePrice, &r.SupplierWholesale,
		&r.Subtotal,
		&r.TaxAmount,
		&r.TaxRate, &r.ExpiryDate, &r.LotNumber, &r.FlagPoison,
		&r.FlagDeleterious, &r.FlagNarcotic, &r.FlagPsychotropic, &r.FlagStimulant,
		&r.FlagStimulantRaw, &r.ProcessFlagMA,
	)
	if err != nil {
		return nil, err
	}
	return &r, nil
}

const insertTransactionQuery = `
INSERT OR REPLACE INTO transaction_records (
    transaction_date, client_code, receipt_number, line_number, flag,
    jan_code, yj_code, product_name, kana_name, usage_classification, package_form, package_spec, maker_name,
    dat_quantity, jan_pack_inner_qty, jan_quantity, jan_pack_unit_qty, jan_unit_name, jan_unit_code,
    yj_quantity, yj_pack_unit_qty, yj_unit_name, unit_price, purchase_price, supplier_wholesale,
    subtotal, tax_amount, tax_rate, expiry_date, lot_number, flag_poison,
    flag_deleterious, flag_narcotic, flag_psychotropic, flag_stimulant,
    flag_stimulant_raw, process_flag_ma
) VALUES (
    :transaction_date, :client_code, :receipt_number, :line_number, :flag,
    :jan_code, :yj_code, :product_name, :kana_name, :usage_classification, 
:package_form, 
:package_spec, :maker_name,
    :dat_quantity, 
:jan_pack_inner_qty, :jan_quantity, :jan_pack_unit_qty, :jan_unit_name, :jan_unit_code,
   

 :yj_quantity, :yj_pack_unit_qty, :yj_unit_name, :unit_price, :purchase_price, :supplier_wholesale,
    :subtotal, :tax_amount, :tax_rate, :expiry_date, :lot_number, :flag_poison,
    :flag_deleterious, :flag_narcotic, :flag_psychotropic, :flag_stimulant,
    :flag_stimulant_raw, :process_flag_ma
)`

func InsertTransactionRecord(tx *sqlx.Tx, record model.TransactionRecord) error {
	_, err := tx.NamedExec(insertTransactionQuery, record)
	if err != nil {
		return fmt.Errorf("failed to insert transaction record: %w", err)
	}
	return nil
}

const updateTransactionQuery = `
UPDATE transaction_records SET
    transaction_date = :transaction_date,
    client_code = :client_code,
    receipt_number = :receipt_number,
    line_number = :line_number, 
    flag = :flag,
 
   jan_code = 
:jan_code,
    yj_code = :yj_code,
   

 product_name = :product_name,
    kana_name = :kana_name,
    usage_classification = :usage_classification,
    package_form = :package_form,
    package_spec = :package_spec,
    maker_name = :maker_name,
    dat_quantity = :dat_quantity,
    jan_pack_inner_qty = :jan_pack_inner_qty,
    jan_quantity = :jan_quantity,
    jan_pack_unit_qty = :jan_pack_unit_qty,
    jan_unit_name = :jan_unit_name,
    jan_unit_code = :jan_unit_code,
    yj_quantity = :yj_quantity,
    
yj_pack_unit_qty = :yj_pack_unit_qty, 
    
 yj_unit_name = :yj_unit_name,
   
     unit_price = :unit_price,
 

   purchase_price = :purchase_price,
    supplier_wholesale = :supplier_wholesale,
    subtotal = :subtotal,
    tax_amount = :tax_amount,
    tax_rate = :tax_rate,
    expiry_date = :expiry_date,
    lot_number = :lot_number,
    flag_poison = :flag_poison,
    flag_deleterious = :flag_deleterious,
    flag_narcotic = :flag_narcotic,
    flag_psychotropic = :flag_psychotropic,
    flag_stimulant = :flag_stimulant,
    flag_stimulant_raw = :flag_stimulant_raw,
    process_flag_ma = :process_flag_ma
WHERE id = :id`

func UpdateFullTransactionInTx(tx *sqlx.Tx, rec *model.TransactionRecord) error {
	_, err := tx.NamedExec(updateTransactionQuery, rec)
	if err !=
		nil {
		return fmt.Errorf("UpdateFullTransactionInTx failed for ID %d: %w", rec.ID, err)
	}
	return nil
}

func PersistTransactionRecordsInTx(tx *sqlx.Tx, records []model.TransactionRecord) error {
	stmt, err := tx.PrepareNamed(insertTransactionQuery)
	if err != nil {
		return fmt.Errorf("failed to prepare statement for transaction_records: %w", err)
	}
	defer stmt.Close()

	for _, rec := range records {
		_, err = stmt.Exec(rec)
		if err != nil {
			return fmt.Errorf("failed to exec statement for transaction_records (JAN: %s): %w", rec.JanCode, err)
		}
	}
	return nil
}

func DeleteUsageTransactionsInDateRange(tx *sqlx.Tx, minDate, maxDate string) error {
	// ▼▼▼【ここを修正】flag = '2' -> '3' (処方) に変更 ▼▼▼
	const q = `DELETE FROM transaction_records WHERE flag = '3' AND transaction_date BETWEEN ?
AND ?`
	// ▲▲▲【修正ここまで】▲▲▲
	_, err := tx.Exec(q, minDate, maxDate)
	if err != nil {
		return fmt.Errorf("failed to delete usage transactions in date range: %w", err)
	}
	return nil
}

func GetTransactionsByProductCodes(db *sqlx.DB, productCodes []string) (map[string][]model.TransactionRecord, error) {
	transactionsByProductCode := make(map[string][]model.TransactionRecord)
	if len(productCodes) == 0 {
		return transactionsByProductCode, nil
	}

	batchSize := 100

	for i := 0; i < len(productCodes); i += batchSize {
		end := i + batchSize
		if end > len(productCodes) {
			end = len(productCodes)
		}
		batch := productCodes[i:end]

		var records []model.TransactionRecord
		query, args, err := sqlx.In(`SELECT `+TransactionColumns+` FROM transaction_records WHERE jan_code IN (?)`, batch)
		if err != nil {
			return nil, fmt.Errorf("failed to create IN query for batch: %w", err)
		}
		query = db.Rebind(query)
		err = db.Select(&records, query, args...)
		if err != nil {
			return nil, fmt.Errorf("failed to select transactions for batch: %w", err)
		}

		for _, r := range records {
			transactionsByProductCode[r.JanCode] = append(transactionsByProductCode[r.JanCode], r)
		}
	}

	return transactionsByProductCode, nil
}

func SearchTransactions(db *sqlx.DB, janCode string, expiryYYYYMM string, lotNumber string) ([]model.TransactionRecord, error) {
	var records []model.TransactionRecord

	var queryBuilder strings.Builder
	queryBuilder.WriteString("SELECT ")
	queryBuilder.WriteString(TransactionColumns)
	queryBuilder.WriteString(" FROM transaction_records WHERE flag IN (1, 2)")

	args :=
		[]interface{}{}

	if janCode != "" {
		queryBuilder.WriteString(" AND jan_code = ?")
		args = append(args, janCode)
	}

	if expiryYYYYMM != "" {
		queryBuilder.WriteString(" AND expiry_date = ?")
		args = append(args, expiryYYYYMM)
	}

	if lotNumber != "" {
		queryBuilder.WriteString(" AND lot_number = ?")
		args = append(args, lotNumber)
	}

	queryBuilder.WriteString(" ORDER BY transaction_date DESC, id DESC")

	err := db.Select(&records, queryBuilder.String(), args...)
	if err != nil {
		return nil, fmt.Errorf("failed to search transactions: %w", err)
	}
	return records, nil
}

func GetReceiptNumbersByDate(db *sqlx.DB, date string, prefix string, clientCode string) ([]string, error) {
	var numbers []string

	query := "SELECT DISTINCT receipt_number FROM transaction_records"
	conditions := []string{"transaction_date = ?", "receipt_number LIKE ?"}
	args := []interface{}{date, prefix +
		"%"}

	if clientCode != "" {
		conditions = append(conditions, "client_code = ?")
		args = append(args, clientCode)
	}

	query +=
		" WHERE " + strings.Join(conditions, " AND ")
	query += " ORDER BY receipt_number"

	err := db.Select(&numbers, query, args...)
	if err != nil {
		return nil, fmt.Errorf("failed to get receipt numbers by date: %w", err)
	}
	return numbers, nil
}

func GetTransactionsByReceiptNumber(db *sqlx.DB, receiptNumber string) ([]model.TransactionRecord, error) {
	var records []model.TransactionRecord
	q := `SELECT ` + TransactionColumns + ` FROM transaction_records WHERE receipt_number = ?
ORDER BY line_number`

	err := db.Select(&records, q, receiptNumber)
	if err != nil {
		return nil, fmt.Errorf("failed to get transactions by receipt number: %w", err)
	}
	return records, nil
}

func DeleteTransactionsByReceiptNumberInTx(tx *sqlx.Tx, receiptNumber string) error {
	q := `DELETE FROM transaction_records WHERE receipt_number = ?`
	_, err := tx.Exec(q, receiptNumber)
	if err != nil {
		return fmt.Errorf("failed to delete transactions for receipt %s: %w", receiptNumber, err)
	}
	return nil
}

func GetLatestInventoryDetailsByYjCode(dbtx DBTX, yjCode string) ([]model.TransactionRecord, error) {
	var latestInventoryDate sql.NullString
	err := dbtx.Get(&latestInventoryDate, `
		SELECT MAX(last_inventory_date) 
		FROM package_stock 
		WHERE yj_code = ?`,
		yjCode)

	if err != nil && err != sql.ErrNoRows {
		return nil, fmt.Errorf("failed to get latest inventory date from package_stock for %s: %w", yjCode, err)
	}

	if !latestInventoryDate.Valid ||
		latestInventoryDate.String == "" {
		return []model.TransactionRecord{}, nil
	}

	var records []model.TransactionRecord
	q := `SELECT ` + TransactionColumns + ` 
		  FROM transaction_records 
		  WHERE yj_code = ?
AND transaction_date = ? 
		  AND flag = 0 
		  ORDER BY jan_code, expiry_date, lot_number`

	err = dbtx.Select(&records, q, yjCode, latestInventoryDate.String)
	if err != nil {
		return nil, fmt.Errorf("failed to query latest inventory (flag=0) transactions for %s on %s: %w", yjCode, latestInventoryDate.String, err)
	}

	return records, nil
}


----- C:\Users\wasab\OneDrive\デスクトップ\TKR\database\transaction.go -----
package database

// model パッケージをインポート

// TODO: 必要に応じて DeleteTransactionByReceiptNumber などの関数もここに追加していきます。


----- C:\Users\wasab\OneDrive\デスクトップ\TKR\database\valuation.go -----
// C:\Users\wasab\OneDrive\デスクトップ\TKR\database\valuation.go
package database

import (
	"database/sql"
	"fmt"
	"sort"
	"strings"
	"tkr/model"
	"tkr/units"

	"github.com/jmoiron/sqlx"
)

// ValuationGroup は剤型ごとの在庫評価額の集計結果を保持します。
// (WASABI: db/valuation.go より移植)
type ValuationGroup struct {
	UsageClassification string                     `json:"usageClassification"`
	DetailRows          []model.ValuationDetailRow `json:"detailRows"`
	TotalNhiValue       float64                    `json:"totalNhiValue"`
	TotalPurchaseValue  float64                    `json:"totalPurchaseValue"`
}

// GetInventoryValuation は、指定された基準日時点での在庫評価レポートを生成します。
// (WASABI: db/valuation.go を TKR 用に修正)
func GetInventoryValuation(conn *sqlx.DB, filters model.ValuationFilters) ([]ValuationGroup, error) {

	// 1. フィルタ条件に合致する製品マスターを取得
	masterQuery := `SELECT ` + SelectColumns + ` FROM product_master WHERE 1=1`
	var masterArgs []interface{}
	if filters.KanaName != "" {
		masterQuery += " AND (kana_name LIKE ? OR product_name LIKE ?)"
		masterArgs = append(masterArgs, "%"+filters.KanaName+"%", "%"+filters.KanaName+"%")
	}
	if filters.UsageClassification != "" && filters.UsageClassification != "all" {
		masterQuery += " AND usage_classification = ?"
		masterArgs = append(masterArgs, filters.UsageClassification)
	}

	allMasters, err := getAllProductMastersFiltered(conn, masterQuery, masterArgs...)
	if err != nil {
		return nil, fmt.Errorf("failed to get filtered product masters: %w", err)
	}
	if len(allMasters) == 0 {
		return []ValuationGroup{}, nil
	}

	// 採用済みマスター（JCSHMS由来）を持つYJコードをマップに記録
	yjHasJcshmsMaster := make(map[string]bool)
	// JANコードをキーにしたマスターマップ
	mastersByJanCode := make(map[string]*model.ProductMaster)
	for _, master := range allMasters {
		if master.Origin == "JCSHMS" {
			yjHasJcshmsMaster[master.YjCode] = true
		}
		mastersByJanCode[master.ProductCode] = master
	}

	// TKRの package_key 形式でマスターをグループ化
	mastersByPackageKey := make(map[string][]*model.ProductMaster)
	for _, master := range allMasters {
		key := fmt.Sprintf("%s|%s|%g|%s", master.YjCode, master.PackageForm, master.JanPackInnerQty, units.ResolveName(master.YjUnitName))
		mastersByPackageKey[key] = append(mastersByPackageKey[key], master)
	}

	var detailRows []model.ValuationDetailRow

	// 2. 包装キーごとにループ
	// ▼▼▼【ここから修正】 PackageKey もループ変数で取得 ▼▼▼
	for key, mastersInPackageGroup := range mastersByPackageKey {
		// ▲▲▲【修正ここまで】▲▲▲
		var totalStockForPackage float64

		// 3. 包装グループ内の全JANの在庫を指定日で計算
		for _, m := range mastersInPackageGroup {
			// TKRの CalculateStockOnDate を使用
			stock, err := CalculateStockOnDate(conn, m.ProductCode, filters.Date)
			if err != nil {
				return nil, fmt.Errorf("failed to calculate stock on date for product %s: %w", m.ProductCode, err)
			}
			totalStockForPackage += stock
		}

		if totalStockForPackage == 0 {
			continue // 在庫ゼロの包装はスキップ
		}

		// 代表マスターを選定 (JCSHMS優先)
		var repMaster *model.ProductMaster
		if len(mastersInPackageGroup) > 0 {
			repMaster = mastersInPackageGroup[0]
			for _, m := range mastersInPackageGroup {
				if m.Origin == "JCSHMS" {
					repMaster = m
					break
				}
			}
		} else {
			continue // マスターがいないキーはスキップ
		}

		// 仮マスター（PROVISIONAL）しか存在しないYJコードの場合、警告フラグ
		showAlert := false
		if repMaster.Origin != "JCSHMS" && !yjHasJcshmsMaster[repMaster.YjCode] {
			showAlert = true
		}

		// 包装仕様 (TKRの units.FormatPackageSpec が要求する型に合わせる)
		tempJcshmsInfo := model.JcshmsInfo{
			PackageForm:     repMaster.PackageForm,
			YjUnitName:      repMaster.YjUnitName,
			YjPackUnitQty:   repMaster.YjPackUnitQty,
			JanPackInnerQty: sql.NullFloat64{Float64: repMaster.JanPackInnerQty, Valid: true},
			JanPackUnitQty:  sql.NullFloat64{Float64: repMaster.JanPackUnitQty, Valid: true},
			JanUnitCode:     sql.NullString{String: fmt.Sprintf("%d", repMaster.JanUnitCode), Valid: true},
		}
		spec := units.FormatPackageSpec(&tempJcshmsInfo)

		// 4. 評価額を計算
		unitNhiPrice := repMaster.NhiPrice
		totalNhiValue := totalStockForPackage * unitNhiPrice
		packageNhiPrice := unitNhiPrice * repMaster.YjPackUnitQty

		var totalPurchaseValue float64
		// 仕入単価 (PurchasePrice) は包装単位あたりの価格
		if repMaster.YjPackUnitQty > 0 {
			// YJ単位あたりの仕入単価 = 包装単価 / YJ包装数
			unitPurchasePrice := repMaster.PurchasePrice / repMaster.YjPackUnitQty
			totalPurchaseValue = totalStockForPackage * unitPurchasePrice
		}

		detailRows = append(detailRows, model.ValuationDetailRow{
			YjCode:               repMaster.YjCode,
			ProductName:          repMaster.ProductName,
			ProductCode:          repMaster.ProductCode, // 代表JAN
			PackageSpec:          spec,
			Stock:                totalStockForPackage, // YJ単位
			YjUnitName:           units.ResolveName(repMaster.YjUnitName),
			PackageNhiPrice:      packageNhiPrice,
			PackagePurchasePrice: repMaster.PurchasePrice,
			TotalNhiValue:        totalNhiValue,
			TotalPurchaseValue:   totalPurchaseValue,
			ShowAlert:            showAlert,
			// ▼▼▼【ここから追加】CSV出力用の項目を設定 ▼▼▼
			PackageKey:      key, // ループ変数から PackageKey を設定
			JanPackInnerQty: repMaster.JanPackInnerQty,
			// ▲▲▲【追加ここまで】▲▲▲
		})
	}

	// 5. 剤型ごとにグループ化
	resultGroups := make(map[string]*ValuationGroup)
	for _, row := range detailRows {
		// 代表JANのマスター情報をマップから取得
		master, ok := mastersByJanCode[row.ProductCode]
		if !ok {
			continue
		}
		uc := master.UsageClassification
		if uc == "" {
			uc = "他"
		}
		group, ok := resultGroups[uc]
		if !ok {
			group = &ValuationGroup{UsageClassification: uc}
			resultGroups[uc] = group
		}
		group.DetailRows = append(group.DetailRows, row)
		group.TotalNhiValue += row.TotalNhiValue
		group.TotalPurchaseValue += row.TotalPurchaseValue
	}

	// 6. 最終結果をソート
	order := map[string]int{"内": 1, "外": 2, "歯": 3, "注": 4, "機": 5, "他": 6}
	var finalResult []ValuationGroup
	for _, group := range resultGroups {
		sort.Slice(group.DetailRows, func(i, j int) bool {
			// カナ名でソートするためにマスター情報を参照
			masterI, okI := mastersByJanCode[group.DetailRows[i].ProductCode]
			masterJ, okJ := mastersByJanCode[group.DetailRows[j].ProductCode]
			if !okI || !okJ {
				return group.DetailRows[i].ProductCode < group.DetailRows[j].ProductCode
			}
			return masterI.KanaName < masterJ.KanaName
		})
		finalResult = append(finalResult, *group)
	}
	sort.Slice(finalResult, func(i, j int) bool {
		prioI, okI := order[strings.TrimSpace(finalResult[i].UsageClassification)]
		if !okI {
			prioI = 7
		}
		prioJ, okJ := order[strings.TrimSpace(finalResult[j].UsageClassification)]
		if !okJ {
			prioJ = 7
		}
		return prioI < prioJ
	})

	return finalResult, nil
}

// getAllProductMastersFiltered はフィルタ条件に基づいて製品マスターを取得するヘルパー関数です。
// (WASABI: db/valuation.go より移植)
func getAllProductMastersFiltered(conn *sqlx.DB, query string, args ...interface{}) ([]*model.ProductMaster, error) {
	rows, err := conn.Query(query, args...)
	if err != nil {
		return nil, fmt.Errorf("GetAllProductMastersFiltered query failed: %w", err)
	}
	defer rows.Close()

	var masters []*model.ProductMaster
	for rows.Next() {
		// TKRの ScanProductMaster を使用
		m, err := ScanProductMaster(rows)
		if err != nil {
			return nil, err
		}
		masters = append(masters, m)
	}
	return masters, nil
}


----- C:\Users\wasab\OneDrive\デスクトップ\TKR\database\wholesalers.go -----
// C:\Users\wasab\OneDrive\デスクトップ\TKR\database\wholesalers.go
package database

import (
	"fmt"
	"tkr/model"

	"github.com/jmoiron/sqlx"
)

func GetAllWholesalers(db *sqlx.DB) ([]model.Wholesaler, error) {
	var wholesalers []model.Wholesaler
	err := db.Select(&wholesalers, "SELECT wholesaler_code, wholesaler_name FROM wholesalers ORDER BY wholesaler_code") // [cite: 2540]
	if err != nil {
		return nil, fmt.Errorf("failed to get all wholesalers: %w", err)
	}
	return wholesalers, nil
}

// ▼▼▼【ここから追加】卸コードと卸名のマップを取得する関数 ▼▼▼
func GetWholesalerMap(db *sqlx.DB) (map[string]string, error) {
	wholesalers, err := GetAllWholesalers(db)
	if err != nil {
		return nil, fmt.Errorf("failed to get wholesaler list for map: %w", err)
	}

	wholesalerMap := make(map[string]string)
	for _, w := range wholesalers {
		wholesalerMap[w.WholesalerCode] = w.WholesalerName
	}
	return wholesalerMap, nil
}

// ▲▲▲【追加ここまで】▲▲▲

func CreateWholesaler(db *sqlx.DB, code, name string) error {
	const q = `INSERT INTO wholesalers (wholesaler_code, wholesaler_name) VALUES (?, ?)`
	_, err := db.Exec(q, code, name)
	if err != nil {
		return fmt.Errorf("CreateWholesaler failed: %w", err)
	}
	return nil
}

// ▼▼▼【ここから追加】(client_master の UpsertClientInTx [cite: 2449] を参考に作成) ▼▼▼
// UpsertWholesalerInTx は卸マスタにデータを挿入または更新します。
func UpsertWholesalerInTx(tx *sqlx.Tx, code, name string) error {
	const q = `
		INSERT INTO wholesalers (wholesaler_code, wholesaler_name) 
		VALUES (?, ?)
		ON CONFLICT(wholesaler_code) DO UPDATE SET
			wholesaler_name = excluded.wholesaler_name
	`
	_, err := tx.Exec(q, code, name)
	if err != nil {
		return fmt.Errorf("UpsertWholesalerInTx (Code: %s, Name: %s) failed: %w", code, name, err)
	}
	return nil
}

// ▲▲▲【追加ここまで】▲▲▲

func DeleteWholesaler(db *sqlx.DB, code string) error {
	const q = `DELETE FROM wholesalers WHERE wholesaler_code = ?` // [cite: 2541]
	_, err := db.Exec(q, code)
	if err != nil {
		return fmt.Errorf("failed to delete wholesaler with code %s: %w", code, err)
	}
	return nil
}


----- C:\Users\wasab\OneDrive\デスクトップ\TKR\deadstock\handler.go -----
// C:\Users\wasab\OneDrive\デスクトップ\TKR\deadstock\handler.go
package deadstock

import (
	"bytes"
	"database/sql"
	"encoding/json"
	"errors"
	"fmt"
	"log"
	"net/http"
	"net/url"
	"strconv"
	"strings"
	"tkr/database"
	"tkr/mappers"
	"tkr/mastermanager"
	"tkr/model"
	"tkr/parsers"

	"github.com/jmoiron/sqlx"
)

type DeadStockListResponse struct {
	Items  []model.DeadStockItem `json:"items"`
	Errors []string              `json:"errors"`
}

func ListDeadStockHandler(db *sqlx.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		startDate := r.URL.Query().Get("startDate")
		endDate := r.URL.Query().Get("endDate")
		// ▼▼▼【ここに追加】excludeZeroStock を取得 ▼▼▼
		excludeZeroStock := r.URL.Query().Get("excludeZeroStock") == "true"
		// ▲▲▲【追加ここまで】▲▲▲

		if startDate == "" ||
			endDate == "" {
			http.Error(w, "startDate and endDate (YYYYMMDD) are required.", http.StatusBadRequest)
			return
		}

		// ▼▼▼【ここを修正】excludeZeroStock を渡す ▼▼▼
		items, err := database.GetDeadStockList(db, startDate, endDate, excludeZeroStock)
		// ▲▲▲【修正ここまで】▲▲▲
		if err != nil {
			http.Error(w, "Failed to get dead stock list: "+err.Error(), http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(DeadStockListResponse{
			Items:  items,
			Errors: nil,
		})
	}
}

func UploadDeadStockCSVHandler(db *sqlx.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		if r.Method != http.MethodPost {
			http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
			return
		}

		file, _, err := r.FormFile("file")
		if err != nil {
			http.Error(w, "CSVファイルの読み取りに失敗: "+err.Error(), http.StatusBadRequest)
			return
		}
		defer file.Close()

		records, err := parsers.ParseDeadStockCSV(file)
		if err != nil {
			http.Error(w, "CSVファイルの解析に失敗: "+err.Error(), http.StatusBadRequest)
			return
		}

		if len(records) == 0 {
			http.Error(w, "読み込むデータがありません（0件、または JAN数量 が 0 です）。", http.StatusBadRequest)
			return
		}

		date := r.FormValue("date")
		if date == "" ||
			len(date) != 8 {
			http.Error(w, "日付(YYYYMMDD)が不正です。", http.StatusBadRequest)
			return
		}

		tx, err := db.Beginx()
		if err != nil {
			http.Error(w, "データベーストランザクションの開始に失敗: "+err.Error(), http.StatusInternalServerError)
			return
		}
		defer tx.Rollback()

		insertedCount, err := registerDeadStockCSVAsInventory(tx, records, date)
		if err != nil {
			log.Printf("ERROR: registerDeadStockCSVAsInventory: %v", err)
			http.Error(w, "棚卸データの登録に失敗しました: "+err.Error(), http.StatusInternalServerError)
			return
		}

		if err := tx.Commit(); err != nil {
			http.Error(w, "データベースのコミットに失敗: "+err.Error(), http.StatusInternalServerError)
			return
		}

		log.Printf("Successfully imported dead stock CSV for date %s, inserted %d records.", date, insertedCount)
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]interface{}{
			"message": fmt.Sprintf("%d件の棚卸データを登録しました。", insertedCount),
		})
	}
}

func registerDeadStockCSVAsInventory(tx *sqlx.Tx, records []parsers.ParsedDeadStockCSVRecord, date string) (int, error) {

	packageStockTotalsYj := make(map[string]float64)
	yjCodeMap := make(map[string]bool)
	var transactionsToInsert []model.TransactionRecord

	var lastSeq int
	var dateYYMMDD string
	if len(date) >= 8 {
		dateYYMMDD = date[2:8]
	} else {
		dateYYMMDD = date
	}
	// ▼▼▼【修正】ADJ -> AJ ▼▼▼
	prefix := "AJ" + dateYYMMDD
	// ▲▲▲【修正ここまで】▲▲▲

	var lastReceiptNumber string
	err := tx.Get(&lastReceiptNumber, `SELECT receipt_number FROM transaction_records WHERE receipt_number LIKE ?
ORDER BY receipt_number DESC LIMIT 1`, prefix+"%")
	if err != nil && err != sql.ErrNoRows {
		return 0, fmt.Errorf("伝票番号の採番に失敗: %w", err)
	}
	// ▼▼▼【修正】14桁 -> 13桁, 9文字目 -> 8文字目 ▼▼▼
	if lastReceiptNumber != "" && len(lastReceiptNumber) == 13 {
		seqStr := lastReceiptNumber[8:]
		lastSeq, _ = strconv.Atoi(seqStr)
	}
	// ▲▲▲【修正ここまで】▲▲▲

	for i, rec := range records {

		var master *model.ProductMaster
		var err error
		var keyForLog string

		if rec.Gs1Code != "" {
			keyForLog = "GS1:" + rec.Gs1Code
			master, err = database.GetProductMasterByGs1Code(tx, rec.Gs1Code)
			if err != nil && !errors.Is(err, sql.ErrNoRows) {
				return 0, fmt.Errorf("GS1コードでのマスター検索に失敗 (GS1: %s): %w", rec.Gs1Code, err)
			}
		}

		if master == nil && rec.ProductCode != "" {
			keyForLog = "JAN:" + rec.ProductCode
			master, err = database.GetProductMasterByCode(tx, rec.ProductCode)
			if err != nil && !errors.Is(err, sql.ErrNoRows) {
				return 0, fmt.Errorf("JANコードでのマスター検索に失敗 (JAN: %s): %w", rec.ProductCode, err)
			}
		}

		if master == nil {
			keyForCreate := rec.Gs1Code
			if keyForCreate == "" {
				keyForCreate = rec.ProductCode
			}

			if keyForCreate == "" {
				log.Printf("WARN: CSVレコードに JANコード も GS1コード もないためスキップ (品名: %s)", rec.ProductName)
				continue
			}
			keyForLog = "Create:" + keyForCreate

			master, err = mastermanager.FindOrCreateMaster(tx, keyForCreate, rec.ProductName)
			if err != nil {
				return 0, fmt.Errorf("マスターの検索/作成に失敗 (Key: %s, Name: %s): %w", keyForCreate, rec.ProductName, err)
			}

			if master.Origin == "PROVISIONAL" && master.Gs1Code == "" && rec.Gs1Code != "" {
				master.Gs1Code = rec.Gs1Code
				input := mastermanager.MasterToInput(master)
				if _, err := mastermanager.UpsertProductMasterSqlx(tx, input); err != nil {
					return 0, fmt.Errorf("仮マスターへのGS1コード更新に失敗 (JAN: %s): %w", master.ProductCode, err)
				}
			}
		}

		log.Printf("CSV Import: Matched (Key: %s) -> Master (JAN: %s, YJ: %s)", keyForLog, master.ProductCode, master.YjCode)

		janQty := rec.JanQuantity
		yjQty := janQty * master.JanPackInnerQty

		newSeq := lastSeq + 1 + i
		receiptNumber := fmt.Sprintf("%s%05d", prefix, newSeq)

		tr := model.TransactionRecord{
			TransactionDate: date,
			Flag:            0,
			ReceiptNumber:   receiptNumber,
			LineNumber:      "1",
			JanCode:         master.ProductCode,
			YjCode:          master.YjCode,
			JanQuantity:     janQty,
			YjQuantity:      yjQty,
			ExpiryDate:      rec.ExpiryDate,
			LotNumber:       rec.LotNumber,
			UnitPrice:       master.NhiPrice,
			Subtotal:        yjQty * master.NhiPrice,
		}
		mappers.MapMasterToTransaction(&tr, master)
		transactionsToInsert = append(transactionsToInsert, tr)

		packageKey := fmt.Sprintf("%s|%s|%g|%s", master.YjCode, master.PackageForm, master.JanPackInnerQty, master.YjUnitName)
		packageStockTotalsYj[packageKey] += yjQty
		yjCodeMap[master.YjCode] = true
	}

	if len(transactionsToInsert) == 0 {
		return 0, nil
	}

	var yjCodes []string
	for yj := range yjCodeMap {
		yjCodes = append(yjCodes, yj)
	}

	productCodes, err := database.GetProductCodesByYjCodes(tx, yjCodes)
	if err != nil {
		return 0, fmt.Errorf("棚卸削除対象の製品コード取得に失敗: %w", err)
	}

	if len(productCodes) > 0 {
		if err := database.DeleteTransactionsByFlagAndDateAndCodes(tx, 0, date, productCodes); err != nil {
			return 0, fmt.Errorf("既存の棚卸データ(flag=0)の削除に失敗: %w", err)
		}
	}

	for _, tr := range transactionsToInsert {
		if err := database.InsertTransactionRecord(tx, tr); err != nil {
			return 0, fmt.Errorf("新しい棚卸データ(flag=0)の挿入に失敗 (JAN: %s): %w", tr.JanCode, err)
		}
	}

	for key, totalYjQty := range packageStockTotalsYj {
		yjCode := strings.Split(key, "|")[0]
		if err := database.UpsertPackageStockInTx(tx, key, yjCode, totalYjQty, date); err != nil {
			return 0, fmt.Errorf("package_stock の更新に失敗 (Key: %s): %w", key, err)
		}
	}

	return len(transactionsToInsert), nil
}

func quoteAll(s string) string {
	return `"` + strings.ReplaceAll(s, `"`, `""`) + `"`
}

func ExportDeadStockHandler(db *sqlx.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		startDate := r.URL.Query().Get("startDate")
		endDate := r.URL.Query().Get("endDate")
		// ▼▼▼【ここに追加】excludeZeroStock を取得（CSVエクスポートは常に在庫ゼロを含む）▼▼▼
		excludeZeroStock := false //
		// ▲▲▲【追加ここまで】▲▲▲

		if startDate == "" || endDate == "" {
			http.Error(w, "startDate and endDate (YYYYMMDD) are required.", http.StatusBadRequest)
			return
		}

		// ▼▼▼【ここを修正】excludeZeroStock (false) を渡す ▼▼▼
		items, err := database.GetDeadStockList(db, startDate, endDate, excludeZeroStock)
		// ▲▲▲【修正ここまで】▲▲▲
		if err != nil {
			http.Error(w, "Failed to get dead stock list: "+err.Error(), http.StatusInternalServerError)
			return
		}

		var buf bytes.Buffer
		buf.Write([]byte{0xEF, 0xBB, 0xBF})

		header := []string{
			"JANコード",
			"GS1コード",
			"品名",
			"JAN数量",
			"期限",
			"ロット",
		}
		buf.WriteString(strings.Join(header, ",") + "\r\n")

		for _, item := range items {
			if len(item.LotDetails) > 0 {
				for _, lot := range item.LotDetails {
					record := []string{
						quoteAll(lot.JanCode),
						quoteAll(lot.Gs1Code),
						quoteAll(item.ProductName),
						quoteAll(fmt.Sprintf("%.2f", lot.JanQuantity)),
						quoteAll(lot.ExpiryDate),
						quoteAll(lot.LotNumber),
					}
					buf.WriteString(strings.Join(record, ",") +
						"\r\n")
				}
				// ▼▼▼【ここを修正】YJ在庫 -> JAN在庫 で判定 ▼▼▼
			} else if item.StockQuantityJan > 0 {
				// ▲▲▲【修正ここまで】▲▲▲
				record := []string{
					quoteAll(""),
					quoteAll(""),
					quoteAll(item.ProductName),
					// ▼▼▼【ここを修正】0.00 -> item.StockQuantityJan ▼▼▼
					quoteAll(fmt.Sprintf("%.2f", item.StockQuantityJan)),
					// ▲▲▲【修正ここまで】▲▲▲
					quoteAll(""),
					quoteAll(""),
				}
				buf.WriteString(strings.Join(record, ",") + "\r\n")
			}
		}

		filename := fmt.Sprintf("不動在庫リスト_%s-%s.csv", startDate, endDate)

		w.Header().Set("Content-Type", "text/csv;charset=utf-8")
		w.Header().Set("Content-Disposition", "attachment; filename*=UTF-8''"+url.PathEscape(filename))

		w.Write(buf.Bytes())
	}
}


----- C:\Users\wasab\OneDrive\デスクトップ\TKR\inout\handler.go -----
// C:\Users\wasab\OneDrive\デスクトップ\TKR\inout\handler.go
package inout

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"strconv"
	"strings"
	"time"
	"tkr/database"
	"tkr/mappers"
	"tkr/mastermanager"
	"tkr/model"

	"github.com/jmoiron/sqlx"
)

// SaveRecordInput はフロントエンドから受け取る行データです。
type SaveRecordInput struct {
	ProductCode string  `json:"productCode"`
	ProductName string  `json:"productName"` // 仮マスター作成用
	JanQuantity float64 `json:"janQuantity"`
	DatQuantity float64 `json:"datQuantity"` // (TKRでは使わないがWASABI に合わせて残す)
	ExpiryDate  string  `json:"expiryDate"`
	LotNumber   string  `json:"lotNumber"`
}

// SavePayload はフロントエンドから受け取る全データです。
type SavePayload struct {
	IsNewClient           bool              `json:"isNewClient"`
	ClientCode            string            `json:"clientCode"`
	ClientName            string            `json:"clientName"`
	TransactionDate       string            `json:"transactionDate"`
	TransactionTypeFlag   int               `json:"transactionTypeFlag"` // "11" (入庫) or "12" (出庫)
	Records               []SaveRecordInput `json:"records"`
	OriginalReceiptNumber string            `json:"originalReceiptNumber"`
}

// SaveInOutHandler は入出庫伝票の保存を処理します。
func SaveInOutHandler(db *sqlx.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var payload SavePayload
		if err := json.NewDecoder(r.Body).Decode(&payload); err != nil {
			http.Error(w, "Invalid request body", http.StatusBadRequest)
			return
		}

		tx, err := db.Beginx()
		if err != nil {
			http.Error(w, "Failed to start transaction", http.StatusInternalServerError)
			return
		}
		defer tx.Rollback()

		clientCode := payload.ClientCode
		if payload.IsNewClient {
			exists, err := database.CheckClientExistsByName(tx, payload.ClientName)
			if err != nil {
				http.Error(w, "Failed to check client existence", http.StatusInternalServerError)
				return
			}
			if exists {
				http.Error(w, fmt.Sprintf("得意先名 '%s' は既に存在します。", payload.ClientName), http.StatusConflict)
				return
			}
			newCode, err := database.NextSequenceInTx(tx, "CL", "CL", 4)
			if err != nil {
				http.Error(w, "Failed to generate new client code", http.StatusInternalServerError)
				return
			}
			if err := database.CreateClientInTx(tx, newCode, payload.ClientName); err != nil {
				http.Error(w, "Failed to create new client", http.StatusInternalServerError)
				return
			}
			clientCode = newCode
		}

		var receiptNumber string
		dateStr := payload.TransactionDate
		if dateStr == "" {
			dateStr = time.Now().Format("20060102")
		}

		if payload.OriginalReceiptNumber != "" {
			receiptNumber = payload.OriginalReceiptNumber
			// ▼▼▼【修正】関数呼び出しを修正 ▼▼▼
			if err := database.DeleteTransactionsByReceiptNumberInTx(tx, receiptNumber); err != nil {
				// ▲▲▲【修正ここまで】▲▲▲
				http.Error(w, "Failed to delete old items from slip", http.StatusInternalServerError)
				return
			}
		} else {
			var lastSeq int
			prefix := "IO" + dateStr[2:8] // "IO" + YYMMDD
			q := `SELECT receipt_number FROM transaction_records 
				  WHERE receipt_number LIKE ? 
				  ORDER BY receipt_number DESC LIMIT 1`
			var lastReceiptNumber string
			err = tx.Get(&lastReceiptNumber, q, prefix+"%")
			if err != nil && err != sql.ErrNoRows {
				http.Error(w, "Failed to get last receipt number sequence", http.StatusInternalServerError)
				return
			}
			lastSeq = 0
			if lastReceiptNumber != "" && len(lastReceiptNumber) == 13 { // IO + 6 + 5 = 13
				seqStr := lastReceiptNumber[8:]
				lastSeq, _ = strconv.Atoi(seqStr)
			}
			newSeq := lastSeq + 1
			receiptNumber = fmt.Sprintf("%s%05d", prefix, newSeq) // 13桁
		}

		var finalRecords []model.TransactionRecord
		flag := payload.TransactionTypeFlag // 11 or 12

		for i, rec := range payload.Records {
			if rec.ProductCode == "" {
				continue
			}
			master, err := mastermanager.FindOrCreateMaster(tx, rec.ProductCode, rec.ProductName)
			if err != nil {
				http.Error(w, fmt.Sprintf("Failed to resolve master for %s: %v", rec.ProductName, err), http.StatusInternalServerError)
				return
			}

			yjQuantity := rec.JanQuantity * master.JanPackInnerQty
			unitPrice := master.NhiPrice
			subtotal := yjQuantity * unitPrice

			tr := model.TransactionRecord{
				TransactionDate: dateStr,
				ClientCode:      clientCode,
				ReceiptNumber:   receiptNumber,
				LineNumber:      fmt.Sprintf("%d", i+1),
				Flag:            flag,
				JanCode:         master.ProductCode,
				JanQuantity:     rec.JanQuantity,
				YjQuantity:      yjQuantity,
				UnitPrice:       unitPrice,
				Subtotal:        subtotal,
				ExpiryDate:      rec.ExpiryDate,
				LotNumber:       rec.LotNumber,
			}

			mappers.MapMasterToTransaction(&tr, master)
			finalRecords = append(finalRecords, tr)
		}

		        if len(finalRecords) > 0 {
		            // ▼▼▼【修正】関数名を PersistTransactionRecordsInTx に変更 ▼▼▼
		            if err := database.PersistTransactionRecordsInTx(tx, finalRecords); err != nil {
		                // ▲▲▲【修正ここまで】▲▲▲
		                log.Printf("Failed to persist records: %v", err)
		                http.Error(w, "Failed to save records to database.", http.StatusInternalServerError)
		                return
		            }
		        }
		
		        		if err := tx.Commit(); err != nil {			http.Error(w, "Failed to commit transaction", http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		response := map[string]interface{}{
			"message":       "保存しました",
			"receiptNumber": receiptNumber,
		}
		if payload.IsNewClient {
			response["newClient"] = map[string]string{
				"code": clientCode,
				"name": payload.ClientName,
			}
		}
		json.NewEncoder(w).Encode(response)
	}
}

// GetTransactionsByReceiptNumberHandler は伝票番号で明細を取得します
func GetTransactionsByReceiptNumberHandler(db *sqlx.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		receiptNumber := strings.TrimPrefix(r.URL.Path, "/api/transaction/")
		if receiptNumber == "" {
			http.Error(w, "Receipt number is required", http.StatusBadRequest)
			return
		}
		// ▼▼▼【修正】関数呼び出しを修正 ▼▼▼
		records, err := database.GetTransactionsByReceiptNumber(db, receiptNumber)
		// ▲▲▲【修正ここまで】▲▲▲
		if err != nil {
			http.Error(w, "Failed to get transaction details", http.StatusInternalServerError)
			return
		}
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(records)
	}
}

// GetReceiptNumbersByDateHandler は日付で伝票番号リストを取得します
func GetReceiptNumbersByDateHandler(db *sqlx.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		date := r.URL.Query().Get("date")
		if date == "" {
			http.Error(w, "Date parameter is required", http.StatusBadRequest)
			return
		}
    if len(date) != 8 {
        http.Error(w, "Date must be in YYYYMMDD format", http.StatusBadRequest)
        return
    }
    clientCode := r.URL.Query().Get("client")
    prefix := "IO" + date[2:] // "IO" + YYMMDD
	receipts, err := database.GetReceiptNumbersByDate(db, date, prefix, clientCode)
		if err != nil {
			http.Error(w, "Failed to get receipt numbers", http.StatusInternalServerError)
			return
		}
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(receipts)
	}
}

// DeleteTransactionHandler は伝票番号で伝票を削除します
func DeleteTransactionHandler(db *sqlx.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		receiptNumber := strings.TrimPrefix(r.URL.Path, "/api/transaction/delete/")
		if receiptNumber == "" {
			http.Error(w, "Receipt number is required", http.StatusBadRequest)
			return
		}
		tx, err := db.Beginx()
		if err != nil {
			http.Error(w, "Failed to start transaction", http.StatusInternalServerError)
			return
		}
		defer tx.Rollback()

		// ▼▼▼【修正】関数呼び出しを修正 ▼▼▼
		if err := database.DeleteTransactionsByReceiptNumberInTx(tx, receiptNumber); err != nil {
			// ▲▲▲【修正ここまで】▲▲▲
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}

		if err := tx.Commit(); err != nil {
			http.Error(w, "Failed to commit transaction", http.StatusInternalServerError)
			return
		}
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]string{"message": "削除しました"})
	}
}


----- C:\Users\wasab\OneDrive\デスクトップ\TKR\inventoryadjustment\handler.go -----
// C:\Users\wasab\OneDrive\デスクトップ\TKR\inventoryadjustment\handler.go
package inventoryadjustment

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"time"
	"tkr/aggregation"
	"tkr/config"
	"tkr/database"
	"tkr/mappers"
	"tkr/model"

	"github.com/jmoiron/sqlx"
)

func GetInventoryDataHandler(conn *sqlx.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		q := r.URL.Query()
		yjCode := q.Get("yjCode")
		if yjCode == "" {
			http.Error(w, "yjCode is a required parameter", http.StatusBadRequest)
			return
		}

		cfg, err := config.LoadConfig()
		if err != nil {
			http.Error(w, "設定ファイルの読み込みに失敗: "+err.Error(), http.StatusInternalServerError)
			return
		}
		now := time.Now()
		endDate := "99991231"
		startDate := now.AddDate(0, 0, -cfg.CalculationPeriodDays)
		yesterdayDate := now.AddDate(0, 0, -1)

		filtersToday := model.AggregationFilters{
			StartDate: startDate.Format("20060102"),
			EndDate:   endDate,
			YjCode:    yjCode,
		}
		ledgerToday, err := aggregation.GetStockLedger(conn, filtersToday)
		if err !=
			nil {
			http.Error(w, "Failed to get today's stock ledger: "+err.Error(), http.StatusInternalServerError)
			return
		}

		filtersYesterday := model.AggregationFilters{
			StartDate: startDate.Format("20060102"),
			EndDate:   yesterdayDate.Format("20060102"),
			YjCode:    yjCode,
		}
		ledgerYesterday, err := aggregation.GetStockLedger(conn, filtersYesterday)
		if err != nil {
			http.Error(w, "Failed to get yesterday's stock ledger: "+err.Error(), http.StatusInternalServerError)
			return
		}

		transactionLedgerView := mappers.ConvertToView(ledgerToday)
		var yesterdaysStockView *mappers.StockLedgerYJGroupView
		if len(ledgerYesterday) > 0 {
			view := mappers.ConvertToView(ledgerYesterday)
			if len(view) > 0 {
				yesterdaysStockView = &view[0]
			}
		}

		var productCodes []string
		if len(ledgerToday) > 0 {
			for _, pkg := range ledgerToday[0].PackageLedgers {
				for _, master := range pkg.Masters {
					productCodes = append(productCodes, master.ProductCode)
				}
			}
		}

		precompDetails, err := database.GetPreCompoundingDetailsByProductCodes(conn, productCodes)
		if err != nil {
			log.Printf("WARN: Failed to get pre-compounding details: %v",
				err)
		}

		tx, err := conn.Beginx()
		if err != nil {
			http.Error(w, "Failed to start transaction for latest inventory details", http.StatusInternalServerError)
			return
		}
		defer tx.Rollback()

		latestInventoryTxs, err := database.GetLatestInventoryDetailsByYjCode(tx, yjCode)
		if err != nil {
			log.Printf("WARN: Failed to get latest inventory details (flag=0 txs) for adjustment: %v", err)
		}

		deadStockDetails := make([]model.DeadStockRecord, len(latestInventoryTxs))
		for i, tx := range latestInventoryTxs {
			deadStockDetails[i] = model.DeadStockRecord{
				ProductCode:      tx.JanCode,
				YjCode:           tx.YjCode,
				PackageForm:      tx.PackageForm,
				JanPackInnerQty:  tx.JanPackInnerQty,
				YjUnitName:       tx.YjUnitName,
				StockQuantityJan: tx.JanQuantity,
				ExpiryDate:       tx.ExpiryDate,
				LotNumber:        tx.LotNumber,
			}
		}

		response := mappers.ResponseDataView{
			TransactionLedger: transactionLedgerView,
			YesterdaysStock:   yesterdaysStockView,
			DeadStockDetails:  deadStockDetails,
			PrecompDetails:    precompDetails,
		}
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(response)
	}
}

type SavePayload struct {
	Date          string                  `json:"date"`
	YjCode        string                  `json:"yjCode"`
	InventoryData map[string]float64      `json:"inventoryData"`
	DeadStockData []model.DeadStockRecord `json:"deadStockData"`
}

func SaveInventoryDataHandler(conn *sqlx.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var payload SavePayload
		if err := json.NewDecoder(r.Body).Decode(&payload); err != nil {
			log.Printf("[SaveInventoryDataHandler] ERROR: Invalid request body: %v", err)
			http.Error(w, "Invalid request body: "+err.Error(), http.StatusBadRequest)
			return
		}

		log.Printf("[SaveInventoryDataHandler] Received payload for YJ: %s, Date: %s. DeadStock items: %d", payload.YjCode, payload.Date, len(payload.DeadStockData))

		tx, err := conn.Beginx()
		if err != nil {
			log.Printf("[SaveInventoryDataHandler] ERROR: Failed to start transaction: %v", err)
			http.Error(w, "Failed to start transaction", http.StatusInternalServerError)
			return
		}
		defer tx.Rollback()

		masters, err := database.GetProductMastersByYjCode(tx, payload.YjCode)
		if err != nil {
			log.Printf("[SaveInventoryDataHandler] ERROR: Failed to get product masters for yj %s: %v", payload.YjCode, err)
			http.Error(w, "Failed to get product masters for yj: "+err.Error(), http.StatusInternalServerError)
			return
		}

		log.Printf("[SaveInventoryDataHandler] Calling SaveGuidedInventoryData with Date: %s, YjCode: %s, Masters found: %d, DeadStock items: %d",
			payload.Date,
			payload.YjCode, len(masters), len(payload.DeadStockData))

		if err := database.SaveGuidedInventoryData(tx, payload.Date, payload.YjCode, masters, payload.InventoryData, payload.DeadStockData); err != nil {
			log.Printf("[SaveInventoryDataHandler] ERROR: Failed to save inventory data in SaveGuidedInventoryData: %v", err)
			http.Error(w, "Failed to save inventory data: "+err.Error(), http.StatusInternalServerError)
			return
		}

		if err := tx.Commit(); err != nil {
			log.Printf("[SaveInventoryDataHandler] ERROR: Failed to commit transaction: %v", err)
			http.Error(w, "Failed to commit transaction", http.StatusInternalServerError)
			return
		}

		log.Printf("[SaveInventoryDataHandler] Successfully saved inventory data for YJ: %s, Date: %s", payload.YjCode, payload.Date)

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]string{"message": "棚卸データを保存しました。"})
	}
}

// ▼▼▼【ここから修正】戻り値とメッセージを変更 ▼▼▼
func ClearOldInventoryHandler(conn *sqlx.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		if r.Method != http.MethodPost {
			http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
			return
		}

		tx, err := conn.Beginx()
		if err != nil {
			http.Error(w, "Failed to start transaction", http.StatusInternalServerError)
			return
		}
		defer tx.Rollback()

		rowsAffected, err := database.DeleteOldInventoryTransactions(tx)
		if err != nil {
			http.Error(w, "Failed to delete old inventory records: "+err.Error(), http.StatusInternalServerError)
			return
		}

		if err := tx.Commit(); err != nil {
			http.Error(w, "Failed to commit transaction", http.StatusInternalServerError)
			return
		}

		var message string
		if rowsAffected == 0 {
			message = "削除対象の古い棚卸履歴はありませんでした。"
		} else {
			message = fmt.Sprintf("最新ではない古い棚卸履歴(flag=0) %d 件を削除しました。", rowsAffected)
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]string{"message": message})
	}
}

// ▲▲▲【修正ここまで】▲▲▲


----- C:\Users\wasab\OneDrive\デスクトップ\TKR\loader\handler.go -----
// C:\Users\wasab\OneDrive\デスクトップ\TKR\loader\handler.go
package loader

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"os"
	"tkr/database"

	"github.com/jmoiron/sqlx"
)

// ReloadJCSHMSHandler は JCSHMS.CSV と JANCODE.CSV の再読み込みをトリガーします。
func ReloadJCSHMSHandler(db *sqlx.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		log.Println("HTTP request received: Reloading JCSHMS and JANCODE...")

		jcshmsPath := "SOU/JCSHMS.CSV"
		jancodePath := "SOU/JANCODE.CSV"

		// JCSHMS.CSV のロード
		if _, err := os.Stat(jcshmsPath); os.IsNotExist(err) {
			log.Printf("WARN: %s not found, skipping.", jcshmsPath)
		} else {
			log.Printf("Reloading %s...", jcshmsPath)
			if err := LoadCSV(db, jcshmsPath, "jcshms", 125, false); err != nil {
				msg := fmt.Sprintf("failed to reload %s: %v", jcshmsPath, err)
				log.Println(msg)
				http.Error(w, msg, http.StatusInternalServerError)
				return
			}
			log.Printf("Reloaded %s successfully.", jcshmsPath)
		}

		// JANCODE.CSV のロード
		if _, err := os.Stat(jancodePath); os.IsNotExist(err) {
			log.Printf("WARN: %s not found, skipping.", jancodePath)
		} else {
			log.Printf("Reloading %s...", jancodePath)
			if err := LoadCSV(db, jancodePath, "jancode", 30, true); err != nil {
				msg := fmt.Sprintf("failed to reload %s: %v", jancodePath, err)
				log.Println(msg)
				http.Error(w, msg, http.StatusInternalServerError)
				return
			}
			log.Printf("Reloaded %s successfully.", jancodePath)
		}

		// シーケンスの再初期化
		tx, err := db.Beginx()
		if err != nil {
			msg := fmt.Sprintf("failed to begin transaction for sequence initialization: %v", err)
			log.Println(msg)
			http.Error(w, msg, http.StatusInternalServerError)
			return
		}
		defer tx.Rollback() // エラー時

		if err := database.InitializeSequenceFromMaxYjCode(tx); err != nil {
			log.Printf("WARN: Failed to re-initialize MA2Y sequence: %v", err)
			// エラーでも続行
		}
		if err := database.InitializeSequenceFromMaxProductCode(tx); err != nil {
			log.Printf("WARN: Failed to re-initialize MA2J sequence: %v", err)
			// エラーでも続行
		}

		if err := tx.Commit(); err != nil {
			msg := fmt.Sprintf("failed to commit sequence initialization: %v", err)
			log.Println(msg)
			http.Error(w, msg, http.StatusInternalServerError)
			return
		}
		log.Println("Code sequences re-initialized.")

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]string{
			"message": "JCSHMS (SOU) マスターの更新が完了しました。",
		})
	}
}


----- C:\Users\wasab\OneDrive\デスクトップ\TKR\loader\loader.go -----
package loader

import (
	"encoding/csv"
	"fmt"
	"io"
	"log"
	"os"
	"strconv"
	"strings"
	"tkr/database"

	"github.com/jmoiron/sqlx" // sqlx をインポート
	"golang.org/x/text/encoding/japanese"
	"golang.org/x/text/transform"
)

// 各テーブルのカラムのデータ型情報 (CSVからの変換用)
// キーは CSV の列インデックス (0始まり)
var tableSchemas = map[string]map[int]string{
	"jcshms": { // JCSHMS.CSV
		44:  "real",    // JC044 (列インデックス 44)
		49:  "real",    // JC049
		50:  "real",    // JC050
		61:  "integer", // JC061
		62:  "integer", // JC062
		63:  "integer", // JC063
		64:  "integer", // JC064
		65:  "integer", // JC065
		66:  "integer", // JC066
		124: "real",    // JC124
	},
	"jancode": { // JANCODE.CSV
		6: "real", // JA006 (列インデックス 6)
		8: "real", // JA008
	},
}

// InitDatabase はデータベーススキーマを適用し、マスターCSVをロードします。
func InitDatabase(db *sqlx.DB) error {
	log.Println("Applying database schema...")
	if err := applySchema(db); err != nil {
		return fmt.Errorf("failed to apply schema.sql: %w", err)
	}
	log.Println("Schema applied successfully.")

	// CSVファイルのパス (SOUフォルダは TKR フォルダ直下に配置する想定)
	jcshmsPath := "SOU/JCSHMS.CSV"
	jancodePath := "SOU/JANCODE.CSV"
	taniPath := "SOU/TANI.CSV" // TANI.CSV も追加

	// ファイル存在チェック (任意ですが、エラーメッセージが分かりやすくなります)
	if _, err := os.Stat(jcshmsPath); os.IsNotExist(err) {
		log.Printf("WARN: %s not found, skipping.", jcshmsPath)
	} else {
		log.Printf("Loading %s...", jcshmsPath)
		// JCSHMS は 125 列, ヘッダーなし
		if err := LoadCSV(db, jcshmsPath, "jcshms", 125, false); err != nil {
			return fmt.Errorf("failed to load %s: %w", jcshmsPath, err)
		}
		log.Printf("Loaded %s successfully.", jcshmsPath)
	}

	if _, err := os.Stat(jancodePath); os.IsNotExist(err) {
		log.Printf("WARN: %s not found, skipping.", jancodePath)
	} else {
		log.Printf("Loading %s...", jancodePath)
		// JANCODE は 30 列, ヘッダーあり(スキップ)
		if err := LoadCSV(db, jancodePath, "jancode", 30, true); err != nil {
			return fmt.Errorf("failed to load %s: %w", jancodePath, err)
		}
		log.Printf("Loaded %s successfully.", jancodePath)
	}

	// TANI.CSV のロード処理も追加（必要に応じて）
	if _, err := os.Stat(taniPath); os.IsNotExist(err) {
		log.Printf("WARN: %s not found, skipping TANI units loading.", taniPath)
	} else {
		// TANI.CSV は units パッケージ側でロードするかもしれません。
		// ここでロードする場合は、適切なテーブル定義と LoadCSV 呼び出しを追加します。
		log.Printf("Note: TANI.CSV exists but loading logic is not implemented here yet.")
	}

	// ▼▼▼【ここから追加】シーケンスの初期化 ▼▼▼
	// (LoadCSVの後、DB接続が確立しているこのタイミングでシーケンスを初期化)
	tx, err := db.Beginx()
	if err != nil {
		return fmt.Errorf("failed to begin transaction for sequence initialization: %w", err)
	}
	defer tx.Rollback() // エラー時

	if err := database.InitializeSequenceFromMaxYjCode(tx); err != nil {
		log.Printf("WARN: Failed to initialize MA2Y sequence: %v", err)
		// エラーでも続行
	}
	if err := database.InitializeSequenceFromMaxProductCode(tx); err != nil {
		log.Printf("WARN: Failed to initialize MA2J sequence: %v", err)
		// エラーでも続行
	}

	if err := tx.Commit(); err != nil {
		return fmt.Errorf("failed to commit sequence initialization: %w", err)
	}
	log.Println("Code sequences initialized.")
	// ▲▲▲【追加ここまで】▲▲▲

	return nil
}

// applySchema は schema.sql ファイルを読み込んで実行します。
func applySchema(db *sqlx.DB) error {
	schemaBytes, err := os.ReadFile("schema.sql")
	if err != nil {
		return fmt.Errorf("could not read schema.sql: %w", err)
	}
	// sqlx.DB でも Exec をそのまま使えます
	_, err = db.Exec(string(schemaBytes))
	if err != nil {
		return fmt.Errorf("failed to execute schema: %w", err)
	}
	return nil
}

// LoadCSV は指定されたCSVファイルを読み込み、指定テーブルにデータを挿入（または置換）します。
// ▼▼▼【ここを修正】 名前付き返り値 `(err error)` を使用 ▼▼▼
func LoadCSV(db *sqlx.DB, filepath, tablename string, expectedColumns int, skipHeader bool) (err error) {
	f, err := os.Open(filepath)
	if err != nil {
		return fmt.Errorf("could not open file %s: %w", filepath, err)
	}
	defer f.Close()

	// Shift-JISデコーダーを設定
	r := csv.NewReader(transform.NewReader(f, japanese.ShiftJIS.NewDecoder()))
	r.LazyQuotes = true    // ダブルクォートが不完全でも許容
	r.FieldsPerRecord = -1 // 可変長カラムを許容 (後でチェック)

	// ヘッダー行をスキップする場合
	if skipHeader {
		if _, err := r.Read(); err != nil && err != io.EOF {
			return fmt.Errorf("failed to skip header in %s: %w", filepath, err)
		}
	}

	// sqlx.Tx を使ってトランザクションを開始
	tx, err := db.Beginx()
	if err != nil {
		return fmt.Errorf("failed to begin transaction: %w", err)
	}

	// ▼▼▼【ここを修正】 defer ロジックを linter に優しい形に変更 ▼▼▼
	defer func() {
		if p := recover(); p != nil {
			// パニックが発生した場合
			tx.Rollback()
			panic(p) // パニックを再スロー
		} else if err != nil {
			// 関数がエラーを返そうとしている場合 (err が nil でない)
			log.Printf("Rolling back transaction for %s due to error: %v", tablename, err)
			tx.Rollback() // ロールバック
		} else {
			// 関数がエラーなしで終了しようとしている場合 (err が nil)
			err = tx.Commit() // コミットし、結果を名前付き返り値 err に代入
			if err != nil {
				log.Printf("Error committing transaction for %s: %v", tablename, err)
			}
		}
	}()
	// ▲▲▲【修正ここまで】▲▲▲

	// INSERT OR REPLACE 文を準備
	placeholders := strings.Repeat("?,", expectedColumns-1) + "?"
	query := fmt.Sprintf("INSERT OR REPLACE INTO %s VALUES (%s)", tablename, placeholders)
	// sqlx.Tx でも Prepare をそのまま使えます
	stmt, err := tx.Prepare(query)
	if err != nil {
		return fmt.Errorf("failed to prepare statement for %s: %w", tablename, err) // err を返す
	}
	defer stmt.Close()

	// テーブルスキーマ情報を取得 (型変換用)
	schema := tableSchemas[tablename]
	rowCount := 0

	for {
		row, readErr := r.Read()
		if readErr == io.EOF {
			break
		}
		if readErr != nil {
			log.Printf("WARN: Error reading row in %s (skipping): %v", filepath, readErr)
			continue // エラー行はスキップして処理を続行
		}

		// カラム数が期待値と異なる場合はスキップ
		if len(row) < expectedColumns {
			// log.Printf("WARN: Skipping row in %s due to insufficient columns (expected %d, got %d): %v", filepath, expectedColumns, len(row), row)
			continue
		}
		// カラム数が多すぎる場合は、期待される数に切り詰める
		if len(row) > expectedColumns {
			row = row[:expectedColumns]
		}

		// SQLステートメントに渡す引数スライスを作成
		args := make([]interface{}, expectedColumns)
		for i := 0; i < expectedColumns; i++ {
			val := strings.TrimSpace(row[i]) // 前後の空白を除去

			// スキーマ情報に基づいて型変換を試みる
			if colType, ok := schema[i]; ok {
				switch colType {
				case "real":
					num, parseErr := strconv.ParseFloat(val, 64)
					if parseErr != nil {
						args[i] = 0.0 // パース失敗時は 0.0
					} else {
						args[i] = num
					}
				case "integer":
					num, parseErr := strconv.ParseInt(val, 10, 64)
					if parseErr != nil {
						args[i] = 0 // パース失敗時は 0
					} else {
						args[i] = num
					}
				default: // "text" or unknown type
					args[i] = val
				}
			} else {
				// スキーマ情報がない場合は文字列として扱う
				args[i] = val
			}
		}

		// 準備されたステートメントを実行
		if _, execErr := stmt.Exec(args...); execErr != nil {
			log.Printf("WARN: Failed to insert row into %s (skipping): %v | Data: %v", tablename, execErr, args)
			err = fmt.Errorf("failed to execute statement for %s: %w", tablename, execErr) // err に代入
			return err                                                                     // エラーを返す (defer が Rollback を実行する)
		}
		rowCount++
	}

	log.Printf("Inserted or replaced %d rows into %s", rowCount, tablename)

	// 成功時は err = nil のまま defer が実行され、Commit される
	return nil
}


----- C:\Users\wasab\OneDrive\デスクトップ\TKR\mappers\mappers.go -----
// C:\Users\wasab\OneDrive\デスクトップ\TKR\mappers\mappers.go
package mappers

import (
	"fmt"
	"tkr/model"
	"tkr/units"
)

/**
 * MapMasterToTransaction は、ProductMaster の情報を TransactionRecord にマッピングします。
 *
 * 呼び出し元（dat, usage, inventory）は、事前に tr のユニークな値
 * (Date, Flag, YjQuantity, JanQuantity, UnitPrice, Subtotal など) を
 * 設定しておく必要があります。
 *
 * この関数は、マスター由来の共通情報（製品名、包装仕様、MAフラグなど）を設定します。
 */
func MapMasterToTransaction(tr *model.TransactionRecord, master *model.ProductMaster) {
	// 1. 製品名と規格を連結
	productNameWithSpec := master.ProductName
	if master.Specification != "" {
		productNameWithSpec = master.ProductName + " " + master.Specification
	}
	tr.ProductName = productNameWithSpec

	// 2. 包装仕様
	yjUnitName := units.ResolveName(master.YjUnitName)
	packageSpec := fmt.Sprintf("%s %g%s", master.PackageForm, master.YjPackUnitQty, yjUnitName)
	janUnitCodeStr := fmt.Sprintf("%d", master.JanUnitCode)
	var janUnitName string
	if master.JanUnitCode == 0 {
		janUnitName = yjUnitName
	} else {
		janUnitName = units.ResolveName(janUnitCodeStr)
	}
	if master.JanPackInnerQty > 0 && master.JanPackUnitQty > 0 {
		packageSpec += fmt.Sprintf(" (%g%s×%g%s)",
			master.JanPackInnerQty, yjUnitName, master.JanPackUnitQty, janUnitName)
	}
	tr.PackageSpec = packageSpec

	// 3. MAフラグ (共通ロジック)
	if master.Origin == "JCSHMS" {
		tr.ProcessFlagMA = "COM"
	} else {
		tr.ProcessFlagMA = "PRO"
	}

	// 4. その他のマスター由来フィールド
	tr.JanCode = master.ProductCode
	tr.YjCode = master.YjCode
	tr.KanaName = master.KanaName
	tr.UsageClassification = master.UsageClassification
	tr.PackageForm = master.PackageForm
	tr.MakerName = master.MakerName
	tr.JanPackInnerQty = master.JanPackInnerQty
	tr.JanPackUnitQty = master.JanPackUnitQty
	tr.JanUnitName = janUnitName
	tr.JanUnitCode = janUnitCodeStr
	tr.YjPackUnitQty = master.YjPackUnitQty
	tr.YjUnitName = yjUnitName

	// 5. 参考価格と卸 (UnitPrice と Subtotal は呼び出し元で設定)
	tr.PurchasePrice = master.PurchasePrice
	tr.SupplierWholesale = master.SupplierWholesale

	// 6. 医薬品フラグ
	tr.FlagPoison = master.FlagPoison
	tr.FlagDeleterious = master.FlagDeleterious
	tr.FlagNarcotic = master.FlagNarcotic
	tr.FlagPsychotropic = master.FlagPsychotropic
	tr.FlagStimulant = master.FlagStimulant
	tr.FlagStimulantRaw = master.FlagStimulantRaw
}


----- C:\Users\wasab\OneDrive\デスクトップ\TKR\mappers\view.go -----
// C:\Users\wasab\OneDrive\デスクトップ\TKR\mappers\view.go
package mappers

import (
	"database/sql"
	"fmt"
	"tkr/model"
	"tkr/units"
)

// ToProductMasterView は、*model.ProductMaster を画面表示用の model.ProductMasterView に変換します。
// (WASABI: mappers/view.go  より移植)
func ToProductMasterView(master *model.ProductMaster) model.ProductMasterView {
	if master == nil {
		return model.ProductMasterView{}
	}

	// TKRの JcshmsInfo 構造体（units.FormatPackageSpec が要求する型）に合わせる
	tempJcshmsInfo := model.JcshmsInfo{
		PackageForm:     master.PackageForm,
		YjUnitName:      master.YjUnitName,
		YjPackUnitQty:   master.YjPackUnitQty,
		JanPackInnerQty: sql.NullFloat64{Float64: master.JanPackInnerQty, Valid: true},
		JanPackUnitQty:  sql.NullFloat64{Float64: master.JanPackUnitQty, Valid: true},
		JanUnitCode:     sql.NullString{String: fmt.Sprintf("%d", master.JanUnitCode), Valid: true},
	}

	// JAN単位名を解決する
	var janUnitName string
	if master.JanUnitCode == 0 {
		janUnitName = master.YjUnitName
	} else {
		janUnitName = units.ResolveName(fmt.Sprintf("%d", master.JanUnitCode))
	}

	return model.ProductMasterView{
		ProductMaster:        *master,
		FormattedPackageSpec: units.FormatPackageSpec(&tempJcshmsInfo),
		JanUnitName:          janUnitName,
	}
}

// StockLedgerYJGroupView は StockLedgerYJGroup の画面表示用です。
// (WASABI: guidedinventory/handler.go  より)
type StockLedgerYJGroupView struct {
	model.StockLedgerYJGroup
	PackageLedgers []StockLedgerPackageGroupView `json:"packageLedgers"`
}

// StockLedgerPackageGroupView は StockLedgerPackageGroup の画面表示用です。
// (WASABI: guidedinventory/handler.go  より)
type StockLedgerPackageGroupView struct {
	model.StockLedgerPackageGroup
	Masters []model.ProductMasterView `json:"masters"`
}

// ResponseDataView は棚卸調整画面の全データを保持するコンテナです。
// (WASABI: guidedinventory/handler.go  より)
type ResponseDataView struct {
	TransactionLedger []StockLedgerYJGroupView `json:"transactionLedger"`
	YesterdaysStock   *StockLedgerYJGroupView  `json:"yesterdaysStock"`
	DeadStockDetails  []model.DeadStockRecord  `json:"deadStockDetails"`

	// ▼▼▼【ここに追加】(WASABI: guidedinventory/handler.go [cite: 542] より) ▼▼▼
	PrecompDetails []model.TransactionRecord `json:"precompDetails"`
	// ▲▲▲【追加ここまで】▲▲▲

}

// ConvertToView はDBモデルを集計・表示用モデルに変換します。
// (WASABI: guidedinventory/handler.go  より移植)
func ConvertToView(yjGroups []model.StockLedgerYJGroup) []StockLedgerYJGroupView {
	if yjGroups == nil {
		return nil
	}

	viewGroups := make([]StockLedgerYJGroupView, 0, len(yjGroups))

	for _, group := range yjGroups {
		newYjGroup := StockLedgerYJGroupView{
			StockLedgerYJGroup: group,
			PackageLedgers:     make([]StockLedgerPackageGroupView, 0, len(group.PackageLedgers)),
		}

		for _, pkg := range group.PackageLedgers {
			newPkgGroup := StockLedgerPackageGroupView{
				StockLedgerPackageGroup: pkg,
				Masters:                 make([]model.ProductMasterView, 0, len(pkg.Masters)),
			}

			for _, master := range pkg.Masters {
				newMasterView := ToProductMasterView(master)
				newPkgGroup.Masters = append(newPkgGroup.Masters, newMasterView)
			}
			newYjGroup.PackageLedgers = append(newYjGroup.PackageLedgers, newPkgGroup)
		}
		viewGroups = append(viewGroups, newYjGroup)
	}
	return viewGroups
}


----- C:\Users\wasab\OneDrive\デスクトップ\TKR\masteredit\handler.go -----
// C:\Users\wasab\OneDrive\デスクトップ\TKR\masteredit\handler.go
package masteredit

import (
	"database/sql"
	"encoding/json"
	"errors"
	"fmt"
	"log"
	"net/http"
	"strings"
	"tkr/database"
	"tkr/mastermanager"
	"tkr/model"
	"tkr/units"

	"github.com/jmoiron/sqlx"
)

func ListMastersHandler(db *sqlx.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {

		queryParams := r.URL.Query()
		usageClass := queryParams.Get("usage_class")
		kanaName := queryParams.Get("kana_name")
		genericName := queryParams.Get("generic_name")
		shelfNumber := queryParams.Get("shelf_number")

		if usageClass == "" {
			log.Println("ListMastersHandler: usage_class is required, returning empty.")
			w.Header().Set("Content-Type", "application/json")
			json.NewEncoder(w).Encode(map[string]interface{}{
				"tableHTML": renderMasterListHTML(nil, "内外注区分を選択してください。"),
				"masters":   []model.ProductMaster{},
			})
			return
		}

		masters, err := database.GetFilteredProductMasters(db,
			usageClass, kanaName, genericName, shelfNumber, "", nil)

		if err != nil {
			log.Printf("Error fetching filtered product masters: %v", err)
			w.Header().Set("Content-Type", "application/json")
			w.WriteHeader(http.StatusInternalServerError)
			json.NewEncoder(w).Encode(map[string]interface{}{
				"tableHTML": renderMasterListHTML(nil, "マスターの検索中にエラーが発生しました。"),
				"masters":   []model.ProductMaster{},
			})
			return
		}

		tableHTML := renderMasterListHTML(masters, "")

		w.Header().Set("Content-Type", "application/json")
		if err := json.NewEncoder(w).Encode(map[string]interface{}{
			"tableHTML": tableHTML,
			"masters":   masters,
		}); err != nil {
			log.Printf("Error encoding product masters to JSON: %v", err)
			http.Error(w, "Failed to encode response", http.StatusInternalServerError)
		}
	}
}

func renderMasterListHTML(masters []model.ProductMaster, statusMessage string) string {
	var sb strings.Builder

	sb.WriteString(`
    <thead>
        <tr>
            <th class="col-action"></th>
            <th class="col-yj">YJコード</th>
            <th class="col-gs1">GS1コード</th>
            <th class="col-jan">JANコード</th>
            <th class="col-product">製品名</th>
            <th class="col-kana">カナ名</th>
            <th class="col-maker">メーカー</th>
            <th class="col-generic">一般名</th>
            <th class="col-shelf">棚番</th>
        </tr>
    </thead>`)

	sb.WriteString(`<tbody>`)
	if statusMessage != "" {
		sb.WriteString(fmt.Sprintf(`<tr><td colspan="9">%s</td></tr>`, statusMessage))
	} else if len(masters) == 0 {
		sb.WriteString(`<tr><td colspan="9">データがありません。</td></tr>`)
	} else {
		for _, master := range masters {
			sb.WriteString(fmt.Sprintf(`<tr data-product-code="%s">`,
				master.ProductCode))
			sb.WriteString(fmt.Sprintf(`<td class="center col-action"><button class="edit-master-btn btn" data-code="%s">編集</button></td>`, master.ProductCode))
			sb.WriteString(fmt.Sprintf(`<td class="col-yj">%s</td>`, master.YjCode))
			sb.WriteString(fmt.Sprintf(`<td class="col-gs1">%s</td>`,
				master.Gs1Code))
			sb.WriteString(fmt.Sprintf(`<td class="col-jan">%s</td>`, master.ProductCode))
			sb.WriteString(fmt.Sprintf(`<td class="left col-product">%s</td>`, master.ProductName))
			sb.WriteString(fmt.Sprintf(`<td class="left col-kana">%s</td>`, master.KanaName))
			sb.WriteString(fmt.Sprintf(`<td class="left col-maker">%s</td>`, master.MakerName))
			sb.WriteString(fmt.Sprintf(`<td class="left col-generic">%s</td>`, master.GenericName))
			sb.WriteString(fmt.Sprintf(`<td class="col-shelf">%s</td>`, master.ShelfNumber))
			sb.WriteString(`</tr>`)
		}
	}
	sb.WriteString(`</tbody>`)

	return sb.String()
}

func UpdateMasterHandler(db *sqlx.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		if r.Method != http.MethodPost {
			http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
			return
		}

		var input model.ProductMasterInput
		if err := json.NewDecoder(r.Body).Decode(&input); err != nil {
			log.Printf("UpdateMasterHandler: Invalid request body: %v", err)
			http.Error(w, "Invalid request body", http.StatusBadRequest)
			return
		}

		tx, err := db.Beginx()
		if err != nil {
			log.Printf("UpdateMasterHandler: Failed to start transaction: %v", err)
			http.Error(w, "Failed to start transaction", http.StatusInternalServerError)
			return
		}
		defer tx.Rollback()

		alertMessage := ""
		isNew := false

		// 1. 既存マスタ情報を取得
		oldMaster, err := database.GetProductMasterByCode(tx, input.ProductCode)

		if err != nil {
			if errors.Is(err, sql.ErrNoRows) {
				// -------------------------------------------------
				// B. 新規作成の場合
				// -------------------------------------------------
				isNew = true
				log.Printf("UpdateMasterHandler: No existing master found for ProductCode [%s]. Treating as NEW.", input.ProductCode)

				// B-1. ProductCode (JAN) の採番
				if input.ProductCode == "" {
					newCode, seqErr := database.NextSequenceInTx(tx, "MA2J", "MA2J", 9)
					if seqErr != nil {
						http.Error(w, "JANコード(MA2J)の自動採番に失敗しました: "+seqErr.Error(), http.StatusInternalServerError)
						return
					}
					input.ProductCode = newCode
					log.Printf("UpdateMasterHandler: Assigned new ProductCode (MA2J): %s", newCode)
				}

				// B-2. YjCode の採番
				if input.YjCode == "" {
					newYj, seqErr := database.NextSequenceInTx(tx, "MA2Y", "MA2Y", 8)
					if seqErr != nil {
						http.Error(w, "YJコード(MA2Y)の自動採番に失敗しました: "+seqErr.Error(), http.StatusInternalServerError)
						return
					}
					input.YjCode = newYj
					log.Printf("UpdateMasterHandler: Assigned new YjCode (MA2Y): %s", newYj)
				}

				// B-3. Origin の設定
				if input.Origin != "JCSHMS" {
					input.Origin = "PROVISIONAL"
				}

				// B-4. 剤型のフォールバック
				if input.UsageClassification == "" {
					input.UsageClassification = "他"
				}

			} else {
				// -------------------------------------------------
				// C. 既存マスタ取得時のDBエラー
				// -------------------------------------------------
				log.Printf("UpdateMasterHandler: Failed to get old master (JAN: %s): %v", input.ProductCode, err)
				http.Error(w, "Failed to retrieve master before edit", http.StatusInternalServerError)
				return
			}
		}

		// -------------------------------------------------
		// A. 更新の場合
		// -------------------------------------------------
		if !isNew {
			log.Printf("UpdateMasterHandler: Found existing master for ProductCode [%s]. Treating as UPDATE.", input.ProductCode)
			// 2. 編集前後の PackageKey を計算
			oldYjUnitName := units.ResolveName(oldMaster.YjUnitName)
			oldKey := fmt.Sprintf("%s|%s|%g|%s", oldMaster.YjCode, oldMaster.PackageForm, oldMaster.JanPackInnerQty, oldYjUnitName)

			newYjUnitName := units.ResolveName(input.YjUnitName)
			newKey := fmt.Sprintf("%s|%s|%g|%s", input.YjCode, input.PackageForm, input.JanPackInnerQty, newYjUnitName)

			if oldKey != newKey {
				alertMessage = "PackageKeyが変更されました。棚卸（在庫振替）を実施してください。"

				input.UserNotes = fmt.Sprintf("(自動記録: 旧Key [%s] から在庫振替要) %s", oldKey, input.UserNotes)

				log.Printf("UpdateMasterHandler: PackageKey changed for %s. OldKey [%s] NewKey [%s]. Alert set.",
					input.ProductCode, oldKey, newKey)
			}
		}

		// 6. マスタをDBに保存
		if _, err := mastermanager.UpsertProductMasterSqlx(tx, input); err != nil {
			log.Printf("UpdateMasterHandler: Failed to upsert product master (JAN: %s): %v", input.ProductCode, err)
			http.Error(w, "Failed to upsert product master", http.StatusInternalServerError)
			return
		}

		if err := tx.Commit(); err != nil {
			log.Printf("UpdateMasterHandler: Failed to commit transaction (JAN: %s): %v", input.ProductCode, err)
			http.Error(w, "Failed to commit transaction", http.StatusInternalServerError)
			return
		}

		log.Printf("UpdateMasterHandler: Successfully saved master (JAN: %s)", input.ProductCode)
		w.Header().Set("Content-Type", "application/json")

		// 7. レスポンスにアラートメッセージを含める
		response := map[string]string{
			"message": "Saved successfully.",
		}
		if alertMessage != "" {
			response["alert"] = alertMessage
		}
		json.NewEncoder(w).Encode(response)
	}
}

type SetOrderStoppedRequest struct {
	ProductCode string `json:"productCode"`
	Status      int    `json:"status"` // 0: 発注可, 1: 発注不可
}

func SetOrderStoppedHandler(conn *sqlx.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var req SetOrderStoppedRequest
		if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
			http.Error(w, "Invalid request body", http.StatusBadRequest)
			return
		}
		if req.ProductCode == "" {
			http.Error(w, "productCode is required", http.StatusBadRequest)
			return
		}

		tx, err := conn.Beginx() // TKR用に .Beginx() を使用
		if err != nil {
			http.Error(w, "Failed to start transaction", http.StatusInternalServerError)
			return
		}
		defer tx.Rollback()

		// TKRの GetProductMasterByCode を使用
		master, err := database.GetProductMasterByCode(tx, req.ProductCode)
		if err != nil {
			// ▼▼▼【修正】エラーハンドリング (sql.ErrNoRows を考慮) ▼▼▼
			if err == sql.ErrNoRows {
				http.Error(w, "Product not found", http.StatusNotFound)
			} else {
				http.Error(w, "Failed to get product master: "+err.Error(), http.StatusInternalServerError)
			}
			// ▲▲▲【修正ここまで】▲▲▲
			return
		}
		if master == nil {
			http.Error(w, "Product not found", http.StatusNotFound)
			return
		}

		// ステータスを更新
		master.IsOrderStopped = req.Status

		// TKRの mastermanager.MasterToInput を使用
		input := mastermanager.MasterToInput(master)

		// TKRの UpsertProductMasterSqlx を使用
		if _, err := mastermanager.UpsertProductMasterSqlx(tx, input); err != nil {
			http.Error(w, "Failed to update product master", http.StatusInternalServerError)
			return
		}

		if err := tx.Commit(); err != nil {
			http.Error(w, "Failed to commit transaction", http.StatusInternalServerError)
			return
		}
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]string{"message": "更新しました。"})
	}
}

// ▼▼▼【追加】棚番一括更新用ハンドラ ▼▼▼
type BulkShelfRequest struct {
	ProductCodes []string `json:"productCodes"`
	ShelfNumber  string   `json:"shelfNumber"`
}

func BulkUpdateShelfHandler(conn *sqlx.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		if r.Method != http.MethodPost {
			http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
			return
		}

		var req BulkShelfRequest
		if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
			http.Error(w, "Invalid request body", http.StatusBadRequest)
			return
		}

		if len(req.ProductCodes) == 0 {
			http.Error(w, "No products selected", http.StatusBadRequest)
			return
		}

		tx, err := conn.Beginx()
		if err != nil {
			http.Error(w, "Failed to start transaction", http.StatusInternalServerError)
			return
		}
		defer tx.Rollback()

		// sqlx.In を使って一括更新
		query, args, err := sqlx.In(`UPDATE product_master SET shelf_number = ? WHERE product_code IN (?)`, req.ShelfNumber, req.ProductCodes)
		if err != nil {
			http.Error(w, "Failed to construct update query: "+err.Error(), http.StatusInternalServerError)
			return
		}
		query = tx.Rebind(query)

		res, err := tx.Exec(query, args...)
		if err != nil {
			http.Error(w, "Failed to execute update: "+err.Error(), http.StatusInternalServerError)
			return
		}

		rowsAffected, _ := res.RowsAffected()

		if err := tx.Commit(); err != nil {
			http.Error(w, "Failed to commit transaction", http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]string{
			"message": fmt.Sprintf("%d件の棚番を「%s」に更新しました。", rowsAffected, req.ShelfNumber),
		})
	}
}


----- C:\Users\wasab\OneDrive\デスクトップ\TKR\mastermanager\manager.go -----
// C:\Users\wasab\OneDrive\デスクトップ\TKR\mastermanager\manager.go
package mastermanager

import (
	"database/sql"
	"fmt"
	"regexp"
	"strconv"
	"strings"
	"tkr/database"
	"tkr/model"

	"github.com/jmoiron/sqlx"
)

var yjCodeRegex = regexp.MustCompile(`^[0-9A-Z]{11,12}$`)
var janCodeRegex = regexp.MustCompile(`^[0-9]{13}$`)
var gs1CodeRegex = regexp.MustCompile(`^[0-9]{14}$`)
var ma2jCodeRegex = regexp.MustCompile(`^MA2J[0-9]{9}$`)

func FindOrCreateMaster(tx *sqlx.Tx, productCodeOrKey string, productName string) (*model.ProductMaster, error) {

	if productCodeOrKey == "0000000000000" ||
		productCodeOrKey == "" {
		if productName != "" {
			var existingMaster model.ProductMaster
			err := tx.Get(&existingMaster, "SELECT * FROM product_master WHERE kana_name_short = ?", productName)

			if err == nil {
				return &existingMaster, nil
			}
			if err != sql.ErrNoRows {
				return nil, fmt.Errorf("failed to query product_master by kana_name_short for %s: %w", productName, err)
			}
		}
	}

	var existingMaster model.ProductMaster
	var err error

	isJANKey := janCodeRegex.MatchString(productCodeOrKey)
	isYJKey := yjCodeRegex.MatchString(productCodeOrKey)
	isGS1Key := gs1CodeRegex.MatchString(productCodeOrKey)
	isMA2JKey := ma2jCodeRegex.MatchString(productCodeOrKey)

	if isYJKey {
		query := "SELECT * FROM product_master WHERE yj_code = ?"
		err = tx.Get(&existingMaster, query, productCodeOrKey)
	} else if isJANKey || isMA2JKey {
		query := "SELECT * FROM product_master WHERE product_code = ?"
		err = tx.Get(&existingMaster, query, productCodeOrKey)
	} else if isGS1Key {
		query := "SELECT * FROM product_master WHERE gs1_code = ?"
		err = tx.Get(&existingMaster, query, productCodeOrKey)
	} else {
		query := "SELECT * FROM product_master WHERE product_code = ?"
		err = tx.Get(&existingMaster, query, productCodeOrKey)
	}

	if err == nil {
		return &existingMaster, nil
	}
	if err != sql.ErrNoRows {
		return nil, fmt.Errorf("failed to query product_master for key %s: %w", productCodeOrKey, err)
	}

	if (isJANKey || isGS1Key) && !strings.HasPrefix(productCodeOrKey, "999") && productCodeOrKey != "0000000000000" && productCodeOrKey != "" {

		var jcshmsInfo *model.JcshmsInfo
		var jcshmsErr error

		if isJANKey {
			jcshmsInfo, jcshmsErr = database.GetJcshmsInfoByJan(tx, productCodeOrKey)
		} else {
			jcshmsInfo, jcshmsErr = database.GetJcshmsInfoByGs1Code(tx, productCodeOrKey)
		}

		if jcshmsErr != nil && jcshmsErr != sql.ErrNoRows {
			return nil, fmt.Errorf("failed to query jcshms/jancode for key %s: %w", productCodeOrKey, jcshmsErr)
		}

		if jcshmsInfo != nil {
			input := JcshmsToProductMasterInput(jcshmsInfo)

			if isGS1Key && input.Gs1Code == "" {
				input.Gs1Code = productCodeOrKey
			}

			if input.YjCode == "" {
				newYj, seqErr := database.NextSequenceInTx(tx, "MA2Y", "MA2Y", 8)
				if seqErr != nil {
					return nil, fmt.Errorf("failed to get next MA2Y sequence for JCSHMS master (Key: %s): %w", productCodeOrKey, seqErr)
				}
				input.YjCode = newYj
			}

			newMaster, upsertErr := UpsertProductMasterSqlx(tx, input)
			if upsertErr != nil {
				return nil, fmt.Errorf("failed to upsert master from JCSHMS for Key %s: %w", productCodeOrKey, upsertErr)
			}
			return newMaster, nil
		}
	}

	provisionalYjCode := productCodeOrKey
	if !isYJKey {
		newYj, seqErr := database.NextSequenceInTx(tx, "MA2Y", "MA2Y", 8)
		if seqErr != nil {
			return nil, fmt.Errorf("failed to get next MA2Y sequence for provisional master (Key: %s): %w", productCodeOrKey, seqErr)
		}
		provisionalYjCode = newYj
	}

	provisionalProductCode := productCodeOrKey
	if (!isJANKey && !isGS1Key) ||
		productCodeOrKey == "0000000000000" || productCodeOrKey == "" {
		newPJCode, seqErr := database.NextSequenceInTx(tx, "MA2J", "MA2J", 9)
		if seqErr != nil {
			return nil, fmt.Errorf("failed to get next MA2J sequence for provisional master (Key: %s): %w", productCodeOrKey, seqErr)
		}
		provisionalProductCode = newPJCode
	}

	dbProductName := productName
	if !strings.HasPrefix(productName, "◆") {
		dbProductName = "◆" + productName
	}

	provisionalInput := model.ProductMasterInput{
		ProductCode:         provisionalProductCode,
		YjCode:              provisionalYjCode,
		ProductName:         dbProductName,
		Origin:              "PROVISIONAL",
		UsageClassification: "他",
	}

	if isGS1Key {
		provisionalInput.Gs1Code = productCodeOrKey
	}

	if productCodeOrKey == "0000000000000" || productCodeOrKey == "" {
		provisionalInput.KanaNameShort = productName
	}

	newMaster, upsertErr := UpsertProductMasterSqlx(tx, provisionalInput)
	if upsertErr != nil {
		return nil, fmt.Errorf("failed to upsert provisional master (OrigKey: %s): %w", productCodeOrKey, upsertErr)
	}
	return newMaster, nil
}

func JcshmsToProductMasterInput(jcshms *model.JcshmsInfo) model.ProductMasterInput {
	var unitNhiPrice float64
	if jcshms.NhiPriceFactor > 0 {
		unitNhiPrice = jcshms.NhiPrice * jcshms.NhiPriceFactor
	} else if jcshms.YjPackUnitQty > 0 {
		unitNhiPrice = jcshms.PackageNhiPrice / jcshms.YjPackUnitQty
	} else {
		unitNhiPrice = jcshms.NhiPrice
	}
	janUnitCodeInt, _ := strconv.Atoi(jcshms.JanUnitCode.String)

	// ▼▼▼【ここから修正】剤型区分のロジックをご要望に合わせて変更 ▼▼▼
	var usageClass string
	if strings.TrimSpace(jcshms.YjCode) == "" {
		// YJコード(JC009)が空白の場合は、JC013の値に関わらず強制的に「他」を設定
		usageClass = "他"
	} else {
		// YJコードが存在する場合
		usageClass = strings.TrimSpace(jcshms.UsageClassification) // JC013の値を取得
		if usageClass == "" {
			// YJコードは存在するが、JC013が空白だった場合も「他」を設定
			usageClass = "他"
		}
	}
	// ▲▲▲【修正ここまで】▲▲▲

	return model.ProductMasterInput{
		ProductCode: jcshms.ProductCode,
		YjCode:      jcshms.YjCode,
		Gs1Code:     jcshms.Gs1Code,
		ProductName: strings.TrimSpace(jcshms.ProductName),
		KanaName:    strings.TrimSpace(jcshms.KanaName),

		KanaNameShort: strings.TrimSpace(jcshms.KanaNameShort),
		GenericName:   strings.TrimSpace(jcshms.GenericName),

		MakerName:           strings.TrimSpace(jcshms.MakerName),
		Specification:       strings.TrimSpace(jcshms.Specification),
		UsageClassification: usageClass, // ▼▼▼【修正】変更後の変数を設定
		PackageForm:         strings.TrimSpace(jcshms.PackageForm),
		YjUnitName:          strings.TrimSpace(jcshms.YjUnitName),
		YjPackUnitQty:       jcshms.YjPackUnitQty,
		JanPackInnerQty:     jcshms.JanPackInnerQty.Float64,
		JanUnitCode:         janUnitCodeInt,
		JanPackUnitQty:      jcshms.JanPackUnitQty.Float64,
		Origin:              "JCSHMS",
		NhiPrice:            unitNhiPrice,
		PurchasePrice:       0,
		FlagPoison:          jcshms.FlagPoison,
		FlagDeleterious:     jcshms.FlagDeleterious,
		FlagNarcotic:        jcshms.FlagNarcotic,
		FlagPsychotropic:    jcshms.FlagPsychotropic,
		FlagStimulant:       jcshms.FlagStimulant,
		FlagStimulantRaw:    jcshms.FlagStimulantRaw,
		IsOrderStopped:      0,
		SupplierWholesale:   "",
		GroupCode:           "",
		ShelfNumber:         "",
		Category:            "",
		UserNotes:           "",
	}
}

func UpsertProductMasterSqlx(tx *sqlx.Tx, input model.ProductMasterInput) (*model.ProductMaster, error) {
	query := `
		INSERT INTO product_master (
			product_code, yj_code, gs1_code, product_name, kana_name, kana_name_short, generic_name,
			maker_name, 
specification, usage_classification, package_form, yj_unit_name, yj_pack_unit_qty,
			jan_pack_inner_qty, jan_unit_code, jan_pack_unit_qty, origin,
			nhi_price, purchase_price,
			flag_poison, flag_deleterious, flag_narcotic, flag_psychotropic, flag_stimulant, 
flag_stimulant_raw,
			is_order_stopped, supplier_wholesale,
			group_code, shelf_number, category, user_notes
		) VALUES (
			:product_code, :yj_code, :gs1_code, :product_name, :kana_name, :kana_name_short, :generic_name,
			:maker_name, :specification, :usage_classification, :package_form, :yj_unit_name, :yj_pack_unit_qty,
			:jan_pack_inner_qty, :jan_unit_code, :jan_pack_unit_qty, :origin,
			:nhi_price, :purchase_price,
			:flag_poison, :flag_deleterious, :flag_narcotic, :flag_psychotropic, :flag_stimulant, :flag_stimulant_raw,
			:is_order_stopped, :supplier_wholesale,
			:group_code, :shelf_number, :category, :user_notes
		)
		ON CONFLICT(product_code) DO UPDATE SET
			yj_code=excluded.yj_code, gs1_code=excluded.gs1_code, product_name=excluded.product_name, kana_name=excluded.kana_name,
			kana_name_short=excluded.kana_name_short, generic_name=excluded.generic_name,
			maker_name=excluded.maker_name, specification=excluded.specification, usage_classification=excluded.usage_classification,
			package_form=excluded.package_form, yj_unit_name=excluded.yj_unit_name, yj_pack_unit_qty=excluded.yj_pack_unit_qty,
			jan_pack_inner_qty=excluded.jan_pack_inner_qty, jan_unit_code=excluded.jan_unit_code, jan_pack_unit_qty=excluded.jan_pack_unit_qty,
			origin=excluded.origin, nhi_price=excluded.nhi_price, purchase_price=excluded.purchase_price,
			flag_poison=excluded.flag_poison, flag_deleterious=excluded.flag_deleterious, flag_narcotic=excluded.flag_narcotic,
			flag_psychotropic=excluded.flag_psychotropic, flag_stimulant=excluded.flag_stimulant, flag_stimulant_raw=excluded.flag_stimulant_raw,
			is_order_stopped=excluded.is_order_stopped, supplier_wholesale=excluded.supplier_wholesale,
			group_code=excluded.group_code, shelf_number=excluded.shelf_number, category=excluded.category, user_notes=excluded.user_notes
	`

	_, err := tx.NamedExec(query, input)
	if err != nil {
		return nil, fmt.Errorf("NamedExec for upsert failed: %w", err)
	}

	var insertedMaster model.ProductMaster
	err = tx.Get(&insertedMaster, "SELECT * FROM product_master WHERE product_code = ?", input.ProductCode)

	if err != nil {
		return nil, fmt.Errorf("failed to re-fetch master after upsert for %s: %w", input.ProductCode, err)
	}

	return &insertedMaster,
		nil
}

func MasterToInput(m *model.ProductMaster) model.ProductMasterInput {
	return model.ProductMasterInput{
		ProductCode:         m.ProductCode,
		YjCode:              m.YjCode,
		Gs1Code:             m.Gs1Code,
		ProductName:         m.ProductName,
		KanaName:            m.KanaName,
		KanaNameShort:       m.KanaNameShort,
		GenericName:         m.GenericName,
		MakerName:           m.MakerName,
		Specification:       m.Specification,
		UsageClassification: m.UsageClassification,
		PackageForm:         m.PackageForm,
		YjUnitName:          m.YjUnitName,
		YjPackUnitQty:       m.YjPackUnitQty,
		JanPackInnerQty:     m.JanPackInnerQty,
		JanUnitCode:         m.JanUnitCode,
		JanPackUnitQty:      m.JanPackUnitQty,
		Origin:              m.Origin,
		NhiPrice:            m.NhiPrice,
		PurchasePrice:       m.PurchasePrice,
		FlagPoison:          m.FlagPoison,
		FlagDeleterious:     m.FlagDeleterious,
		FlagNarcotic:        m.FlagNarcotic,
		FlagPsychotropic:    m.FlagPsychotropic,
		FlagStimulant:       m.FlagStimulant,
		FlagStimulantRaw:    m.FlagStimulantRaw,
		IsOrderStopped:      m.IsOrderStopped,
		SupplierWholesale:   m.SupplierWholesale,
		GroupCode:           m.GroupCode,
		ShelfNumber:         m.ShelfNumber,
		Category:            m.Category,
		UserNotes:           m.UserNotes,
	}
}


----- C:\Users\wasab\OneDrive\デスクトップ\TKR\model\aggregation_types.go -----
// C:\Users\wasab\OneDrive\デスクトップ\TKR\model\aggregation_types.go
package model

// AggregationFilters は集計時のフィルタ条件です。
type AggregationFilters struct {
	StartDate    string
	EndDate      string
	KanaName     string
	DrugTypes    []string
	DosageForm   string
	Coefficient  float64
	YjCode       string
	MovementOnly bool
	ShelfNumber  string
	GenericName  string
}

// StockLedgerYJGroup はYJコード単位の集計グループです。
type StockLedgerYJGroup struct {
	YjCode                string                    `json:"yjCode"`
	ProductName           string                    `json:"productName"`
	YjUnitName            string                    `json:"yjUnitName"`
	PackageLedgers        []StockLedgerPackageGroup `json:"packageLedgers"`
	StartingBalance       interface{}               `json:"startingBalance"`
	NetChange             float64                   `json:"netChange"`
	EndingBalance         interface{}               `json:"endingBalance"`
	TotalReorderPoint     float64                   `json:"totalReorderPoint"`
	IsReorderNeeded       bool                      `json:"isReorderNeeded"`
	TotalBaseReorderPoint float64                   `json:"totalBaseReorderPoint"`
	TotalPrecompounded    float64                   `json:"totalPrecompounded"`
}

// StockLedgerPackageGroup は包装キー単位の集計グループです。
type StockLedgerPackageGroup struct {
	PackageKey             string              `json:"packageKey"`
	JanUnitName            string              `json:"janUnitName"`
	StartingBalance        interface{}         `json:"startingBalance"`
	Transactions           []LedgerTransaction `json:"transactions"`
	NetChange              float64             `json:"netChange"`
	EndingBalance          interface{}         `json:"endingBalance"`
	Masters                []*ProductMaster    `json:"masters"`
	EffectiveEndingBalance float64             `json:"effectiveEndingBalance"`
	MaxUsage               float64             `json:"maxUsage"`
	ReorderPoint           float64             `json:"reorderPoint"`
	IsReorderNeeded        bool                `json:"isReorderNeeded"`
	BaseReorderPoint       float64             `json:"baseReorderPoint"`
	PrecompoundedTotal     float64             `json:"precompoundedTotal"`
}

// LedgerTransaction は台帳表示用の取引記録です。
type LedgerTransaction struct {
	TransactionRecord
	RunningBalance float64 `json:"runningBalance"`
}

// ValuationFilters は在庫評価の絞り込み条件です。
type ValuationFilters struct {
	Date                string
	KanaName            string
	UsageClassification string // (JSからは dosageForm として渡される)
}

// ValuationDetailRow は在庫評価の明細行データです。
type ValuationDetailRow struct {
	YjCode               string  `json:"yjCode"`
	ProductName          string  `json:"productName"`
	ProductCode          string  `json:"productCode"` // 代表JAN
	PackageSpec          string  `json:"packageSpec"`
	Stock                float64 `json:"stock"` // YJ単位
	YjUnitName           string  `json:"yjUnitName"`
	PackageNhiPrice      float64 `json:"packageNhiPrice"`
	PackagePurchasePrice float64 `json:"packagePurchasePrice"`
	TotalNhiValue        float64 `json:"totalNhiValue"`
	TotalPurchaseValue   float64 `json:"totalPurchaseValue"`
	ShowAlert            bool    `json:"showAlert"`
	// ▼▼▼【ここから追加】CSV出力用に内包装数量を追加 ▼▼▼
	PackageKey      string  `json:"packageKey"`
	JanPackInnerQty float64 `json:"janPackInnerQty"`
	// ▲▲▲【追加ここまで】▲▲▲
}


----- C:\Users\wasab\OneDrive\デスクトップ\TKR\model\domain_types.go -----
// C:\Users\wasab\OneDrive\デスクトップ\TKR\model\domain_types.go
package model

type Client struct {
	ClientCode string `db:"client_code" json:"clientCode"`
	ClientName string `db:"client_name" json:"clientName"`
}

type Wholesaler struct {
	WholesalerCode string `db:"wholesaler_code" json:"wholesalerCode"`
	WholesalerName string `db:"wholesaler_name" json:"wholesalerName"`
}


----- C:\Users\wasab\OneDrive\デスクトップ\TKR\model\inventory_types.go -----
package model

type DeadStockRecord struct {
	ID               int     `db:"id" json:"id"`
	ProductCode      string  `db:"product_code" json:"productCode"`
	YjCode           string  `db:"yj_code" json:"yjCode"`
	PackageForm      string  `db:"package_form" json:"packageForm"`
	JanPackInnerQty  float64 `db:"jan_pack_inner_qty" json:"janPackInnerQty"`
	YjUnitName       string  `db:"yj_unit_name" json:"yjUnitName"`
	StockQuantityJan float64 `db:"stock_quantity_jan" json:"stockQuantityJan"`
	ExpiryDate       string  `db:"expiry_date" json:"expiryDate"`
	LotNumber        string  `db:"lot_number" json:"lotNumber"`
}

type PackageStock struct {
	PackageKey        string  `db:"package_key"`
	YjCode            string  `db:"yj_code"`
	StockQuantityYj   float64 `db:"stock_quantity_yj"`
	LastInventoryDate string  `db:"last_inventory_date"`
}

type DeadStockItem struct {
	PackageKey          string      `db:"package_key" json:"packageKey"`
	YjCode              string      `db:"yj_code" json:"yjCode"`
	StockQuantityYj     float64     `db:"stock_quantity_yj" json:"stockQuantityYj"`
	CurrentStockYj      float64     `json:"currentStockYj"`
	StockQuantityJan    float64     `json:"stockQuantityJan"`
	JanPackInnerQty     float64     `db:"jan_pack_inner_qty" json:"janPackInnerQty"`
	ProductName         string      `db:"product_name" json:"productName"`
	PackageSpec         string      `db:"package_spec" json:"packageSpec"`
	LotDetails          []LotDetail `json:"lotDetails"`
	KanaName            string      `db:"kana_name"`
	UsageClassification string      `db:"usage_classification"`
}

type LotDetail struct {
	JanCode     string  `db:"jan_code" json:"JanCode"`
	Gs1Code     string  `db:"gs1_code" json:"Gs1Code"`
	PackageSpec string  `db:"package_spec" json:"PackageSpec"`
	ExpiryDate  string  `db:"expiry_date" json:"ExpiryDate"`
	LotNumber   string  `db:"lot_number" json:"LotNumber"`
	JanQuantity float64 `db:"jan_quantity" json:"JanQuantity"`
	JanUnitName string  `db:"jan_unit_name" json:"JanUnitName"`
}


----- C:\Users\wasab\OneDrive\デスクトップ\TKR\model\master_types.go -----
// C:\Users\wasab\OneDrive\デスクトップ\TKR\model\master_types.go
package model

import "database/sql"

type JcshmsInfo struct {
	ProductCode string `db:"JC000" json:"productCode"`
	YjCode      string `db:"JC009" json:"yjCode"`
	ProductName string `db:"JC018" json:"productName"`

	Specification string `db:"JC020" json:"specification"` // 規格容量

	KanaNameShort string `db:"JC019" json:"kanaNameShort"`
	KanaName      string `db:"JC022" json:"kanaName"`
	GenericName   string `db:"JC024" json:"genericName"`

	MakerName           string  `db:"JC030" json:"makerName"`
	UsageClassification string  `db:"JC013" json:"usageClassification"`
	PackageForm         string  `db:"JC037" json:"packageForm"`
	YjUnitName          string  `db:"JC039" json:"yjUnitName"`
	YjPackUnitQty       float64 `db:"JC044" json:"yjPackUnitQty"`
	NhiPrice            float64 `db:"JC049" json:"nhiPrice"`
	PackageNhiPrice     float64 `db:"JC050" json:"packageNhiPrice"`
	Gs1Code             string  `db:"JC122" json:"gs1Code"`
	NhiPriceFactor      float64 `db:"JC124" json:"nhiPriceFactor"`

	JanPackInnerQty sql.NullFloat64 `db:"JA006" json:"janPackInnerQty"`
	JanUnitCode     sql.NullString  `db:"JA007" json:"janUnitCode"`
	JanPackUnitQty  sql.NullFloat64 `db:"JA008" json:"janPackUnitQty"`

	FlagPoison       int `db:"JC061" json:"flagPoison"`
	FlagDeleterious  int `db:"JC062" json:"flagDeleterious"`
	FlagNarcotic     int `db:"JC063" json:"flagNarcotic"`
	FlagPsychotropic int `db:"JC064" json:"flagPsychotropic"`
	FlagStimulant    int `db:"JC065" json:"flagStimulant"`
	FlagStimulantRaw int `db:"JC066" json:"flagStimulantRaw"`
}

type ProductMaster struct {
	ProductCode         string  `db:"product_code" json:"productCode"`
	YjCode              string  `db:"yj_code" json:"yjCode"`
	Gs1Code             string  `db:"gs1_code" json:"gs1Code"`
	ProductName         string  `db:"product_name" json:"productName"`
	KanaName            string  `db:"kana_name" json:"kanaName"`
	KanaNameShort       string  `db:"kana_name_short" json:"kanaNameShort"`
	GenericName         string  `db:"generic_name" json:"genericName"`
	MakerName           string  `db:"maker_name" json:"makerName"`
	Specification       string  `db:"specification" json:"specification"`
	UsageClassification string  `db:"usage_classification" json:"usageClassification"`
	PackageForm         string  `db:"package_form" json:"packageForm"`
	YjUnitName          string  `db:"yj_unit_name" json:"yjUnitName"`
	YjPackUnitQty       float64 `db:"yj_pack_unit_qty" json:"yjPackUnitQty"`
	JanPackInnerQty     float64 `db:"jan_pack_inner_qty" json:"janPackInnerQty"`
	JanUnitCode         int     `db:"jan_unit_code" json:"janUnitCode"`
	JanPackUnitQty      float64 `db:"jan_pack_unit_qty" json:"janPackUnitQty"`
	Origin              string  `db:"origin" json:"origin"`
	NhiPrice            float64 `db:"nhi_price" json:"nhiPrice"`
	PurchasePrice       float64 `db:"purchase_price" json:"purchasePrice"`
	FlagPoison          int     `db:"flag_poison" json:"flagPoison"`
	FlagDeleterious     int     `db:"flag_deleterious" json:"flagDeleterious"`
	FlagNarcotic        int     `db:"flag_narcotic" json:"flagNarcotic"`
	FlagPsychotropic    int     `db:"flag_psychotropic" json:"flagPsychotropic"`
	FlagStimulant       int     `db:"flag_stimulant" json:"flagStimulant"`
	FlagStimulantRaw    int     `db:"flag_stimulant_raw" json:"flagStimulantRaw"`
	IsOrderStopped      int     `db:"is_order_stopped" json:"isOrderStopped"`
	SupplierWholesale   string  `db:"supplier_wholesale" json:"supplierWholesale"`
	GroupCode           string  `db:"group_code" json:"groupCode"`
	ShelfNumber         string  `db:"shelf_number" json:"shelfNumber"`
	Category            string  `db:"category" json:"category"`
	UserNotes           string  `db:"user_notes" json:"userNotes"`
}

type ProductMasterInput struct {
	ProductCode         string  `db:"product_code" json:"productCode"`
	YjCode              string  `db:"yj_code" json:"yjCode"`
	Gs1Code             string  `db:"gs1_code" json:"gs1Code"`
	ProductName         string  `db:"product_name" json:"productName"`
	KanaName            string  `db:"kana_name" json:"kanaName"`
	KanaNameShort       string  `db:"kana_name_short" json:"kanaNameShort"`
	GenericName         string  `db:"generic_name" json:"genericName"`
	MakerName           string  `db:"maker_name" json:"makerName"`
	Specification       string  `db:"specification" json:"specification"`
	UsageClassification string  `db:"usage_classification" json:"usageClassification"`
	PackageForm         string  `db:"package_form" json:"packageForm"`
	YjUnitName          string  `db:"yj_unit_name" json:"yjUnitName"`
	YjPackUnitQty       float64 `db:"yj_pack_unit_qty" json:"yjPackUnitQty"`
	JanPackInnerQty     float64 `db:"jan_pack_inner_qty" json:"janPackInnerQty"`
	JanUnitCode         int     `db:"jan_unit_code" json:"janUnitCode"`
	JanPackUnitQty      float64 `db:"jan_pack_unit_qty" json:"janPackUnitQty"`
	Origin              string  `db:"origin" json:"origin"`
	NhiPrice            float64 `db:"nhi_price" json:"nhiPrice"`
	PurchasePrice       float64 `db:"purchase_price" json:"purchasePrice"`
	FlagPoison          int     `db:"flag_poison" json:"flagPoison"`
	FlagDeleterious     int     `db:"flag_deleterious" json:"flagDeleterious"`
	FlagNarcotic        int     `db:"flag_narcotic" json:"flagNarcotic"`
	FlagPsychotropic    int     `db:"flag_psychotropic" json:"flagPsychotropic"`
	FlagStimulant       int     `db:"flag_stimulant" json:"flagStimulant"`
	FlagStimulantRaw    int     `db:"flag_stimulant_raw" json:"flagStimulantRaw"`
	IsOrderStopped      int     `db:"is_order_stopped" json:"isOrderStopped"`
	SupplierWholesale   string  `db:"supplier_wholesale" json:"supplierWholesale"`
	GroupCode           string  `db:"group_code" json:"groupCode"`
	ShelfNumber         string  `db:"shelf_number" json:"shelfNumber"`
	Category            string  `db:"category" json:"category"`
	UserNotes           string  `db:"user_notes" json:"userNotes"`
}

type ProductMasterView struct {
	ProductMaster
	FormattedPackageSpec string `json:"formattedPackageSpec"`
	JanUnitName          string `json:"janUnitName"`
	IsAdopted            bool   `json:"isAdopted,omitempty"`
}


----- C:\Users\wasab\OneDrive\デスクトップ\TKR\model\order_types.go -----
// C:\Users\wasab\OneDrive\デスクトップ\TKR\model\order_types.go
package model

// Backorder は backorders テーブルのレコードを表します。
// (WASABI: model/types.go を TKR 用に修正)
type Backorder struct {
	ID        int    `db:"id" json:"id"`
	OrderDate string `db:"order_date" json:"orderDate"`
	// ▼▼▼【ここに追加】▼▼▼
	JanCode string `db:"jan_code" json:"janCode,omitempty"`
	// ▲▲▲【追加ここまで】▲▲▲
	YjCode            string  `db:"yj_code" json:"yjCode"`
	ProductName       string  `db:"product_name" json:"productName"`
	PackageForm       string  `db:"package_form" json:"packageForm"`
	JanPackInnerQty   float64 `db:"jan_pack_inner_qty" json:"janPackInnerQty"`
	YjUnitName        string  `db:"yj_unit_name" json:"yjUnitName"`
	OrderQuantity     float64 `db:"order_quantity" json:"orderQuantity"`
	RemainingQuantity float64 `db:"remaining_quantity" json:"remainingQuantity"`
	// TKRの database/backorders.go に合わせ、*sql.NullString ではなく string を使用
	WholesalerCode string  `db:"wholesaler_code" json:"wholesalerCode,omitempty"`
	YjPackUnitQty  float64 `db:"yj_pack_unit_qty" json:"yjPackUnitQty"`
	JanPackUnitQty float64 `db:"jan_pack_unit_qty" json:"janPackUnitQty"`
	JanUnitCode    int     `db:"jan_unit_code" json:"janUnitCode"`

	// フロントエンドからの発注データ受け取り用フィールド (DBカラムなし)
	YjQuantity float64 `json:"yjQuantity,omitempty"`
}

// ▼▼▼【ここから追加】 (WASABI: model/types.go  より) ▼▼▼
type PriceUpdate struct {
	ProductCode      string  `json:"productCode"`
	NewPurchasePrice float64 `json:"newPrice"`
	NewSupplier      string  `json:"newWholesaler"`
}

type ProductQuote struct {
	ProductCode    string  `db:"product_code" json:"productCode"`
	WholesalerCode string  `db:"wholesaler_code" json:"wholesalerCode"`
	QuotePrice     float64 `db:"quote_price" json:"quotePrice"`
	QuoteDate      string  `db:"quote_date" json:"quoteDate"`
}

// ▲▲▲【追加ここまで】▲▲▲


----- C:\Users\wasab\OneDrive\デスクトップ\TKR\model\transaction_types.go -----
// C:\Users\wasab\OneDrive\デスクトップ\TKR\model\transaction_types.go
package model

type DatRecord struct {
	ClientCode    string
	Flag          int
	Date          string
	ReceiptNumber string
	LineNumber    string
	JanCode       string
	ProductName   string
	DatQuantity   float64
	UnitPrice     float64
	Subtotal      float64
	ExpiryDate    string
	LotNumber     string
}

type TransactionRecord struct {
	ID                  int     `db:"id" json:"id"`
	TransactionDate     string  `db:"transaction_date" json:"transactionDate"`
	ClientCode          string  `db:"client_code" json:"clientCode"`
	ReceiptNumber       string  `db:"receipt_number" json:"receiptNumber"`
	LineNumber          string  `db:"line_number" json:"lineNumber"`
	Flag                int     `db:"flag" json:"flag"`
	JanCode             string  `db:"jan_code" json:"janCode"`
	YjCode              string  `db:"yj_code" json:"yjCode"`
	ProductName         string  `db:"product_name" json:"productName"`
	KanaName            string  `db:"kana_name" json:"kanaName"`
	UsageClassification string  `db:"usage_classification" json:"usageClassification"`
	PackageForm         string  `db:"package_form" json:"packageForm"`
	PackageSpec         string  `db:"package_spec" json:"packageSpec"`
	MakerName           string  `db:"maker_name" json:"makerName"`
	DatQuantity         float64 `db:"dat_quantity" json:"datQuantity"`
	JanPackInnerQty     float64 `db:"jan_pack_inner_qty" json:"janPackInnerQty"`
	JanQuantity         float64 `db:"jan_quantity" json:"janQuantity"`
	JanPackUnitQty      float64 `db:"jan_pack_unit_qty" json:"janPackUnitQty"`
	JanUnitName         string  `db:"jan_unit_name" json:"janUnitName"`
	JanUnitCode         string  `db:"jan_unit_code" json:"janUnitCode"`
	YjQuantity          float64 `db:"yj_quantity" json:"yjQuantity"`
	YjPackUnitQty       float64 `db:"yj_pack_unit_qty" json:"yjPackUnitQty"`
	YjUnitName          string  `db:"yj_unit_name" json:"yjUnitName"`
	UnitPrice           float64 `db:"unit_price" json:"unitPrice"`
	PurchasePrice       float64 `db:"purchase_price" json:"purchasePrice"`
	SupplierWholesale   string  `db:"supplier_wholesale" json:"supplierWholesale"`
	Subtotal            float64 `db:"subtotal" json:"subtotal"`
	TaxAmount           float64 `db:"tax_amount" json:"taxAmount"`
	TaxRate             float64 `db:"tax_rate" json:"taxRate"`
	ExpiryDate          string  `db:"expiry_date" json:"expiryDate"`
	LotNumber           string  `db:"lot_number" json:"lotNumber"`
	FlagPoison          int     `db:"flag_poison" json:"flagPoison"`
	FlagDeleterious     int     `db:"flag_deleterious" json:"flagDeleterious"`
	FlagNarcotic        int     `db:"flag_narcotic" json:"flagNarcotic"`
	FlagPsychotropic    int     `db:"flag_psychotropic" json:"flagPsychotropic"`
	FlagStimulant       int     `db:"flag_stimulant" json:"flagStimulant"`
	FlagStimulantRaw    int     `db:"flag_stimulant_raw" json:"flagStimulantRaw"`
	ProcessFlagMA       string  `db:"process_flag_ma" json:"processFlagMA"`
}

type UnifiedInputRecord struct {
	Date        string
	YjCode      string
	JanCode     string
	ProductName string
	YjQuantity  float64
	YjUnitName  string
}


----- C:\Users\wasab\OneDrive\デスクトップ\TKR\model\types.go -----
// C:\Users\wasab\OneDrive\デスクトップ\TKR\model\types.go
package model

// このファイル内の型定義は、機能ごとに
// master_types.go, transaction_types.go, aggregation_types.go,
// inventory_types.go, domain_types.go に分割されました。


----- C:\Users\wasab\OneDrive\デスクトップ\TKR\parsers\client_csv_parser.go -----
// C:\Users\wasab\OneDrive\デスクトップ\TKR\parsers\client_csv_parser.go
package parsers

import (
	"encoding/csv"
	"fmt"
	"io"
	"log"
	"strings"
)

// ParsedClientCSVRecord は得意先CSVの1行を表します。
type ParsedClientCSVRecord struct {
	ClientCode string
	ClientName string
}

// ParseClientCSV は得意先マスタCSVを解析します。
func ParseClientCSV(r io.Reader) ([]ParsedClientCSVRecord, error) {
	// SkipBOM [cite: 4504-4505] を使用
	reader := csv.NewReader(SkipBOM(r))
	reader.LazyQuotes = true

	header, err := reader.Read()
	if err == io.EOF {
		return nil, fmt.Errorf("CSVファイルが空です")
	}
	if err != nil {
		return nil, fmt.Errorf("CSVヘッダーの読み取りに失敗: %w", err)
	}

	// getColIndex [cite: 4505-4506] を使用
	requiredHeaders := []string{"client_code", "client_name"}
	colIndex, err := getColIndex(header, requiredHeaders)
	if err != nil {
		return nil, err
	}

	var records []ParsedClientCSVRecord
	line := 1

	for {
		line++
		rec, err := reader.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			log.Printf("WARN: 得意先CSV %d行目の読み取りエラー (スキップ): %v", line, err)
			continue
		}

		get := func(key string) string {
			if idx, ok := colIndex[key]; ok && idx < len(rec) {
				return strings.TrimSpace(rec[idx])
			}
			return ""
		}

		clientCode := get("client_code")
		clientName := get("client_name")

		if clientCode == "" || clientName == "" {
			log.Printf("WARN: 得意先CSV %d行目 (コードまたは名称が空) (スキップ)", line)
			continue
		}

		records = append(records, ParsedClientCSVRecord{
			ClientCode: clientCode,
			ClientName: clientName,
		})
	}

	return records, nil
}


----- C:\Users\wasab\OneDrive\デスクトップ\TKR\parsers\dat_parser.go -----
// C:\Users\wasab\OneDrive\デスクトップ\TKR\parsers\dat_parser.go
package parsers

import (
	"bufio"
	"bytes" // bytes パッケージを追加
	"fmt"
	"io"
	"strconv"
	"strings"   // strings パッケージを追加
	"tkr/model" // model パッケージをインポート

	"golang.org/x/text/encoding/japanese"
	"golang.org/x/text/transform"
)

// ▼▼▼【ここから修正】UTF-8に事前変換せず、バイトスライスとしてパースする ▼▼▼

// sjisToUTF8 は Shift-JIS のバイトスライスを UTF-8 文字列に変換します。
func sjisToUTF8(b []byte) string {
	// 0x00 (NULL文字) はトリム対象の空白とはみなされないため、
	// 先に ReplaceAll で除去してから TrimSpace をかける
	trimmedBytes := bytes.Trim(b, "\x00 ") // NULL文字と空白を除去
	utf8Bytes, _, _ := transform.Bytes(japanese.ShiftJIS.NewDecoder(), trimmedBytes)
	return string(utf8Bytes)
}

// trimSpaceAndGetString は、バイトスライスの指定範囲を文字列として取得し、空白とNULL文字を除去します。
func trimSpaceAndGetString(line []byte, start, end int) string {
	if start >= len(line) {
		return ""
	}
	if end > len(line) {
		end = len(line)
	}
	// 0x00 (NULL文字) と 0x20 (スペース) を両端から除去
	trimmedSlice := bytes.Trim(line[start:end], "\x00 ")
	return string(trimmedSlice)
}

// parseFloat は、バイトスライスの指定範囲を float64 に変換します (エラー時は 0.0)
func parseFloat(line []byte, start, end int) float64 {
	s := trimSpaceAndGetString(line, start, end)
	f, _ := strconv.ParseFloat(s, 64)
	return f
}

// parseInt は、バイトスライスの指定範囲を int に変換します (エラー時は 0)
func parseInt(line []byte, start, end int) int {
	s := trimSpaceAndGetString(line, start, end)
	i, _ := strconv.Atoi(s)
	return i
}

// ▼▼▼【ここから追加】有効期限を YYYYMM に正規化する関数 ▼▼▼
func normalizeExpiryDate(rawDate string) string {
	rawDate = strings.TrimSpace(rawDate)
	l := len(rawDate)

	switch {
	case l == 8: // YYYYMMDD (例: 20281231)
		return rawDate[0:6] // "202812"
	case l == 6: // YYMMDD (例: 280131)
		yy := rawDate[0:2]
		mm := rawDate[2:4]
		return "20" + yy + mm // "202801"
	case l == 4: // YYMM (例: 2812)
		yy := rawDate[0:2]
		mm := rawDate[2:4]
		return "20" + yy + mm // "202812"
	default:
		return rawDate // 不明な形式はそのまま返す
	}
}

// ▲▲▲【追加ここまで】▲▲▲

// ParseDat は、固定長のDATファイルからレコードを抽出し、DatRecord のスライスを返します。
func ParseDat(r io.Reader) ([]model.DatRecord, error) {
	// UTF-8へのデコーダーを削除
	scanner := bufio.NewScanner(r)

	var records []model.DatRecord
	var currentWholesale string

	for scanner.Scan() {
		lineBytes := scanner.Bytes() // UTF-8ではなく、元のバイト列を取得

		if len(lineBytes) == 0 {
			continue
		}

		// レコード区分 (1バイト目)
		recordType := ""
		if len(lineBytes) > 0 {
			recordType = string(lineBytes[0:1])
		}

		switch recordType {
		case "S":
			// Sレコードから卸コードを取得 (バイト位置 3 から 13 未満)
			currentWholesale = trimSpaceAndGetString(lineBytes, 3, 13)
		case "D":
			// Dレコード (最低 121 バイト必要と仮定)
			if len(lineBytes) < 121 {
				continue
			}

			// バイト位置に基づいてパース
			flag := parseInt(lineBytes, 3, 4)
			date := trimSpaceAndGetString(lineBytes, 4, 12)
			receiptNumber := trimSpaceAndGetString(lineBytes, 12, 22)
			lineNumber := trimSpaceAndGetString(lineBytes, 22, 24)
			janCode := trimSpaceAndGetString(lineBytes, 25, 38)

			// 製品名 (バイト位置 38-78) のみ Shift-JIS から UTF-8 に変換
			productName := sjisToUTF8(lineBytes[38:78])

			datQuantity := parseFloat(lineBytes, 78, 83)
			unitPrice := parseFloat(lineBytes, 83, 92)
			subtotal := parseFloat(lineBytes, 92,
				101)

			// 期限とロット (バイト位置)
			rawExpiryDate := trimSpaceAndGetString(lineBytes, 109, 115)
			lotNumber := trimSpaceAndGetString(lineBytes, 115, 121)

			// ▼▼▼【ここを修正】正規化関数を呼び出す ▼▼▼
			expiryDate := normalizeExpiryDate(rawExpiryDate)
			// ▲▲▲【修正ここまで】▲▲▲

			rec := model.DatRecord{
				ClientCode:    currentWholesale,
				Flag:          flag,
				Date:          date,
				ReceiptNumber: receiptNumber,
				LineNumber:    lineNumber,
				JanCode:       janCode,
				ProductName:   productName,
				DatQuantity:   datQuantity,
				UnitPrice:     unitPrice,
				Subtotal:      subtotal,
				ExpiryDate:    expiryDate, // 正規化後の YYYYMM 形式
				LotNumber:     lotNumber,
			}
			records = append(records, rec)
		}
	}
	if err := scanner.Err(); err != nil {
		return nil, fmt.Errorf("error reading DAT file: %w", err)
	}
	return records, nil
}

// ▲▲▲【修正ここまで】▲▲▲


----- C:\Users\wasab\OneDrive\デスクトップ\TKR\parsers\deadstock_csv_parser.go -----
// C:\Users\wasab\OneDrive\デスクトップ\TKR\parsers\deadstock_csv_parser.go
package parsers

import (
	"encoding/csv"
	"fmt"
	"io"
	"log"
	"strconv"
	"strings"
)

type ParsedDeadStockCSVRecord struct {
	ProductCode string
	Gs1Code     string
	ProductName string
	JanQuantity float64
	ExpiryDate  string
	LotNumber   string
}

func ParseDeadStockCSV(r io.Reader) ([]ParsedDeadStockCSVRecord, error) {
	// ▼▼▼【修正】skipBOM -> SkipBOM ▼▼▼
	reader := csv.NewReader(SkipBOM(r))
	// ▲▲▲【修正ここまで】▲▲▲
	reader.LazyQuotes = true

	header, err := reader.Read()
	if err == io.EOF {
		return nil, fmt.Errorf("CSVファイルが空です")
	}
	if err != nil {
		return nil, fmt.Errorf("CSVヘッダーの読み取りに失敗: %w", err)
	}

	colIndex := make(map[string]int)
	for i, colName := range header {
		colIndex[strings.TrimSpace(colName)] = i
	}

	requiredHeaders := []string{"JANコード", "JAN数量"}
	for _, req := range requiredHeaders {
		if _, ok := colIndex[req]; !ok {
			return nil, fmt.Errorf("必須ヘッダーが見つかりません: %s", req)
		}
	}

	var records []ParsedDeadStockCSVRecord
	line := 1

	for {
		line++
		rec, err := reader.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			log.Printf("WARN: CSV %d行目の読み取りエラー (スキップ): %v", line, err)
			continue
		}

		get := func(key string) string {
			if idx, ok := colIndex[key]; ok && idx < len(rec) {
				val := strings.TrimSpace(rec[idx])
				return val
			}
			return ""
		}

		getFloat := func(key string) float64 {
			s := get(key)
			f, _ := strconv.ParseFloat(s, 64)
			return f
		}

		janQty := getFloat("JAN数量")
		if janQty == 0 {
			continue
		}

		parsedRec := ParsedDeadStockCSVRecord{
			ProductCode: get("JANコード"),
			Gs1Code:     get("GS1コード"),
			ProductName: get("品名"),
			JanQuantity: janQty,
			ExpiryDate:  get("期限"),
			LotNumber:   get("ロット"),
		}

		if parsedRec.ProductCode == "" {
			parsedRec.ProductCode = parsedRec.Gs1Code
		}

		records = append(records, parsedRec)
	}
	return records, nil
}


----- C:\Users\wasab\OneDrive\デスクトップ\TKR\parsers\parser_utils.go -----
// C:\Users\wasab\OneDrive\デスクトップ\TKR\parsers\parser_utils.go
package parsers

import (
	"bufio"
	"fmt"
	"io"
	"strings"
)

// ▼▼▼【修正】関数名を 'skipBOM' から 'SkipBOM' に変更 ▼▼▼
// SkipBOM はUTF-8 BOMをスキップします。
func SkipBOM(r io.Reader) io.Reader {
	// ▲▲▲【修正ここまで】▲▲▲
	br := bufio.NewReader(r)
	bom := []byte{0xEF, 0xBB, 0xBF}
	peeked, err := br.Peek(3)
	if err != nil {
		return br
	}
	isBOM := true
	for i, b := range bom {
		if peeked[i] != b {
			isBOM = false
			break
		}
	}
	if isBOM {
		br.Read(make([]byte, 3))
	}
	return br
}

// getColIndex はヘッダー名から列インデックスを取得するヘルパーです。
func getColIndex(header []string, required []string) (map[string]int, error) {
	colIndex := make(map[string]int)
	for i, colName := range header {
		colIndex[strings.TrimSpace(colName)] = i
	}
	for _, req := range required {
		if _, ok := colIndex[req]; !ok {
			return nil, fmt.Errorf("必須ヘッダーが見つかりません: %s", req)
		}
	}
	return colIndex, nil
}


----- C:\Users\wasab\OneDrive\デスクトップ\TKR\parsers\precomp_csv_parser.go -----
package parsers

import (
	"encoding/csv"
	"fmt"
	"io"
	"log"
	"strconv"
	"strings"
)

type ParsedPrecompCSVRecord struct {
	PatientNumber string
	ProductCode   string
	JanQuantity   float64
}

func ParsePrecompCSV(r io.Reader) ([]ParsedPrecompCSVRecord, error) {
	reader := csv.NewReader(SkipBOM(r))
	reader.LazyQuotes = true

	header, err := reader.Read()
	if err == io.EOF {
		return nil, fmt.Errorf("CSVファイルが空です")
	}
	if err != nil {
		return nil, fmt.Errorf("CSVヘッダーの読み取りに失敗: %w", err)
	}

	requiredHeaders := []string{"patient_number", "product_code", "quantity_jan"}
	colIndex, err := getColIndex(header, requiredHeaders)
	if err != nil {
		return nil, err
	}

	var records []ParsedPrecompCSVRecord
	line := 1

	for {
		line++
		rec, err := reader.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			log.Printf("WARN: 予製CSV %d行目の読み取りエラー (スキップ): %v", line, err)
			continue
		}

		get := func(key string) string {
			if idx, ok := colIndex[key]; ok && idx < len(rec) {
				return strings.TrimSpace(rec[idx])
			}
			return ""
		}

		patientNumber := get("patient_number")
		productCode := get("product_code")
		janQty, _ := strconv.ParseFloat(get("quantity_jan"), 64)

		if patientNumber == "" || productCode == "" {
			log.Printf("WARN: 予製CSV %d行目 (患者番号または製品コードが空) (スキップ)", line)
			continue
		}

		records = append(records, ParsedPrecompCSVRecord{
			PatientNumber: patientNumber,
			ProductCode:   productCode,
			JanQuantity:   janQty,
		})
	}

	return records, nil
}


----- C:\Users\wasab\OneDrive\デスクトップ\TKR\parsers\stock_csv_parser.go -----
// C:\Users\wasab\OneDrive\デスクトップ\TKR\parsers\stock_csv_parser.go
package parsers

import (
	"encoding/csv"
	"fmt"
	"io"
	"log"
	"strconv"
	"strings"
)

type ParsedExternalStockCSVRecord struct {
	JanCode     string
	JanQuantity float64
	ExpiryDate  string
	LotNumber   string
}

type ParsedTKRStockCSVRecord struct {
	PackageKey  string
	ProductName string
	JanQuantity float64
}

func ParseExternalStockCSV(r io.Reader) ([]ParsedExternalStockCSVRecord, error) {
	// ▼▼▼【修正】skipBOM -> SkipBOM ▼▼▼
	reader := csv.NewReader(SkipBOM(r))
	// ▲▲▲【修正ここまで】▲▲▲
	reader.LazyQuotes = true

	header, err := reader.Read()
	if err == io.EOF {
		return nil, fmt.Errorf("CSVファイルが空です")
	}
	if err != nil {
		return nil, fmt.Errorf("CSVヘッダーの読み取りに失敗: %w", err)
	}

	requiredHeaders := []string{"JANコード", "JAN数量"}
	colIndex, err := getColIndex(header, requiredHeaders)
	if err != nil {
		return nil, err
	}

	idxExpiry, hasExpiry := colIndex["期限"]
	idxLot, hasLot := colIndex["ロット"]

	var records []ParsedExternalStockCSVRecord
	line := 1
	for {
		line++
		rec, err := reader.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			log.Printf("WARN: CSV %d行目の読み取りエラー (スキップ): %v", line,
				err)
			continue
		}

		get := func(idx int) string {
			if idx < len(rec) {
				return strings.TrimSpace(rec[idx])
			}
			return ""
		}

		janQty, _ := strconv.ParseFloat(get(colIndex["JAN数量"]), 64)
		if janQty <= 0 {
			continue
		}

		parsedRec := ParsedExternalStockCSVRecord{
			JanCode:     get(colIndex["JANコード"]),
			JanQuantity: janQty,
		}

		if hasExpiry {
			parsedRec.ExpiryDate = get(idxExpiry)
		}
		if hasLot {
			parsedRec.LotNumber = get(idxLot)
		}

		records = append(records, parsedRec)
	}
	return records, nil
}

func ParseTKRStockCSV(r io.Reader) ([]ParsedTKRStockCSVRecord, error) {
	// ▼▼▼【修正】skipBOM -> SkipBOM ▼▼▼
	reader := csv.NewReader(SkipBOM(r))
	// ▲▲▲【修正ここまで】▲▲▲
	reader.LazyQuotes = true

	header, err := reader.Read()
	if err == io.EOF {
		return nil, fmt.Errorf("CSVファイルが空です")
	}
	if err != nil {
		return nil, fmt.Errorf("CSVヘッダーの読み取りに失敗: %w", err)
	}

	requiredHeaders := []string{"PackageKey", "JAN数量"}
	colIndex, err := getColIndex(header, requiredHeaders)
	if err != nil {
		return nil, err
	}

	var records []ParsedTKRStockCSVRecord
	line := 1
	for {
		line++
		rec, err := reader.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			log.Printf("WARN: CSV %d行目の読み取りエラー (スキップ): %v",
				line, err)
			continue
		}

		get := func(idx int) string {
			if idx < len(rec) {
				return strings.TrimSpace(rec[idx])
			}
			return ""
		}

		janQty, _ := strconv.ParseFloat(get(colIndex["JAN数量"]), 64)

		parsedRec := ParsedTKRStockCSVRecord{
			PackageKey:  get(colIndex["PackageKey"]),
			JanQuantity: janQty,
		}

		records = append(records, parsedRec)
	}
	return records, nil
}


----- C:\Users\wasab\OneDrive\デスクトップ\TKR\parsers\usage_parser.go -----
// C:\Users\wasab\OneDrive\デスクトップ\TKR\parsers\usage_parser.go
package parsers

import (
	"encoding/csv"
	"fmt"
	"io"
	"strconv"
	"tkr/model" // TKRのモデルを参照

	"golang.org/x/text/encoding/japanese"
	"golang.org/x/text/transform"
)

// ParseUsageはUSAGE CSVを解析し、UnifiedInputRecordのスライスを返します。
func ParseUsage(r io.Reader) ([]model.UnifiedInputRecord, error) {
	reader := csv.NewReader(transform.NewReader(r, japanese.ShiftJIS.NewDecoder()))
	reader.FieldsPerRecord = -1

	var records []model.UnifiedInputRecord
	for {
		rec, err := reader.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			return nil, fmt.Errorf("csv read error: %w", err)
		}

		if len(rec) < 6 {
			continue // skip incomplete rows
		}

		yjQty, _ := strconv.ParseFloat(rec[4], 64)

		unifiedRec := model.UnifiedInputRecord{
			Date:        rec[0],
			YjCode:      rec[1],
			JanCode:     rec[2],
			ProductName: rec[3],
			YjQuantity:  yjQty,
			YjUnitName:  rec[5],
		}
		records = append(records, unifiedRec)
	}
	return records, nil
}


----- C:\Users\wasab\OneDrive\デスクトップ\TKR\precomp\handler.go -----
package precomp

import (
	"bytes"
	"encoding/csv"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"net/url"
	"time"
	"tkr/database"
	"tkr/model"
	"tkr/parsers"
	"tkr/units"

	"github.com/jmoiron/sqlx"
)

type PrecompPayload struct {
	PatientNumber string                        `json:"patientNumber"`
	Records       []database.PrecompRecordInput `json:"records"`
}

type LoadResponse struct {
	Status  string                    `json:"status"`
	Records []model.TransactionRecord `json:"records"`
}

func SavePrecompHandler(conn *sqlx.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var payload PrecompPayload
		if err := json.NewDecoder(r.Body).Decode(&payload); err != nil {
			http.Error(w, "Invalid request body", http.StatusBadRequest)
			return
		}

		if payload.PatientNumber == "" {
			http.Error(w, "Patient number is required", http.StatusBadRequest)
			return
		}

		tx, err := conn.Beginx()
		if err != nil {
			http.Error(w, "Failed to start transaction", http.StatusInternalServerError)
			return
		}
		defer tx.Rollback()

		if err := database.UpsertPreCompoundingRecordsInTx(tx, payload.PatientNumber, payload.Records); err != nil {
			log.Printf("ERROR: Failed to save pre-compounding records for patient %s: %v", payload.PatientNumber, err)
			http.Error(w, "Failed to save pre-compounding records: "+err.Error(), http.StatusInternalServerError)
			return
		}

		if err := tx.Commit(); err != nil {
			http.Error(w, "Failed to commit transaction", http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]string{"message": "予製データを保存しました。"})
	}
}

func LoadPrecompHandler(conn *sqlx.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		patientNumber := r.URL.Query().Get("patientNumber")
		if patientNumber == "" {
			http.Error(w, "Patient number is required", http.StatusBadRequest)
			return
		}

		status, err := database.GetPreCompoundingStatusByPatient(conn, patientNumber)
		if err != nil {
			http.Error(w, "Failed to get pre-compounding status: "+err.Error(), http.StatusInternalServerError)
			return
		}
		records, err := database.GetPreCompoundingRecordsByPatient(conn, patientNumber)
		if err != nil {
			http.Error(w, "Failed to load pre-compounding records: "+err.Error(), http.StatusInternalServerError)
			return
		}

		response := LoadResponse{
			Status:  status,
			Records: records,
		}
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(response)
	}
}

func ClearPrecompHandler(conn *sqlx.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		patientNumber := r.URL.Query().Get("patientNumber")
		if patientNumber == "" {
			http.Error(w, "Patient number is required", http.StatusBadRequest)
			return
		}

		if err := database.DeletePreCompoundingRecordsByPatient(conn, patientNumber); err != nil {
			http.Error(w, "Failed to clear pre-compounding records: "+err.Error(), http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]string{"message": "予製データを完全に削除しました。"})
	}
}

func SuspendPrecompHandler(conn *sqlx.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var payload struct {
			PatientNumber string `json:"patientNumber"`
		}
		if err := json.NewDecoder(r.Body).Decode(&payload); err != nil {
			http.Error(w, "Invalid request body", http.StatusBadRequest)
			return
		}
		if payload.PatientNumber == "" {
			http.Error(w, "Patient number is required", http.StatusBadRequest)
			return
		}
		tx, err := conn.Beginx()
		if err != nil {
			http.Error(w, "Failed to start transaction", http.StatusInternalServerError)
			return
		}
		defer tx.Rollback()

		if err := database.SuspendPreCompoundingRecordsByPatient(tx, payload.PatientNumber); err != nil {
			http.Error(w, "Failed to suspend pre-compounding records: "+err.Error(), http.StatusInternalServerError)
			return
		}
		if err := tx.Commit(); err != nil {
			http.Error(w, "Failed to commit transaction", http.StatusInternalServerError)
			return
		}
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]string{"message": "予製を中断しました。"})
	}
}

func ResumePrecompHandler(conn *sqlx.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var payload struct {
			PatientNumber string `json:"patientNumber"`
		}
		if err := json.NewDecoder(r.Body).Decode(&payload); err != nil {
			http.Error(w, "Invalid request body", http.StatusBadRequest)
			return
		}
		if payload.PatientNumber == "" {
			http.Error(w, "Patient number is required", http.StatusBadRequest)
			return
		}
		tx, err := conn.Beginx()
		if err != nil {
			http.Error(w, "Failed to start transaction", http.StatusInternalServerError)
			return
		}
		defer tx.Rollback()

		if err := database.ResumePreCompoundingRecordsByPatient(tx, payload.PatientNumber); err != nil {
			http.Error(w, "Failed to resume pre-compounding records: "+err.Error(), http.StatusInternalServerError)
			return
		}
		if err := tx.Commit(); err != nil {
			http.Error(w, "Failed to commit transaction", http.StatusInternalServerError)
			return
		}
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]string{"message": "予製を再開しました。"})
	}
}

func GetStatusPrecompHandler(conn *sqlx.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		patientNumber := r.URL.Query().Get("patientNumber")
		if patientNumber == "" {
			http.Error(w, "Patient number is required", http.StatusBadRequest)
			return
		}

		status, err := database.GetPreCompoundingStatusByPatient(conn, patientNumber)
		if err != nil {
			http.Error(w, "Failed to get status: "+err.Error(), http.StatusInternalServerError)
			return
		}
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]string{"status": status})
	}
}

func ExportAllPrecompHandler(db *sqlx.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		records, err := database.GetAllPreCompoundingRecords(db)
		if err != nil {
			http.Error(w, "Failed to get all precomp records: "+err.Error(), http.StatusInternalServerError)
			return
		}

		var buf bytes.Buffer
		buf.Write([]byte{0xEF, 0xBB, 0xBF})
		writer := csv.NewWriter(&buf)

		header := []string{
			"patient_number", "product_code", "product_name", "quantity_jan", "unit_name",
		}
		if err := writer.Write(header); err != nil {
			http.Error(w, "Failed to write CSV header: "+err.Error(), http.StatusInternalServerError)
			return
		}

		for _, rec := range records {
			row := []string{
				rec.ClientCode,
				rec.JanCode,
				rec.ProductName,
				fmt.Sprintf("%.2f", rec.JanQuantity),
				units.ResolveName(rec.JanUnitName),
			}
			if err := writer.Write(row); err != nil {
				log.Printf("WARN: Failed to write precomp row to CSV (Patient: %s): %v", rec.ClientCode, err)
			}
		}
		writer.Flush()

		if err := writer.Error(); err != nil {
			http.Error(w, "Failed to flush CSV writer: "+err.Error(), http.StatusInternalServerError)
			return
		}

		filename := fmt.Sprintf("TKR予製データ(全件)_%s.csv", time.Now().Format("20060102"))
		w.Header().Set("Content-Type", "text/csv; charset=utf-8")
		w.Header().Set("Content-Disposition", "attachment; filename*=UTF-8''"+url.PathEscape(filename))
		w.Write(buf.Bytes())
	}
}

func ImportAllPrecompHandler(db *sqlx.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		file, _, err := r.FormFile("file")
		if err != nil {
			http.Error(w, "CSVファイルの読み取りに失敗: "+err.Error(), http.StatusBadRequest)
			return
		}
		defer file.Close()

		// ▼▼▼【ここを修正】戻り値の型を変更 ▼▼▼
		records, err := parsers.ParsePrecompCSV(file)
		if err != nil {
			// ▲▲▲【修正ここまで】▲▲▲
			http.Error(w, "CSVファイルの解析に失敗: "+err.Error(), http.StatusBadRequest)
			return
		}

		if len(records) == 0 {
			http.Error(w, "CSVから読み込むデータがありません。", http.StatusBadRequest)
			return
		}

		// ▼▼▼【ここから修正】新しい `records` スライス（ParsedPrecompCSVRecord）からマップを構築 ▼▼▼
		recordsByPatient := make(map[string][]database.PrecompRecordInput)
		for _, rec := range records {
			patientNumber := rec.PatientNumber
			recordsByPatient[patientNumber] = append(recordsByPatient[patientNumber], database.PrecompRecordInput{
				ProductCode: rec.ProductCode,
				JanQuantity: rec.JanQuantity,
			})
		}
		// ▲▲▲【修正ここまで】▲▲▲

		tx, err := db.Beginx()
		if err != nil {
			http.Error(w, "データベーストランザクションの開始に失敗: "+err.Error(), http.StatusInternalServerError)
			return
		}
		defer tx.Rollback()

		// ▼▼▼【ここから修正】`patientMap` ではなく `recordsByPatient` のキーをイテレート ▼▼▼
		processedPatients := 0
		for patientNumber, patientRecords := range recordsByPatient {

			if err := database.UpsertPreCompoundingRecordsInTx(tx, patientNumber, patientRecords); err != nil {
				http.Error(w, fmt.Sprintf("患者 %s の予製データ登録に失敗: %v", patientNumber, err), http.StatusInternalServerError)
				return
			}
			processedPatients++
		}
		// ▲▲▲【修正ここまで】▲▲▲

		if err := tx.Commit(); err != nil {
			http.Error(w, "データベースのコミットに失敗: "+err.Error(), http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]string{
			"message": fmt.Sprintf("%d名の患者の予製データをインポート（洗い替え）しました。", processedPatients),
		})
	}
}


----- C:\Users\wasab\OneDrive\デスクトップ\TKR\pricing\handler.go -----
// C:\Users\wasab\OneDrive\デスクトップ\TKR\pricing\handler.go
package pricing

import (
	"encoding/json"
	"fmt"
	"net/http"
	"sort"
	"tkr/database"
	"tkr/mappers"
	"tkr/model"

	"github.com/jmoiron/sqlx"
)

// writeJsonError はエラーレスポンスを返します
func writeJsonError(w http.ResponseWriter, message string, code int) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(code)
	json.NewEncoder(w).Encode(map[string]string{"message": message})
}

// QuoteDataWithSpec は価格比較画面用のデータ構造です
type QuoteDataWithSpec struct {
	model.ProductMaster
	FormattedPackageSpec string             `json:"formattedPackageSpec"`
	Quotes               map[string]float64 `json:"quotes"`
}

// UploadResponse はアップロード結果のデータ構造です
type UploadResponse struct {
	ProductData     []QuoteDataWithSpec `json:"productData"`
	WholesalerOrder []string            `json:"wholesalerOrder"`
}

// BulkUpdateHandler は価格比較画面からのマスター更新を処理します
func BulkUpdateHandler(db *sqlx.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var payload []model.PriceUpdate
		if err := json.NewDecoder(r.Body).Decode(&payload); err != nil {
			writeJsonError(w, "Invalid request body: "+err.Error(), http.StatusBadRequest)
			return
		}

		tx, err := db.Beginx()
		if err != nil {
			writeJsonError(w,
				"Failed to start transaction", http.StatusInternalServerError)
			return
		}
		defer tx.Rollback()

		if err := database.UpdatePricesAndSuppliersInTx(tx, payload); err != nil {
			writeJsonError(w, "Failed to update prices: "+err.Error(), http.StatusInternalServerError)
			return
		}

		if err := tx.Commit(); err != nil {
			writeJsonError(w, "Failed to commit transaction", http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]string{
			"message": fmt.Sprintf("%d件の医薬品マスターを更新しました。", len(payload)),
		})
	}
}

// GetAllMastersForPricingHandler は価格比較画面の初期表示用データを返します
func GetAllMastersForPricingHandler(db *sqlx.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		allMasters, err := database.GetAllProductMasters(db)
		if err != nil {
			writeJsonError(w, "Failed to get all product masters for pricing", http.StatusInternalServerError)
			return
		}
		allQuotes, err := database.GetAllProductQuotes(db)
		if err != nil {
			writeJsonError(w, "Failed to get product quotes", http.StatusInternalServerError)
			return
		}
		wholesalerMasterMap, err := database.GetWholesalerMap(db)
		if err != nil {
			writeJsonError(w, "卸マスタの取得に失敗しました: "+err.Error(), http.StatusInternalServerError)
			return
		}

		var wholesalerOrder []string
		for _, name := range wholesalerMasterMap {
			wholesalerOrder = append(wholesalerOrder, name)
		}
		sort.Strings(wholesalerOrder)

		responseData := make([]QuoteDataWithSpec, 0, len(allMasters))
		for _, master := range allMasters {
			view := mappers.ToProductMasterView(master)
			formattedSpec := view.FormattedPackageSpec

			quotesForThisProduct := make(map[string]float64)
			if quotes, ok :=
				allQuotes[master.ProductCode]; ok {
				for wCode, price := range quotes {
					if wName, ok := wholesalerMasterMap[wCode]; ok {
						quotesForThisProduct[wName] = price
					}
				}
			}

			responseData = append(responseData, QuoteDataWithSpec{
				ProductMaster:        *master,
				FormattedPackageSpec: formattedSpec,
				Quotes:               quotesForThisProduct,
			})
		}

		finalResponse := UploadResponse{
			ProductData:     responseData,
			WholesalerOrder: wholesalerOrder,
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(finalResponse)
	}
}


----- C:\Users\wasab\OneDrive\デスクトップ\TKR\pricing\pricing_export_handler.go -----
// C:\Users\wasab\OneDrive\デスクトップ\TKR\pricing\pricing_export_handler.go
package pricing

import (
	"encoding/csv"
	"fmt"
	"log"
	"net/http"
	"net/url"
	"strconv"
	"strings"
	"time"
	"tkr/database"
	"tkr/mappers"
	"tkr/model"

	"github.com/jmoiron/sqlx"
)

// GetExportDataHandler は見積依頼CSVを作成します
func GetExportDataHandler(db *sqlx.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		wholesalerName := r.URL.Query().Get("wholesalerName")
		unregisteredOnlyStr := r.URL.Query().Get("unregisteredOnly")
		unregisteredOnly := unregisteredOnlyStr == "true"

		if wholesalerName == "" {
			writeJsonError(w, "Wholesaler name is required", http.StatusBadRequest)
			return
		}

		allMasters, err := database.GetAllProductMasters(db)
		if err != nil {
			writeJsonError(w, "Failed to get products for export", http.StatusInternalServerError)
			return
		}

		var mastersToProcess []*model.ProductMaster
		for _, p := range allMasters {
			if strings.HasPrefix(p.ProductCode, "MA2J") {
				continue
			}
			mastersToProcess = append(mastersToProcess, p)
		}

		var dataToExport []*model.ProductMaster
		if unregisteredOnly {
			for _, p := range mastersToProcess {
				if p.SupplierWholesale == "" {

					dataToExport = append(dataToExport, p)
				}
			}
			if len(dataToExport) == 0 {
				writeJsonError(w, "未登録の品目が見つかりませんでした。", http.StatusNotFound)
				return
			}
		} else {
			dataToExport = mastersToProcess
		}

		dateStr := r.URL.Query().Get("date")
		fileType := "ALL"
		if unregisteredOnly {
			fileType = "UNREGISTERED"
		}
		fileName := fmt.Sprintf("価格見積依頼_%s_%s_%s.csv", wholesalerName, fileType, dateStr)
		fileName = url.PathEscape(fileName)

		w.Header().Set("Content-Type", "text/csv; charset=utf-8")
		w.Header().Set("Content-Disposition", "attachment; filename*=UTF-8''"+fileName)
		w.Write([]byte{0xEF, 0xBB, 0xBF})

		csvWriter := csv.NewWriter(w)
		defer csvWriter.Flush()

		headers := []string{"product_code", "product_name", "maker_name", "package_spec", "purchase_price"}
		if err := csvWriter.Write(headers); err != nil {
			log.Printf("Failed to write CSV header: %v", err)
		}

		for _, m := range dataToExport {
			view := mappers.ToProductMasterView(m)
			formattedSpec := view.FormattedPackageSpec

			record := []string{
				fmt.Sprintf("%q", m.ProductCode),
				m.ProductName,
				m.MakerName,
				formattedSpec,
				"",
			}
			if err := csvWriter.Write(record); err != nil {
				log.Printf("Failed to write product row to CSV (JAN: %s): %v", m.ProductCode, err)
			}
		}
	}
}

// BackupExportHandler は現在の納入価・卸をCSVにバックアップします
func BackupExportHandler(db *sqlx.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		allMasters, err := database.GetAllProductMasters(db)
		if err != nil {
			writeJsonError(w, "Failed to get products for backup export", http.StatusInternalServerError)
			return
		}

		now := time.Now()
		fileName := fmt.Sprintf("納入価・卸バックアップ_%s.csv", now.Format("20060102_150405"))
		fileName = url.PathEscape(fileName)

		w.Header().Set("Content-Type", "text/csv; charset=utf-8")
		w.Header().Set("Content-Disposition", "attachment; filename*=UTF-8''"+fileName)
		w.Write([]byte{0xEF, 0xBB, 0xBF})

		csvWriter := csv.NewWriter(w)
		defer csvWriter.Flush()

		headers := []string{"product_code", "product_name", "maker_name", "package_spec", "purchase_price", "supplier_wholesale"}
		if err := csvWriter.Write(headers); err != nil {
			log.Printf("Failed to write CSV header: %v", err)
		}

		for _, m := range allMasters {
			view := mappers.ToProductMasterView(m)
			formattedSpec := view.FormattedPackageSpec

			record := []string{
				fmt.Sprintf("%q", m.ProductCode),
				m.ProductName,
				m.MakerName,
				formattedSpec,
				strconv.FormatFloat(m.PurchasePrice, 'f', 2, 64),
				m.SupplierWholesale,
			}
			if err := csvWriter.Write(record); err != nil {
				log.Printf("Failed to write product row to CSV (JAN: %s): %v", m.ProductCode, err)
			}
		}
	}
}


----- C:\Users\wasab\OneDrive\デスクトップ\TKR\pricing\pricing_import_handler.go -----
// C:\Users\wasab\OneDrive\デスクトップ\TKR\pricing\pricing_import_handler.go
package pricing

import (
	"bufio"
	"encoding/csv"
	"encoding/json"
	"fmt"
	"log"
	"mime/multipart"
	"net/http"
	"strconv"
	"strings"
	"time"
	"tkr/database"
	"tkr/mappers"
	"tkr/model"

	"github.com/jmoiron/sqlx"
)

// UploadQuotesHandler は見積CSVをDBに保存し、比較データを返します
func UploadQuotesHandler(db *sqlx.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		if err := r.ParseMultipartForm(32 << 20); err != nil {
			writeJsonError(w, "File upload error", http.StatusBadRequest)
			return
		}

		wholesalerFiles := r.MultipartForm.File["files"]
		wholesalerNames := r.MultipartForm.Value["wholesalerNames"]

		if len(wholesalerFiles) != len(wholesalerNames) {
			writeJsonError(w, "File and wholesaler name mismatch", http.StatusBadRequest)
			return
		}

		wholesalerMasterMap, err := database.GetWholesalerMap(db)
		if err != nil {
			writeJsonError(w, "卸マスタの取得に失敗しました: "+err.Error(), http.StatusInternalServerError)
			return
		}
		wholesalerReverseMap := make(map[string]string)
		for code, name := range wholesalerMasterMap {
			wholesalerReverseMap[name] = code
		}

		tx, err := db.Beginx()
		if err != nil {
			writeJsonError(w, "トランザクションの開始に失敗: "+err.Error(), http.StatusInternalServerError)
			return
		}
		defer tx.Rollback()

		quoteDate := time.Now().Format("20060102")
		var wholesalerOrder []string

		for i, fileHeader := range wholesalerFiles {
			wholesalerName := wholesalerNames[i]
			wholesalerOrder = append(wholesalerOrder, wholesalerName)

			wholesalerCode, ok := wholesalerReverseMap[wholesalerName]
			if !ok {
				log.Printf("WARN: Wholesaler name '%s' not found in master.Skipping file.", wholesalerName)
				continue
			}

			if err := processQuoteFile(tx, fileHeader, wholesalerCode, quoteDate); err != nil {
				writeJsonError(w, fmt.Sprintf("ファイル '%s' の処理に失敗: %v", fileHeader.Filename, err), http.StatusInternalServerError)
				return
			}
		}

		allMasters, err := database.GetAllProductMasters(db)
		if err != nil {
			writeJsonError(w, "Failed to get all product masters", http.StatusInternalServerError)
			return
		}
		allQuotes, err := database.GetAllProductQuotes(tx)
		if err != nil {
			writeJsonError(w, "Failed to get product quotes", http.StatusInternalServerError)
			return
		}

		var responseData []QuoteDataWithSpec
		for _, master := range allMasters {
			view := mappers.ToProductMasterView(master)
			formattedSpec := view.FormattedPackageSpec

			quotesForThisProduct := make(map[string]float64)
			if quotes, ok := allQuotes[master.ProductCode]; ok {
				for wCode, price := range quotes {
					if wName, ok := wholesalerMasterMap[wCode]; ok {
						quotesForThisProduct[wName] = price
					}
				}
			}

			responseData = append(responseData, QuoteDataWithSpec{
				ProductMaster:        *master,
				FormattedPackageSpec: formattedSpec,
				Quotes:               quotesForThisProduct,
			})
		}

		if err := tx.Commit(); err != nil {
			writeJsonError(w, "トランザクションのコミットに失敗: "+err.Error(), http.StatusInternalServerError)
			return
		}

		finalResponse := UploadResponse{
			ProductData:     responseData,
			WholesalerOrder: wholesalerOrder,
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(finalResponse)
	}
}

// processQuoteFile は単一の見積CSVファイルを解析しDBに保存します
func processQuoteFile(tx *sqlx.Tx, fileHeader *multipart.FileHeader, wholesalerCode string, quoteDate string) error {
	file, err := fileHeader.Open()
	if err != nil {
		return fmt.Errorf("could not open uploaded file: %w", err)
	}
	defer file.Close()

	br := bufio.NewReader(file)
	bom, err := br.Peek(3)
	if err == nil && bom[0] == 0xef && bom[1] == 0xbb && bom[2] == 0xbf {
		br.Discard(3)
	}
	csvReader := csv.NewReader(br)
	csvReader.LazyQuotes = true
	rows, err := csvReader.ReadAll()
	if err != nil ||
		len(rows) < 1 {
		return fmt.Errorf("could not parse CSV: %w", err)
	}

	header := rows[0]
	codeIndex, priceIndex := -1, -1
	for i, h := range header {
		if h == "product_code" {
			codeIndex = i
		}
		if h == "purchase_price" {
			priceIndex = i
		}
	}
	if codeIndex == -1 ||
		priceIndex == -1 {
		return fmt.Errorf("required columns (product_code, purchase_price) not found")
	}

	var quotes []model.ProductQuote
	for _, row := range rows[1:] {
		if len(row) <= codeIndex ||
			len(row) <= priceIndex {
			continue
		}
		productCode := strings.Trim(strings.TrimSpace(row[codeIndex]), `="`)
		priceStr := row[priceIndex]
		if productCode == "" || priceStr == "" {
			continue
		}
		price, err := strconv.ParseFloat(priceStr, 64)
		if err != nil {
			continue
		}
		quotes = append(quotes, model.ProductQuote{
			ProductCode:    productCode,
			WholesalerCode: wholesalerCode,
			QuotePrice:     price,
			QuoteDate:      quoteDate,
		})
	}

	if len(quotes) > 0 {
		if err := database.UpsertProductQuotesInTx(tx, quotes); err != nil {
			return fmt.Errorf("failed to save quotes to DB: %w", err)
		}
	}
	return nil
}

// DirectImportHandler はバックアップCSVから納入価・卸を一括更新します
func DirectImportHandler(db *sqlx.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		file, _, err := r.FormFile("file")
		if err != nil {
			writeJsonError(w, "No file uploaded", http.StatusBadRequest)
			return
		}
		defer file.Close()

		br := bufio.NewReader(file)
		bom, err := br.Peek(3)
		if err == nil && bom[0] == 0xef && bom[1] == 0xbb && bom[2] == 0xbf {
			br.Discard(3)
		}
		csvReader := csv.NewReader(br)
		csvReader.LazyQuotes = true
		rows, err := csvReader.ReadAll()
		if err !=
			nil {
			writeJsonError(w, "Failed to parse CSV file: "+err.Error(), http.StatusBadRequest)
			return
		}

		var updates []model.PriceUpdate
		for i, row := range rows {
			if i == 0 {
				continue
			}
			if len(row) < 6 {
				continue
			}
			productCode := strings.Trim(strings.TrimSpace(row[0]), `="`)
			priceStr := strings.TrimSpace(row[4])
			supplierCode := strings.TrimSpace(row[5])
			if productCode == "" ||
				priceStr == "" || supplierCode == "" {
				continue
			}
			price, err := strconv.ParseFloat(priceStr, 64)
			if err != nil {
				continue
			}
			updates = append(updates, model.PriceUpdate{
				ProductCode:      productCode,
				NewPurchasePrice: price,
				NewSupplier:      supplierCode,
			})
		}

		if len(updates) == 0 {
			writeJsonError(w, "No valid data to import found in the file.", http.StatusBadRequest)
			return
		}

		tx, err := db.Beginx()
		if err != nil {
			writeJsonError(w, "Failed to start transaction", http.StatusInternalServerError)
			return
		}
		defer tx.Rollback()

		if err := database.UpdatePricesAndSuppliersInTx(tx, updates); err != nil {
			writeJsonError(w, "Failed to update prices: "+err.Error(), http.StatusInternalServerError)
			return
		}

		if err := tx.Commit(); err != nil {
			writeJsonError(w, "Failed to commit transaction", http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]string{
			"message": fmt.Sprintf("%d件の納入価と卸情報を更新しました。", len(updates)),
		})
	}
}


----- C:\Users\wasab\OneDrive\デスクトップ\TKR\product\handler.go -----
// C:\Users\wasab\OneDrive\デスクトップ\TKR\product\handler.go
package product

import (
	"database/sql"
	"encoding/json"
	"errors"
	"fmt"
	"log"
	"net/http"
	"sort"
	"strings"
	"tkr/barcode"
	"tkr/database"
	"tkr/mappers"
	"tkr/mastermanager"
	"tkr/model"

	"github.com/jmoiron/sqlx"
)

// (inputToMaster 関数は変更なし)
func inputToMaster(input model.ProductMasterInput) *model.ProductMaster {
	return &model.ProductMaster{
		ProductCode:         input.ProductCode,
		YjCode:              input.YjCode,
		Gs1Code:             input.Gs1Code,
		ProductName:         input.ProductName,
		KanaName:            input.KanaName,
		KanaNameShort:       input.KanaNameShort,
		GenericName:         input.GenericName,
		MakerName:           input.MakerName,
		Specification:       input.Specification,
		UsageClassification: input.UsageClassification,
		PackageForm:         input.PackageForm,
		YjUnitName:          input.YjUnitName,
		YjPackUnitQty:       input.YjPackUnitQty,
		JanPackInnerQty:     input.JanPackInnerQty,
		JanUnitCode:         input.JanUnitCode,
		JanPackUnitQty:      input.JanPackUnitQty,
		Origin:              input.Origin,
		NhiPrice:            input.NhiPrice,
		PurchasePrice:       input.PurchasePrice,
		FlagPoison:          input.FlagPoison,
		FlagDeleterious:     input.FlagDeleterious,
		FlagNarcotic:        input.FlagNarcotic,
		FlagPsychotropic:    input.FlagPsychotropic,
		FlagStimulant:       input.FlagStimulant,
		FlagStimulantRaw:    input.FlagStimulantRaw,
		IsOrderStopped:      input.IsOrderStopped,
		SupplierWholesale:   input.SupplierWholesale,
		GroupCode:           input.GroupCode,
		ShelfNumber:         input.ShelfNumber,
		Category:            input.Category,
		UserNotes:           input.UserNotes,
	}
}

func SearchProductsHandler(conn *sqlx.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		q := r.URL.Query()
		kanaName := q.Get("kanaName")
		dosageForm := q.Get("dosageForm")
		genericName := q.Get("genericName")
		shelfNumber := q.Get("shelfNumber")
		searchMode := q.Get("searchMode")

		productName := q.Get("productName")
		drugTypesRaw := q.Get("drugTypes")
		var drugTypes []string
		if drugTypesRaw != "" {
			drugTypes = strings.Split(drugTypesRaw, ",")
		}

		if searchMode == "inout" {
			// --- 「JCSHMSから採用」フロー (マスタ編集, 入出庫明細, 発注追加) ---

			// 1. ローカルマスタ(product_master)を先に検索してマップ化する
			//    これにより、JCSHMS側で見つかった品目がローカルにもある場合、ローカルの情報を優先できる（卸情報など）
			localMasters, err := database.GetFilteredProductMasters(conn, dosageForm, kanaName, genericName, shelfNumber, productName, drugTypes)
			if err != nil {
				http.Error(w, "Failed to search product_master: "+err.Error(), http.StatusInternalServerError)
				return
			}
			localMasterMap := make(map[string]model.ProductMaster)
			for _, m := range localMasters {
				localMasterMap[m.ProductCode] = m
			}

			// 2. 採用済みの全JANコードマップを取得 (検索条件にヒットしなくても、採用済みかどうかの判定用)
			adoptedCodeMap, err := database.GetAllAdoptedProductCodesMap(conn)
			if err != nil {
				http.Error(w, "Failed to get adopted product map: "+err.Error(), http.StatusInternalServerError)
				return
			}

			mergedResults := []model.ProductMasterView{}
			seenCodes := make(map[string]bool)

			// 3. JCSHMS から検索
			jcshmsResults, err := database.GetFilteredJcshmsInfo(conn, dosageForm, kanaName, genericName, productName, drugTypes)
			if err != nil {
				http.Error(w, "Failed to search jcshms_master: "+err.Error(), http.StatusInternalServerError)
				return
			}

			for _, jcshmsInfo := range jcshmsResults {
				jan := jcshmsInfo.ProductCode

				// ★修正ポイント: ローカルマスタに同じJANがあれば、そちらを優先して使う
				if localM, exists := localMasterMap[jan]; exists {
					view := mappers.ToProductMasterView(&localM)
					view.IsAdopted = true
					mergedResults = append(mergedResults, view)
				} else {
					// ローカルになければJCSHMSのデータを使う
					input := mastermanager.JcshmsToProductMasterInput(jcshmsInfo)
					tempMaster := inputToMaster(input)
					view := mappers.ToProductMasterView(tempMaster)

					// 採用済マップで照会 (検索条件には引っかからなかったが、実は採用済みの場合など)
					if _, ok := adoptedCodeMap[view.ProductCode]; ok {
						view.IsAdopted = true
						// ※ここで本来ならそのローカルマスタを取得すべきだが、検索条件外ならJCSHMS表示で妥協するか、
						// 個別に取得するコストを天秤にかける。
						// 基本的に「検索して追加」の場面なので、検索条件にヒットしたlocalMasterMapで十分カバーできるはず。
					} else {
						view.IsAdopted = false
					}
					mergedResults = append(mergedResults, view)
				}
				seenCodes[jan] = true
			}

			// 4. ローカルマスタのみに存在する品目（PROVISIONALなど）を追加
			for _, master := range localMasters {
				if seenCodes[master.ProductCode] {
					continue // 既に追加済みならスキップ
				}
				view := mappers.ToProductMasterView(&master)
				view.IsAdopted = true
				mergedResults = append(mergedResults, view)
				seenCodes[master.ProductCode] = true
			}

			// 5. 最終結果をソート
			sort.Slice(mergedResults, func(i, j int) bool {
				return mergedResults[i].KanaName < mergedResults[j].KanaName
			})

			w.Header().Set("Content-Type", "application/json")
			json.NewEncoder(w).Encode(mergedResults)

		} else {
			// --- 通常検索 (棚卸調整, DAT取込など) ---
			// ここは変更なし (ローカルマスタのみ検索)

			localMasters, err := database.GetFilteredProductMasters(conn, dosageForm, kanaName, genericName, shelfNumber, productName, drugTypes)
			if err != nil {
				http.Error(w, "Failed to search product_master: "+err.Error(), http.StatusInternalServerError)
				return
			}

			results := make([]model.ProductMasterView, len(localMasters))
			for i, master := range localMasters {
				view := mappers.ToProductMasterView(&master)
				view.IsAdopted = true
				results[i] = view
			}

			sort.Slice(results, func(i, j int) bool {
				return results[i].KanaName < results[j].KanaName
			})

			w.Header().Set("Content-Type", "application/json")
			json.NewEncoder(w).Encode(results)
		}
	}
}

// ... (GetProductByBarcodeHandler 以降は変更なし)
func GetProductByBarcodeHandler(conn *sqlx.DB) http.HandlerFunc {
	// (省略: 変更なし)
	return func(w http.ResponseWriter, r *http.Request) {
		rawBarcode := strings.TrimPrefix(r.URL.Path, "/api/product/by_barcode/")
		if rawBarcode == "" {
			http.Error(w, "barcode is required", http.StatusBadRequest)
			return
		}

		log.Printf("API: Received raw barcode: %s", rawBarcode)

		master, err := database.GetProductMasterByBarcode(conn, rawBarcode)
		if err != nil && !errors.Is(err, sql.ErrNoRows) {
			log.Printf("Error searching product_master by Barcode %s: %v", rawBarcode, err)
			http.Error(w, "データベースエラーが発生しました", http.StatusInternalServerError)
			return
		}

		if master != nil {
			log.Printf("Found product in product_master: %s", master.ProductName)
			masterView := mappers.ToProductMasterView(master)
			w.Header().Set("Content-Type", "application/json")
			json.NewEncoder(w).Encode(masterView)
			return
		}

		log.Printf("Product not in product_master, searching JCSHMS...")

		var jcshmsInfo *model.JcshmsInfo
		var jcshmsErr error
		var gtin14 string

		if len(rawBarcode) <= 13 {
			log.Printf("Barcode %s is JAN format. Searching JCSHMS by JAN...", rawBarcode)
			jcshmsInfo, jcshmsErr = database.GetJcshmsInfoByJan(conn, rawBarcode)
		} else {
			parsed, parseErr := barcode.Parse(rawBarcode)
			if parseErr != nil {
				http.Error(w, fmt.Sprintf("バーコード解析エラー: %v", parseErr), http.StatusBadRequest)
				return
			}
			gtin14 = parsed.Gtin14
			if gtin14 == "" {
				http.Error(w, "バーコードから製品コード(GTIN)が抽出できません", http.StatusBadRequest)
				return
			}
			log.Printf("Barcode %s is GS1 format (GTIN: %s). Searching JCSHMS by GS1...", rawBarcode, gtin14)
			jcshmsInfo, jcshmsErr = database.GetJcshmsInfoByGs1Code(conn, gtin14)
		}

		if jcshmsErr != nil {
			log.Printf("Error searching JCSHMS by Barcode %s: %v", rawBarcode, jcshmsErr)
			http.Error(w, "JCSHMSマスターの検索中にエラーが発生しました", http.StatusInternalServerError)
			return
		}

		if jcshmsInfo == nil {
			log.Printf("Product not found in JCSHMS for Barcode %s", rawBarcode)
			http.Error(w, "どのマスターにも製品が見つかりませんでした", http.StatusNotFound)
			return
		}

		log.Printf("Found product in JCSHMS: %s. Creating new master...", jcshmsInfo.ProductName)

		input := mastermanager.JcshmsToProductMasterInput(jcshmsInfo)

		if gtin14 != "" && input.Gs1Code == "" {
			input.Gs1Code = gtin14
			log.Printf("Setting Gs1Code from parsed barcode: %s", gtin14)
		}

		tx, err := conn.Beginx()
		if err != nil {
			log.Printf("Failed to begin transaction to create master: %v", err)
			http.Error(w, "トランザクションの開始に失敗しました", http.StatusInternalServerError)
			return
		}
		defer tx.Rollback()

		newMaster, err := mastermanager.UpsertProductMasterSqlx(tx, input)
		if err != nil {
			log.Printf("Failed to insert new master from JCSHMS: %v", err)
			http.Error(w, "マスターの新規作成に失敗しました", http.StatusInternalServerError)
			return
		}

		if err := tx.Commit(); err != nil {
			log.Printf("Failed to commit transaction to create master: %v", err)
			http.Error(w, "トランザクションのコミットに失敗しました", http.StatusInternalServerError)
			return
		}

		log.Printf("Successfully created new master for %s", newMaster.ProductName)
		masterView := mappers.ToProductMasterView(newMaster)
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(masterView)
	}
}

func AdoptMasterHandler(conn *sqlx.DB) http.HandlerFunc {
	// (省略: 変更なし)
	return func(w http.ResponseWriter, r *http.Request) {
		var payload struct {
			Gs1Code     string `json:"gs1Code"`
			ProductCode string `json:"productCode"`
		}
		if err := json.NewDecoder(r.Body).Decode(&payload); err != nil {
			http.Error(w, "Invalid request body", http.StatusBadRequest)
			return
		}

		if payload.Gs1Code == "" && payload.ProductCode == "" {
			http.Error(w, "gs1Code or productCode is required", http.StatusBadRequest)
			return
		}

		var jcshmsInfo *model.JcshmsInfo
		var err error

		if payload.Gs1Code != "" {
			jcshmsInfo, err = database.GetJcshmsInfoByGs1Code(conn, payload.Gs1Code)
		} else {
			jcshmsInfo, err = database.GetJcshmsInfoByJan(conn, payload.ProductCode)
		}

		if err != nil {
			log.Printf("Error searching JCSHMS for adoption by Key: %v", err)
			http.Error(w, "JCSHMSマスターの検索中にエラーが発生しました", http.StatusInternalServerError)
			return
		}

		if jcshmsInfo == nil {
			http.Error(w, "Adoption failed: Product not found in JCSHMS", http.StatusNotFound)
			return
		}

		input := mastermanager.JcshmsToProductMasterInput(jcshmsInfo)

		tx, err := conn.Beginx()
		if err != nil {
			http.Error(w, "トランザクションの開始に失敗しました", http.StatusInternalServerError)
			return
		}
		defer tx.Rollback()

		newMaster, err := mastermanager.UpsertProductMasterSqlx(tx, input)
		if err != nil {
			http.Error(w, "マスターの新規作成に失敗しました", http.StatusInternalServerError)
			return
		}

		if err := tx.Commit(); err != nil {
			http.Error(w, "トランザクションのコミットに失敗しました", http.StatusInternalServerError)
			return
		}

		log.Printf("Successfully adopted master for %s", newMaster.ProductName)
		masterView := mappers.ToProductMasterView(newMaster)
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(masterView)
	}
}


----- C:\Users\wasab\OneDrive\デスクトップ\TKR\render\renderer.go -----
// C:\Users\wasab\OneDrive\デスクトップ\TKR\render\renderer.go
package render

import (
	"fmt"
	"strconv"
	"strings"
	"tkr/model"
	"tkr/units" // TKRのunitsパッケージをインポート
)

// RenderTransactionTableHTML は、トランザクションレコードのスライスからHTMLテーブル文字列を生成します。
// この関数は dat と usage の両方から呼び出される共有コンポーネントです。
func RenderTransactionTableHTML(transactions []model.TransactionRecord, wholesalerMap map[string]string) string {
	var sb strings.Builder

	sb.WriteString(`
    <thead>
     
   <tr>
            <th rowspan="2" class="col-action">－</th>
            <th class="col-date">日付</th>
            <th class="col-yj">YJ</th>
            <th colspan="2" class="col-product">製品名</th>
            <th class="col-count">個数</th>
            <th class="col-yjqty">YJ数量</th>
            <th class="col-yjpackqty">YJ包装数</th>
  
   
        <th class="col-yjunit">YJ単位</th>
            <th class="col-unitprice">単価</th>
            <th class="col-expiry">期限</th>
            <th class="col-wholesaler">卸</th>
            <th class="col-line">行</th>
        </tr>
        <tr>
            <th class="col-flag">種別</th>
        
   
  <th class="col-jan">JAN</th>
            <th class="col-package">包装</th>
            <th class="col-maker">メーカー</th>
            <th class="col-form">剤型</th>
            <th class="col-janqty">JAN数量</th>
            <th class="col-janpackqty">JAN包装数</th>
            <th class="col-janunit">JAN単位</th>
            <th class="col-amount">金額</th>
    
   
      <th class="col-lot">ロット</th>
            <th class="col-receipt">伝票番号</th>
            <th class="col-ma">MA</th>
        </tr>
    </thead>`)

	sb.WriteString(`<tbody>`)
	if len(transactions) == 0 {
		sb.WriteString(`<tr><td colspan="13">登録されたデータはありません。</td></tr>`)
	} else {
		for _, tx := range transactions {
			formattedDate := tx.TransactionDate
			formattedExpiry := tx.ExpiryDate
			formattedYjQty := strconv.FormatFloat(tx.YjQuantity, 'f', 2, 64)
			formattedUnitPrice := strconv.FormatFloat(tx.UnitPrice, 'f', 2, 64)
			formattedSubtotal := strconv.FormatFloat(tx.Subtotal, 'f', 2, 64)

			var flagText string
			switch tx.Flag {
			case 1:
				flagText = "納品"
			case 2:
				flagText = "返品"
			case 3:
				flagText = "処方"
			default:
				flagText = strconv.Itoa(tx.Flag)
			}

			// 卸名をマップから取得
			var clientOrWholesalerName string
			if tx.Flag == 1 || tx.Flag == 2 { // 納品・返品
				if wholesalerMap != nil {
					if name, ok := wholesalerMap[tx.ClientCode]; ok {
						clientOrWholesalerName = name
					} else {
						clientOrWholesalerName = tx.ClientCode // マップにない場合はコード
					}
				} else {
					clientOrWholesalerName = tx.ClientCode // マップ自体がない
				}
			} else {
				clientOrWholesalerName = tx.ClientCode // 処方などは ClientCode をそのまま（TKRでは現状空のはず）
			}

			sb.WriteString(`<tr>`)
			sb.WriteString(`<td class="center col-action">－</td>`)
			sb.WriteString(fmt.Sprintf(`<td class="center col-date">%s</td>`, formattedDate))
			sb.WriteString(fmt.Sprintf(`<td class="col-yj">%s</td>`, tx.YjCode))
			sb.WriteString(fmt.Sprintf(`<td colspan="2" class="col-product">%s</td>`, tx.ProductName))
			sb.WriteString(fmt.Sprintf(`<td class="right col-count">%.0f</td>`, tx.DatQuantity))
			sb.WriteString(fmt.Sprintf(`<td class="right col-yjqty">%s</td>`, formattedYjQty))
			sb.WriteString(fmt.Sprintf(`<td class="right col-yjpackqty">%.0f</td>`, tx.YjPackUnitQty))
			// ▼▼▼【修正】units.ResolveName を呼び出す ▼▼▼
			sb.WriteString(fmt.Sprintf(`<td class="center col-yjunit">%s</td>`, units.ResolveName(tx.YjUnitName)))
			// ▲▲▲【修正ここまで】▲▲▲
			sb.WriteString(fmt.Sprintf(`<td class="right col-unitprice">%s</td>`, formattedUnitPrice))
			sb.WriteString(fmt.Sprintf(`<td class="center col-expiry">%s</td>`, formattedExpiry))
			sb.WriteString(fmt.Sprintf(`<td class="center col-wholesaler">%s</td>`, clientOrWholesalerName))
			sb.WriteString(fmt.Sprintf(`<td class="center col-line">%s</td>`, tx.LineNumber))
			sb.WriteString(`</tr>`)

			sb.WriteString(`<tr>`)
			sb.WriteString(`<td></td>`)
			sb.WriteString(fmt.Sprintf(`<td class="center col-flag">%s</td>`, flagText))
			sb.WriteString(fmt.Sprintf(`<td class="col-jan">%s</td>`, tx.JanCode))
			sb.WriteString(fmt.Sprintf(`<td class="col-package">%s</td>`, tx.PackageSpec))
			sb.WriteString(fmt.Sprintf(`<td class="col-maker">%s</td>`, tx.MakerName))
			sb.WriteString(`<td class="col-form"></td>`)
			sb.WriteString(fmt.Sprintf(`<td class="right col-janqty">%.2f</td>`, tx.JanQuantity))
			sb.WriteString(fmt.Sprintf(`<td class="right col-janpackqty">%.0f</td>`, tx.JanPackUnitQty))
			// ▼▼▼【修正】units.ResolveName を呼び出す ▼▼▼
			sb.WriteString(fmt.Sprintf(`<td class="center col-janunit">%s</td>`, units.ResolveName(tx.JanUnitName)))
			// ▲▲▲【修正ここまで】▲▲▲
			sb.WriteString(fmt.Sprintf(`<td class="right col-amount">%s</td>`, formattedSubtotal))
			sb.WriteString(fmt.Sprintf(`<td class="col-lot">%s</td>`, tx.LotNumber))
			sb.WriteString(fmt.Sprintf(`<td class="col-receipt">%s</td>`, tx.ReceiptNumber))
			sb.WriteString(fmt.Sprintf(`<td class="center col-ma">%s</td>`, tx.ProcessFlagMA))
			sb.WriteString(`</tr>`)
		}
	}
	sb.WriteString(`</tbody>`)

	return sb.String()
}


----- C:\Users\wasab\OneDrive\デスクトップ\TKR\reorder\backorder_service.go -----
// C:\Users\wasab\OneDrive\デスクトップ\TKR\reorder\backorder_service.go
package reorder

import (
	"fmt"
	"strings"
	"time"
	"tkr/database"
	"tkr/model"

	"github.com/jmoiron/sqlx"
)

// RegisterBackorders は発注データのリストを受け取り、共通のルールでDB（発注残）に登録します。
// DAT発注とCSV発注の両方から利用されます。
func RegisterBackorders(tx *sqlx.Tx, items []model.Backorder) error {
	if len(items) == 0 {
		return nil
	}

	today := time.Now().Format("20060102150405")
	var backordersToInsert []model.Backorder

	for _, item := range items {
		// 日付の正規化と予約判定
		isReservation := false
		orderDate := item.OrderDate

		if orderDate != "" {
			normalized := strings.ReplaceAll(orderDate, "-", "")
			normalized = strings.ReplaceAll(normalized, ":", "")
			normalized = strings.ReplaceAll(normalized, " ", "")
			normalized = strings.ReplaceAll(normalized, "T", "")

			if len(normalized) == 12 {
				normalized += "00"
			}
			orderDate = normalized

			if orderDate > today {
				isReservation = true
			}
		} else {
			orderDate = today
		}

		// 予約の場合、卸コードにサフィックスを追加
		wholesalerCode := item.WholesalerCode
		if isReservation && !strings.HasSuffix(wholesalerCode, "_RSV") {
			wholesalerCode += "_RSV"
		}

		// 登録用データの構築
		bo := item
		bo.OrderDate = orderDate
		bo.WholesalerCode = wholesalerCode

		// 発注数と残数をセット (フロントエンドから送られてきたYJ数量を使用)
		bo.OrderQuantity = bo.YjQuantity
		bo.RemainingQuantity = bo.YjQuantity

		backordersToInsert = append(backordersToInsert, bo)
	}

	if err := database.InsertBackordersInTx(tx, backordersToInsert); err != nil {
		return fmt.Errorf("failed to insert backorders: %w", err)
	}

	return nil
}


----- C:\Users\wasab\OneDrive\デスクトップ\TKR\reorder\dat_exporter.go -----
// C:\Users\wasab\OneDrive\デスクトップ\TKR\reorder\dat_exporter.go
package reorder

import (
	"bytes"
	"fmt"
	"sort"
	"time"

	"golang.org/x/text/encoding/japanese"
	"golang.org/x/text/transform"
)

// DatOrderRequest はDAT生成に必要な最小限のデータ構造です
type DatOrderRequest struct {
	JanCode        string  `json:"janCode"`
	WholesalerCode string  `json:"wholesalerCode"`
	OrderQuantity  float64 `json:"orderQuantity"` // 箱数 (画面入力値)
	KanaNameShort  string  `json:"kanaNameShort"` // 商品名
}

// DatBuilder は固定長DATデータを作成するための構造体です
type DatBuilder struct {
	pharmacyID string // 薬局ID (MedicodeUserID)
	buffer     *bytes.Buffer
}

func NewDatBuilder(pharmacyID string) *DatBuilder {
	return &DatBuilder{
		pharmacyID: pharmacyID,
		buffer:     new(bytes.Buffer),
	}
}

// convertToSJIS は文字列をShift_JISバイト列に変換します
func convertToSJIS(s string) ([]byte, error) {
	encoder := japanese.ShiftJIS.NewEncoder()
	encoded, _, err := transform.Bytes(encoder, []byte(s))
	if err != nil {
		return nil, err
	}
	return encoded, nil
}

// formatField は指定された文字列をShift_JISバイト列に変換し、
// 指定されたバイト長(byteLen)に整形（右スペース埋め/切り詰め）して返します。
func formatField(text string, byteLen int) []byte {
	// 1. そのままShift_JISバイト列へ変換
	sjisBytes, err := convertToSJIS(text)
	if err != nil {
		// 変換エラー時は安全策として空スペースで埋める
		return bytes.Repeat([]byte(" "), byteLen)
	}

	// 2. 長さ調整 (バイト数基準)
	if len(sjisBytes) > byteLen {
		// 指定長より長い場合は切り詰める
		return sjisBytes[:byteLen]
	} else if len(sjisBytes) < byteLen {
		// 指定長より短い場合は右側をスペース(0x20)で埋める
		padding := bytes.Repeat([]byte(" "), byteLen-len(sjisBytes))
		return append(sjisBytes, padding...)
	}

	// ちょうど良い長さ
	return sjisBytes
}

// S行 (ヘッダー) をバッファに書き込みます
// 構成: S10(3) + 薬局ID(10) + 卸コード(9) + 予備(1) + 伝票番号(4) + 日時(12) + "128128"(6) + 予備(83) = 128
func (b *DatBuilder) writeSRecord(wholesalerCode string, slipNumber int) {
	// 現在日時 (YYMMDDHHMMSS)
	now := time.Now().Format("060102150405")

	// 各フィールドを作成
	var record []byte
	record = append(record, []byte("S10")...)                                   // 識別 (3)
	record = append(record, formatField(b.pharmacyID, 10)...)                   // 薬局ID (10)
	record = append(record, formatField(wholesalerCode, 9)...)                  // 卸コード (9)
	record = append(record, []byte(" ")...)                                     // 予備 (1)
	record = append(record, formatField(fmt.Sprintf("%04d", slipNumber), 4)...) // 伝票番号 (4)
	record = append(record, formatField(now, 12)...)                            // 日時 (12)
	record = append(record, []byte("128128")...)                                // ブロック長 (6)

	// ここまでで 3+10+9+1+4+12+6 = 45バイト
	// 残り 128 - 45 = 83バイトをスペースで埋める
	paddingLen := 128 - len(record)
	if paddingLen > 0 {
		record = append(record, bytes.Repeat([]byte(" "), paddingLen)...)
	}

	b.buffer.Write(record)
}

// D行 (明細) をバッファに書き込みます
// 構成: D10(3) + 薬局ID(10) + 納入日(6) + 予備(10) + 商品コード(14) + 商品名(40) + 数量(10) + 予備(10) + 不明(8) + 予備(17) = 128
func (b *DatBuilder) writeDRecord(item DatOrderRequest) {
	today := time.Now().Format("060102")

	// JANコード変換: 13桁なら先頭に '1' を付与して14桁にする
	jan := item.JanCode
	if len(jan) == 13 {
		jan = "1" + jan
	}

	// 数量変換: 整数5桁 + 小数5桁 (例: 1 -> 0000100000)
	// ここでは受け取った OrderQuantity (箱数) をそのまま使用する
	qtyVal := int(item.OrderQuantity * 100000)
	qtyStr := fmt.Sprintf("%010d", qtyVal)

	// 各フィールドを作成
	var record []byte
	record = append(record, []byte("D10")...)                 // 識別 (3)
	record = append(record, formatField(b.pharmacyID, 10)...) // 薬局ID (10)
	record = append(record, formatField(today, 6)...)         // 納入日 (6)
	record = append(record, bytes.Repeat([]byte(" "), 10)...) // 予備 (10)
	record = append(record, formatField(jan, 14)...)          // 商品コード (14)

	// KanaNameShort をそのまま使用し、Shift_JISで40バイトに収める
	record = append(record, formatField(item.KanaNameShort, 40)...)

	record = append(record, formatField(qtyStr, 10)...) // 数量 (10)

	// ★スペース (10桁)
	record = append(record, bytes.Repeat([]byte(" "), 10)...) // 予備 (10)

	record = append(record, []byte("00000000")...) // 不明 (8)

	// ここまでで 3+10+6+10+14+40+10+10+8 = 111バイト
	// 残り 128 - 111 = 17バイトをスペースで埋める
	paddingLen := 128 - len(record)
	if paddingLen > 0 {
		record = append(record, bytes.Repeat([]byte(" "), paddingLen)...)
	} else if paddingLen < 0 {
		// 万が一オーバーしていたら128バイトで切る
		record = record[:128]
	}

	b.buffer.Write(record)
}

// E行 (トレーラー) をバッファに書き込みます
// 構成: E10(3) + 総行数(6) + 明細数(6) + 予備(113) = 128
func (b *DatBuilder) writeERecord(totalLines, itemLines int) {
	// 総行数、明細数を6桁ゼロ埋め
	totalStr := fmt.Sprintf("%06d", totalLines)
	itemStr := fmt.Sprintf("%06d", itemLines)

	var record []byte
	record = append(record, []byte("E10")...)    // 識別 (3)
	record = append(record, []byte(totalStr)...) // 総行数 (6)
	record = append(record, []byte(itemStr)...)  // 明細数 (6)

	// ここまでで 3+6+6 = 15バイト
	// 残り 128 - 15 = 113バイトをスペースで埋める
	paddingLen := 128 - len(record)
	if paddingLen > 0 {
		record = append(record, bytes.Repeat([]byte(" "), paddingLen)...)
	}

	b.buffer.Write(record)
}

// GenerateFixedLengthDat は発注リクエストのリストからDATファイル(バイト列)を生成します。
func GenerateFixedLengthDat(pharmacyID string, requests []DatOrderRequest) ([]byte, error) {
	if pharmacyID == "" {
		return nil, fmt.Errorf("薬局ID(MedicodeUserID)が設定されていません")
	}

	builder := NewDatBuilder(pharmacyID)

	// 卸ごとにグルーピング
	ordersByWholesaler := make(map[string][]DatOrderRequest)
	for _, req := range requests {
		if req.WholesalerCode == "" {
			continue
		}
		ordersByWholesaler[req.WholesalerCode] = append(ordersByWholesaler[req.WholesalerCode], req)
	}

	// 卸コード順にソートして処理
	var wholesalers []string
	for w := range ordersByWholesaler {
		wholesalers = append(wholesalers, w)
	}
	sort.Strings(wholesalers)

	slipCounter := 1 // 伝票番号 (連番)

	for _, wCode := range wholesalers {
		items := ordersByWholesaler[wCode]
		if len(items) == 0 {
			continue
		}

		// S行
		builder.writeSRecord(wCode, slipCounter)

		// D行
		for _, item := range items {
			builder.writeDRecord(item)
		}

		// E行
		// 総行数 = S(1) + D(len) + E(1)
		totalLines := 1 + len(items) + 1
		builder.writeERecord(totalLines, len(items))

		slipCounter++
	}

	return builder.buffer.Bytes(), nil
}


----- C:\Users\wasab\OneDrive\デスクトップ\TKR\reorder\handler.go -----
// C:\Users\wasab\OneDrive\デスクトップ\TKR\reorder\handler.go
package reorder

import (
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"strconv"
	"strings"
	"time"
	"tkr/aggregation"
	"tkr/config"
	"tkr/database"
	"tkr/mappers"
	"tkr/model"
	"tkr/units"

	"github.com/jmoiron/sqlx"
)

type OrderCandidatesResponse struct {
	Candidates  []OrderCandidateYJGroup `json:"candidates"`
	Wholesalers []model.Wholesaler      `json:"wholesalers"`
}

type OrderCandidateYJGroup struct {
	model.StockLedgerYJGroup
	PackageLedgers []OrderCandidatePackageGroup `json:"packageLedgers"`
}

type OrderCandidatePackageGroup struct {
	model.StockLedgerPackageGroup
	Masters            []model.ProductMasterView `json:"masters"`
	ExistingBackorders []model.Backorder         `json:"existingBackorders"`
}

// 返品推奨リスト用の構造体
type ReturnCandidate struct {
	Representative   model.ProductMasterView `json:"representative"`
	ProductName      string                  `json:"productName"`
	MakerName        string                  `json:"makerName"`
	PackageForm      string                  `json:"packageForm"`
	PackageKey       string                  `json:"packageKey"`
	LastInDate       string                  `json:"lastInDate"`
	EstimatedExpiry  string                  `json:"estimatedExpiry"`
	StockQuantity    float64                 `json:"stockQuantity"`
	NhiPrice         float64                 `json:"nhiPrice"`
	MinJanPackQty    float64                 `json:"minJanPackQty"`
	Threshold        float64                 `json:"threshold"`
	ExcessQuantity   float64                 `json:"excessQuantity"`
	ReturnableBoxes  int                     `json:"returnableBoxes"`
	UnitName         string                  `json:"unitName"`
	TheoreticalStock float64                 `json:"theoreticalStock"`
}

// APIリクエスト用の拡張構造体 (CSV/DAT共通)
// フロントエンドから「箱数」と「バラ数(YJ)」の両方を受け取る
type OrderRequestItem struct {
	model.Backorder
	BoxQuantity   float64 `json:"boxQuantity"`   // DAT用: 箱数
	KanaNameShort string  `json:"kanaNameShort"` // DAT用: カナ名
}

func GenerateOrderCandidatesHandler(conn *sqlx.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		q := r.URL.Query()
		kanaName := q.Get("kanaName")
		dosageForm := q.Get("dosageForm")
		shelfNumber := q.Get("shelfNumber")
		coefficientStr := q.Get("coefficient")
		coefficient, err := strconv.ParseFloat(coefficientStr, 64)
		if err != nil {
			coefficient = 1.5
		}

		// --- 予約解除ロジック ---
		func() {
			tx, err := conn.Beginx()
			if err != nil {
				fmt.Printf("WARN: Failed to begin transaction: %v\n", err)
				return
			}
			defer func() {
				if p := recover(); p != nil {
					tx.Rollback()
				}
			}()

			nowStr := time.Now().Format("20060102150405")
			expiredReservations, err := database.GetExpiredReservationsInTx(tx, nowStr)
			if err != nil {
				fmt.Printf("WARN: Failed to get expired reservations: %v\n", err)
				tx.Rollback()
				return
			}

			if len(expiredReservations) > 0 {
				for _, res := range expiredReservations {
					if err := database.DeleteBackorderInTx(tx, res.ID); err != nil {
						fmt.Printf("WARN: Failed to delete reservation ID %d: %v\n", res.ID, err)
						tx.Rollback()
						return
					}
				}
				if err := tx.Commit(); err != nil {
					fmt.Printf("WARN: Failed to commit reservation cleanup: %v\n", err)
				} else {
					fmt.Printf("INFO: Released %d expired reservations.\n", len(expiredReservations))
				}
			} else {
				tx.Rollback()
			}
		}()

		cfg, err := config.LoadConfig()
		if err != nil {
			http.Error(w, "設定ファイルの読み込みに失敗しました: "+err.Error(), http.StatusInternalServerError)
			return
		}

		now := time.Now()
		endDate := "99991231"
		startDate := now.AddDate(0, 0, -cfg.CalculationPeriodDays)

		filters := model.AggregationFilters{
			StartDate:   startDate.Format("20060102"),
			EndDate:     endDate,
			KanaName:    kanaName,
			DosageForm:  dosageForm,
			ShelfNumber: shelfNumber,
			Coefficient: coefficient,
		}

		yjGroups, err := aggregation.GetStockLedger(conn, filters)
		if err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}

		allBackorders, err := database.GetAllBackordersList(conn)
		if err != nil {
			http.Error(w, "Failed to get backorder list", http.StatusInternalServerError)
			return
		}

		backordersByPackageKey := make(map[string][]model.Backorder)
		for _, bo := range allBackorders {
			resolvedKey := fmt.Sprintf("%s|%s|%g|%s", bo.YjCode, bo.PackageForm, bo.JanPackInnerQty, units.ResolveName(bo.YjUnitName))
			backordersByPackageKey[resolvedKey] = append(backordersByPackageKey[resolvedKey], bo)
		}

		var candidates []OrderCandidateYJGroup
		for _, group := range yjGroups {
			if group.IsReorderNeeded {
				newYjGroup := OrderCandidateYJGroup{
					StockLedgerYJGroup: group,
					PackageLedgers:     []OrderCandidatePackageGroup{},
				}

				for _, pkg := range group.PackageLedgers {
					newPkgGroup := OrderCandidatePackageGroup{
						StockLedgerPackageGroup: pkg,
						Masters:                 []model.ProductMasterView{},
						ExistingBackorders:      backordersByPackageKey[pkg.PackageKey],
					}

					for _, master := range pkg.Masters {
						masterView := mappers.ToProductMasterView(master)
						newPkgGroup.Masters = append(newPkgGroup.Masters, masterView)
					}
					newYjGroup.PackageLedgers = append(newYjGroup.PackageLedgers, newPkgGroup)
				}
				candidates = append(candidates, newYjGroup)
			}
		}

		wholesalers, err := database.GetAllWholesalers(conn)
		if err != nil {
			http.Error(w, "Failed to get wholesalers", http.StatusInternalServerError)
			return
		}

		response := OrderCandidatesResponse{
			Candidates:  candidates,
			Wholesalers: wholesalers,
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(response)
	}
}

// PlaceOrderHandler (CSV発注など、通常の発注登録)
func PlaceOrderHandler(conn *sqlx.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// ★修正: OrderRequestItem を使用するように変更
		var payload []OrderRequestItem
		if err := json.NewDecoder(r.Body).Decode(&payload); err != nil {
			http.Error(w, "Invalid request body", http.StatusBadRequest)
			return
		}

		// model.Backorder のリストに変換
		var backorders []model.Backorder
		for _, item := range payload {
			backorders = append(backorders, item.Backorder)
		}

		tx, err := conn.Beginx()
		if err != nil {
			http.Error(w, "Failed to start transaction", http.StatusInternalServerError)
			return
		}
		defer tx.Rollback()

		// 共通関数を使って登録
		if err := RegisterBackorders(tx, backorders); err != nil {
			http.Error(w, "Failed to register backorders: "+err.Error(), http.StatusInternalServerError)
			return
		}

		if err := tx.Commit(); err != nil {
			http.Error(w, "Failed to commit transaction", http.StatusInternalServerError)
			return
		}

		// 予約が含まれているかチェック (メッセージ用)
		isReservation := false
		today := time.Now().Format("20060102150405")
		for _, bo := range backorders {
			if bo.OrderDate != "" {
				normalized := strings.ReplaceAll(bo.OrderDate, "-", "")
				normalized = strings.ReplaceAll(normalized, ":", "")
				normalized = strings.ReplaceAll(normalized, " ", "")
				normalized = strings.ReplaceAll(normalized, "T", "")
				if len(normalized) == 12 {
					normalized += "00"
				}
				if normalized > today {
					isReservation = true
					break
				}
			}
		}

		msg := "発注内容を発注残として登録しました。"
		if isReservation {
			msg = "発注を予約しました。指定日時まで保留されます。"
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]string{"message": msg})
	}
}

// GenerateReturnCandidatesHandler
// 在庫過多（不動含む）の品目を検出し、返品推奨リストを作成します。
func GenerateReturnCandidatesHandler(db *sqlx.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		q := r.URL.Query()
		kanaName := q.Get("kanaName")
		dosageForm := q.Get("dosageForm")
		shelfNumber := q.Get("shelfNumber")
		coefficientStr := q.Get("coefficient")
		coefficient, err := strconv.ParseFloat(coefficientStr, 64)
		if err != nil {
			coefficient = 1.5 // デフォルト
		}

		cfg, err := config.LoadConfig()
		if err != nil {
			http.Error(w, "設定の読み込みに失敗しました", http.StatusInternalServerError)
			return
		}
		now := time.Now()
		startDate := now.AddDate(0, 0, -cfg.CalculationPeriodDays)

		// 1. 共通集計関数を呼び出す
		aggFilters := model.AggregationFilters{
			StartDate:   startDate.Format("20060102"),
			EndDate:     "99991231",
			KanaName:    kanaName,
			DosageForm:  dosageForm,
			ShelfNumber: shelfNumber,
			Coefficient: 1.0,
		}

		yjGroups, err := aggregation.GetStockLedger(db, aggFilters)
		if err != nil {
			http.Error(w, "在庫集計に失敗しました: "+err.Error(), http.StatusInternalServerError)
			return
		}

		var results []ReturnCandidate

		for _, group := range yjGroups {
			for _, pkg := range group.PackageLedgers {
				// 閾値と過剰数の計算
				threshold := (pkg.BaseReorderPoint * coefficient) + pkg.PrecompoundedTotal
				excess := pkg.EffectiveEndingBalance - threshold

				var master *model.ProductMaster
				if len(pkg.Masters) > 0 {
					master = pkg.Masters[0]
				} else {
					continue
				}

				// 最小包装単位 (JAN包装) の確認
				minJanPackQty := 0.0
				if master.JanPackUnitQty > 0 {
					minJanPackQty = master.JanPackUnitQty
				}

				// 過剰数が「最小JAN包装数量」以上の場合のみリストアップする
				if excess > 0 && (minJanPackQty == 0 || excess >= minJanPackQty) {
					// 返品可能箱数
					returnableBoxes := 0
					if minJanPackQty > 0 {
						returnableBoxes = int(excess / minJanPackQty)
					}

					lastIn := ""
					for _, t := range pkg.Transactions {
						if t.Flag == 1 || t.Flag == 11 {
							if t.TransactionDate > lastIn {
								lastIn = t.TransactionDate
							}
						}
					}

					results = append(results, ReturnCandidate{
						Representative:   mappers.ToProductMasterView(master),
						ProductName:      master.ProductName,
						MakerName:        master.MakerName,
						PackageForm:      master.PackageForm,
						PackageKey:       pkg.PackageKey,
						LastInDate:       lastIn,
						StockQuantity:    pkg.EndingBalance.(float64), // 現在在庫(生)
						TheoreticalStock: pkg.EffectiveEndingBalance,  // 発注残・予製込みの理論在庫
						Threshold:        threshold,
						ExcessQuantity:   excess,
						MinJanPackQty:    minJanPackQty,
						ReturnableBoxes:  returnableBoxes,
						UnitName:         group.YjUnitName,
						NhiPrice:         master.NhiPrice,
					})
				}
			}
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(results)
	}
}

// ExportFixedLengthDatHandler は発注データから固定長DATファイルを生成し、かつ発注残として保存します。
func ExportFixedLengthDatHandler(conn *sqlx.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		if r.Method != http.MethodPost {
			http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
			return
		}

		// 設定から薬局ID (MedicodeUserID) を取得
		cfg, err := config.LoadConfig()
		if err != nil {
			http.Error(w, "設定の読み込みに失敗しました: "+err.Error(), http.StatusInternalServerError)
			return
		}
		pharmacyID := cfg.MedicodeUserID
		if pharmacyID == "" {
			http.Error(w, "設定画面で MEDICODE ユーザーID を設定してください。", http.StatusBadRequest)
			return
		}

		// 拡張した構造体で受け取る (BoxQuantityを含む)
		var payload []OrderRequestItem
		if err := json.NewDecoder(r.Body).Decode(&payload); err != nil {
			http.Error(w, "リクエストボディの解析に失敗: "+err.Error(), http.StatusBadRequest)
			return
		}

		if len(payload) == 0 {
			http.Error(w, "発注対象データがありません。", http.StatusBadRequest)
			return
		}

		// DB保存用とDAT生成用のデータを準備
		var backorders []model.Backorder
		var datRequests []DatOrderRequest

		for _, item := range payload {
			// 卸コードがないものはスキップ (DBにも保存しない)
			if item.WholesalerCode == "" {
				continue
			}

			// 1. DB保存用 (発注残) -> model.Backorder
			// フロントエンドで計算済みの YJQuantity をそのまま使う
			backorders = append(backorders, item.Backorder)

			// 2. DAT生成用 -> DatOrderRequest
			// フロントエンドから送られてきた BoxQuantity (箱数) をそのまま使う
			datReq := DatOrderRequest{
				JanCode:        item.JanCode,
				WholesalerCode: item.WholesalerCode,
				OrderQuantity:  item.BoxQuantity, // ★箱数をセット
				KanaNameShort:  item.KanaNameShort,
			}
			datRequests = append(datRequests, datReq)
		}

		if len(backorders) == 0 {
			http.Error(w, "有効な発注データがありません（卸未設定など）。", http.StatusBadRequest)
			return
		}

		tx, err := conn.Beginx()
		if err != nil {
			http.Error(w, "トランザクション開始エラー", http.StatusInternalServerError)
			return
		}
		defer tx.Rollback()

		// ★ DBへの保存 (発注残登録)
		if err := RegisterBackorders(tx, backorders); err != nil {
			http.Error(w, "発注残の登録に失敗しました: "+err.Error(), http.StatusInternalServerError)
			return
		}

		// DAT生成
		datBytes, err := GenerateFixedLengthDat(pharmacyID, datRequests)
		if err != nil {
			http.Error(w, "DATファイルの生成に失敗: "+err.Error(), http.StatusInternalServerError)
			return
		}

		if err := tx.Commit(); err != nil {
			http.Error(w, "コミットエラー", http.StatusInternalServerError)
			return
		}

		// ファイルダウンロードとしてレスポンス
		fileName := fmt.Sprintf("ORDER_%s.DAT", time.Now().Format("20060102150405"))
		fileName = url.PathEscape(fileName)

		w.Header().Set("Content-Type", "application/octet-stream")
		w.Header().Set("Content-Disposition", "attachment; filename*=UTF-8''"+fileName)
		w.Header().Set("Content-Length", fmt.Sprintf("%d", len(datBytes)))

		w.Write(datBytes)
	}
}


----- C:\Users\wasab\OneDrive\デスクトップ\TKR\reprocess\reprocess.go -----
// C:\Users\wasab\OneDrive\デスクトップ\TKR\reprocess\reprocess.go
package reprocess

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"tkr/database" // TKRのdb
	"tkr/mappers"  // TKRのmappers
	"tkr/model"    // TKRのmodel

	"github.com/jmoiron/sqlx" // TKRは sqlx を使用
)

// ExecuteReprocess は全ての取引データを最新のマスター情報で更新します。
func ExecuteReprocess(conn *sqlx.DB) error {
	// 全ての製品マスターをメモリにロード（高速化のため）
	allMasters, err := database.GetAllProductMasters(conn) // TKRの関数呼び出し
	if err != nil {
		return fmt.Errorf("ExecuteReprocess: Failed to fetch all product masters: %w", err)
	}
	mastersMap := make(map[string]*model.ProductMaster)
	for _, m := range allMasters {
		mastersMap[m.ProductCode] = m // TKRでは ProductCode が主キー
	}

	// 全ての取引レコードを取得
	rows, err := conn.Query("SELECT " + database.TransactionColumns + " FROM transaction_records")
	if err != nil {
		return fmt.Errorf("ExecuteReprocess: Failed to fetch all transaction records: %w", err)
	}
	defer rows.Close()

	var allRecords []model.TransactionRecord
	for rows.Next() {
		rec, err := database.ScanTransactionRecord(rows) // TKRの関数呼び出し
		if err != nil {
			return fmt.Errorf("ExecuteReprocess: Failed to scan transaction record: %w", err)
		}
		allRecords = append(allRecords, *rec)
	}

	if len(allRecords) == 0 {
		log.Println("ExecuteReprocess: No transaction data to reprocess.")
		return nil
	}

	// バッチ処理で更新
	const batchSize = 500
	updatedCount := 0
	for i := 0; i < len(allRecords); i += batchSize {
		end := i + batchSize
		if end > len(allRecords) {
			end = len(allRecords)
		}
		batch := allRecords[i:end]

		tx, err := conn.Beginx() // TKRは sqlx.Tx
		if err != nil {
			return fmt.Errorf("ExecuteReprocess: Failed to start transaction: %w", err)
		}

		for _, rec := range batch {
			master, ok := mastersMap[rec.JanCode]
			if !ok {
				continue // マスターが見つからないデータはスキップ
			}

			// 1. 最新のマスター情報をレコードにマッピング (TKRの関数名に変更)
			mappers.MapMasterToTransaction(&rec, master)

			// 2. 数量の再計算（マスターの包装規格変更への対応）
			// DAT数量(箱数)がある場合は、それを正としてYJ/JAN数量を再計算する
			if rec.DatQuantity > 0 && master.YjPackUnitQty > 0 {
				// (A) DAT数量(箱数)が存在する場合（DAT取込データ）
				// YJ数量 = DAT数量(箱数) * YJ包装数
				rec.YjQuantity = rec.DatQuantity * master.YjPackUnitQty

				// JAN数量 = YJ数量 / JAN包装内入数
				if master.JanPackInnerQty > 0 {
					rec.JanQuantity = rec.YjQuantity / master.JanPackInnerQty
				} else {
					rec.JanQuantity = 0 // 復旧不可
				}

			} else if rec.JanQuantity > 0 && master.JanPackInnerQty > 0 {
				// (B) JAN数量のみ存在する場合（入出庫データなど）
				rec.YjQuantity = rec.JanQuantity * master.JanPackInnerQty
			} else if rec.YjQuantity > 0 && rec.JanQuantity == 0 && master.JanPackInnerQty > 0 {
				// (C) YJ数量のみ存在する場合（処方データなど）
				rec.JanQuantity = rec.YjQuantity / master.JanPackInnerQty
			}
			// (D) すべて0の場合は、0のまま

			// 3. 金額を再計算 (TKRのFlag定義に合わせてロジックを分岐)
			switch rec.Flag {
			case 1, 2: // 納品(1), 返品(2) -> DAT由来
				// ▼▼▼【修正】DAT由来の納品・返品データは金額を再計算しない ▼▼▼
				// DATファイルの値が正であるため、マスタの薬価等を適用して書き換えることはしない。
				// 何もしない (break不要、処理をスキップ)

			case 0, 3: // 棚卸(0), 処方(3)
				rec.UnitPrice = master.NhiPrice // 薬価を単価とする
				rec.Subtotal = rec.YjQuantity * rec.UnitPrice

			default: // その他 (入庫 11, 出庫 12 など)
				// ユーザー指示：入出庫は薬価ベースで計算してOK
				rec.UnitPrice = master.NhiPrice
				rec.Subtotal = rec.YjQuantity * rec.UnitPrice
			}
			// ▲▲▲【修正ここまで】▲▲▲

			// 4. 処理ステータスを更新 (TKRの定義に合わせて修正)
			if rec.ProcessFlagMA == "PRO" && master.Origin == "JCSHMS" {
				rec.ProcessFlagMA = "COM"
			}

			// 5. データベースを更新 (TKRの関数呼び出し)
			if err := database.UpdateFullTransactionInTx(tx, &rec); err != nil {
				tx.Rollback()
				return fmt.Errorf("ExecuteReprocess: Failed to update record ID %d: %w", rec.ID, err)
			}
			updatedCount++
		}

		if err := tx.Commit(); err != nil {
			tx.Rollback()
			return fmt.Errorf("ExecuteReprocess: Failed to commit transaction: %w", err)
		}
		log.Printf("ExecuteReprocess: Processed %d/%d records...", updatedCount, len(allRecords))
	}

	log.Printf("ExecuteReprocess: Successfully updated %d transaction records.", updatedCount)
	return nil
}

// ProcessTransactionsHandler は ExecuteReprocess をラップするHTTPハンドラです。
func ProcessTransactionsHandler(conn *sqlx.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		log.Println("HTTP request received: Starting reprocessing of all transactions...")
		if err := ExecuteReprocess(conn); err != nil {
			log.Printf("HTTP Reprocess Error: %v", err)
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]string{
			"message": "全取引データの再計算が完了しました。",
		})
	}
}


----- C:\Users\wasab\OneDrive\デスクトップ\TKR\stock\handler.go -----
// C:\Users\wasab\OneDrive\デスクトップ\TKR\stock\handler.go
package stock

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"

	"database/sql" // ▼▼▼【追加】sql パッケージをインポート ▼▼▼
	"strconv"      // ▼▼▼【追加】strconv パッケージをインポート ▼▼▼
	"tkr/database"
	"tkr/mappers"

	// "tkr/mastermanager" // (未使用)
	"tkr/model"
	"tkr/parsers"

	// "tkr/units" // (未使用)

	"github.com/jmoiron/sqlx"
)

// ▼▼▼【ここから削除】未使用の quoteAll 関数 ▼▼▼
/*
func quoteAll(s string) string {
	return `"` + strings.ReplaceAll(s, `"`, `""`) + `"`
}
*/
// ▲▲▲【削除ここまで】▲▲▲

// ▼▼▼ ImportTKRStockCSVHandler は変更なし (ご要望の「洗い替え」ロジックを実装済み) ▼▼▼
func ImportTKRStockCSVHandler(db *sqlx.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		if r.Method != http.MethodPost {
			http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
			return
		}

		date := r.FormValue("date") // YYYYMMDD形式
		if date == "" || len(date) != 8 {
			http.Error(w, "日付(YYYYMMDD)が不正です。", http.StatusBadRequest)
			return
		}

		file, _, err := r.FormFile("file")
		if err != nil {
			http.Error(w, "CSVファイルの読み取りに失敗: "+err.Error(), http.StatusBadRequest)
			return
		}
		defer file.Close()

		// 1. TKR独自CSVパーサーを呼ぶ (CSVに記載のあるデータ)
		csvRecords, err := parsers.ParseTKRStockCSV(file)
		if err != nil {
			http.Error(w, "CSVファイルの解析に失敗: "+err.Error(), http.StatusBadRequest)
			return
		}

		// CSVの在庫データをマップ化 (Key: PackageKey, Value: JAN数量)
		csvStockMap := make(map[string]float64)
		for _, rec := range csvRecords {
			if rec.PackageKey != "" {
				csvStockMap[rec.PackageKey] = rec.JanQuantity
			}
		}

		// 2. 棚卸日（フォーム値）と伝票番号を生成
		var dateYYMMDD string
		if len(date) >= 8 {
			dateYYMMDD = date[2:8] // "20251107" -> "251107"
		} else {
			dateYYMMDD = date
		}
		// ▼▼▼【削除】古い伝票番号プレフィックス ▼▼▼
		// receiptNumber := "MIG_TKR_" + dateYYMMDD
		// ▲▲▲【削除ここまで】▲▲▲

		tx, err := db.Beginx()
		if err != nil {
			http.Error(w, "データベーストランザクションの開始に失敗: "+err.Error(), http.StatusInternalServerError)
			return
		}
		defer tx.Rollback()

		// ▼▼▼【ここから追加】伝票番号採番ロジック (AJ/IO/ADJ と同様) ▼▼▼
		var lastSeq int
		prefix := "MG" + dateYYMMDD // プレフィックスを "MG" (2桁) に変更 (Migrate)

		var lastReceiptNumber string
		// 'MG' + yymmdd で始まる最大の伝票番号を取得
		err = tx.Get(&lastReceiptNumber, `SELECT receipt_number FROM transaction_records WHERE receipt_number LIKE ? ORDER BY receipt_number DESC LIMIT 1`, prefix+"%")
		if err != nil && err != sql.ErrNoRows {
			http.Error(w, "伝票番号の採番に失敗: "+err.Error(), http.StatusInternalServerError)
			return
		}

		lastSeq = 0
		if lastReceiptNumber != "" && len(lastReceiptNumber) == 13 { // 13桁チェック (MG+6+5)
			seqStr := lastReceiptNumber[8:] // 8文字目以降 (MG + 6桁 = 8桁)
			lastSeq, _ = strconv.Atoi(seqStr)
		}
		// ▲▲▲【追加ここまで】▲▲▲

		// 3. 【洗い替え】既存の在庫データをすべて削除
		// (package_stock と flag=0 の transaction_records)
		if err := database.ClearAllPackageStockInTx(tx); err != nil {
			http.Error(w, "既存在庫の全削除（洗い替え）に失敗: "+err.Error(), http.StatusInternalServerError)
			return
		}

		// 4. 【洗い替え】product_master から「すべての」PackageKey を取得
		allMasterKeysMap, err := database.GetAllPackageKeysFromMasters(tx)
		if err != nil {
			http.Error(w, "全マスタのPackageKey取得に失敗: "+err.Error(), http.StatusInternalServerError)
			return
		}

		// 5. すべての PackageKey をループして登録処理
		lineCounter := 0
		for key, keyInfo := range allMasterKeysMap {
			lineCounter++

			janQty := 0.0
			// CSVマップに存在するかチェック
			if csvQty, ok := csvStockMap[key]; ok {
				janQty = csvQty // 存在すればCSVの値を使用
			}
			// 存在しなければ janQty は 0.0 のまま (洗い替え)

			master := keyInfo.Representative
			if master == nil {
				log.Printf("WARN: No representative master found for PackageKey %s, skipping.", key)
				continue
			}

			yjQty := janQty * master.JanPackInnerQty

			// 5a.package_stock を更新（これが在庫の起点となる）
			if err :=
				database.UpsertPackageStockInTx(tx, key, master.YjCode, yjQty, date); err != nil {
				http.Error(w, "在庫起点(package_stock)の更新に失敗: "+err.Error(), http.StatusInternalServerError)
				return
			}

			// ▼▼▼【ここから修正】13桁の伝票番号を生成 ▼▼▼
			newSeq := lastSeq + lineCounter // 連番を計算 (i ではなく lineCounter を使用)
			receiptNumber := fmt.Sprintf("%s%05d", prefix, newSeq)
			// ▲▲▲【修正ここまで】▲▲▲

			// 5b.transaction_records に棚卸明細(flag=0)を登録
			// (期限・ロットは不明のため、代表マスターのJANで合計行を1行だけ登録)
			tr := model.TransactionRecord{
				TransactionDate: date,
				Flag:            0,
				// ▼▼▼【修正】ハイフン連結をやめ、生成した13桁の番号を使用 ▼▼▼
				ReceiptNumber: receiptNumber,
				// ▲▲▲【修正ここまで】▲▲▲
				LineNumber:  "1",
				JanCode:     master.ProductCode,
				JanQuantity: janQty,
				YjQuantity:  yjQty,
				UnitPrice:   master.NhiPrice,
				Subtotal:    yjQty * master.NhiPrice,
				ExpiryDate:  "", // 期限不明
				LotNumber:   "", // ロット不明
			}
			mappers.MapMasterToTransaction(&tr, master)

			if err := database.InsertTransactionRecord(tx, tr); err != nil {
				http.Error(w, "棚卸明細(flag=0)の挿入に失敗: "+err.Error(), http.StatusInternalServerError)
				return
			}
		}

		if err := tx.Commit(); err != nil {
			http.Error(w, "データベースのコミットに失敗: "+err.Error(), http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]interface{}{
			"message": fmt.Sprintf("在庫の洗い替えが完了しました。%d件のPackageKeyが処理されました。", len(allMasterKeysMap)),
		})
	}
}


----- C:\Users\wasab\OneDrive\デスクトップ\TKR\stock\master_migration_handler.go -----
// C:\Users\wasab\OneDrive\デスクトップ\TKR\stock\master_migration_handler.go
package stock

import (
	"bytes"
	"encoding/csv"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"net/url"
	"strconv"
	"strings"
	"time"
	"tkr/database"
	"tkr/mastermanager"
	"tkr/model"
	"tkr/parsers"

	"github.com/jmoiron/sqlx"
	// ★【残す】
	// ★【残す】
)

// ▼▼▼【ここを修正】masterCSVHeader を（再度）定義 ▼▼▼
var masterCSVHeader = []string{
	"product_code", "yj_code", "gs1_code", "product_name", "kana_name", "kana_name_short",
	"generic_name", "maker_name", "specification", "usage_classification", "package_form",
	"yj_unit_name", "yj_pack_unit_qty", "jan_pack_inner_qty", "jan_unit_code", "jan_pack_unit_qty",
	"origin", "nhi_price", "purchase_price",
	"flag_poison", "flag_deleterious", "flag_narcotic", "flag_psychotropic", "flag_stimulant", "flag_stimulant_raw",
	"is_order_stopped", "supplier_wholesale",
	"group_code", "shelf_number", "category", "user_notes",
}

// ▲▲▲【修正ここまで】▲▲▲

// ▼▼▼【ここから修正】ExportAllMastersHandler を「TKRマスタバックアップ」を出力する元のロジックに戻す ▼▼▼
func ExportAllMastersHandler(db *sqlx.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		masters, err := database.GetAllProductMasters(db)
		if err != nil {
			http.Error(w, "Failed to get all product masters: "+err.Error(), http.StatusInternalServerError)
			return
		}

		var buf bytes.Buffer
		buf.Write([]byte{0xEF, 0xBB, 0xBF}) // UTF-8 BOM

		// csv.Writer を使用して確実なCSVを生成
		writer := csv.NewWriter(&buf)

		// 1. ヘッダーを書き込む (masterCSVHeader を使用)
		if err := writer.Write(masterCSVHeader); err != nil {
			http.Error(w, "Failed to write CSV header: "+err.Error(), http.StatusInternalServerError)
			return
		}

		// 2. データを書き込む (全カラム)
		for _, m := range masters {
			record := []string{
				m.ProductCode, m.YjCode, m.Gs1Code, m.ProductName, m.KanaName, m.KanaNameShort,
				m.GenericName, m.MakerName, m.Specification, m.UsageClassification, m.PackageForm,
				m.YjUnitName,
				strconv.FormatFloat(m.YjPackUnitQty, 'f', -1, 64),
				strconv.FormatFloat(m.JanPackInnerQty, 'f', -1, 64),
				strconv.Itoa(m.JanUnitCode),
				strconv.FormatFloat(m.JanPackUnitQty, 'f', -1, 64),
				m.Origin,
				strconv.FormatFloat(m.NhiPrice, 'f', -1, 64),
				strconv.FormatFloat(m.PurchasePrice, 'f', -1, 64),
				strconv.Itoa(m.FlagPoison),
				strconv.Itoa(m.FlagDeleterious),
				strconv.Itoa(m.FlagNarcotic),
				strconv.Itoa(m.FlagPsychotropic),
				strconv.Itoa(m.FlagStimulant),
				strconv.Itoa(m.FlagStimulantRaw),
				strconv.Itoa(m.IsOrderStopped),
				m.SupplierWholesale,
				m.GroupCode, m.ShelfNumber, m.Category, m.UserNotes,
			}
			if err := writer.Write(record); err != nil {
				log.Printf("WARN: Failed to write master row to CSV (Code: %s): %v", m.ProductCode, err)
			}
		}
		writer.Flush()

		if err := writer.Error(); err != nil {
			http.Error(w, "Failed to flush CSV writer: "+err.Error(), http.StatusInternalServerError)
			return
		}

		// 3. ファイル名を「TKRマスタバックアップ...」に戻す
		filename := fmt.Sprintf("TKRマスタバックアップ_%s.csv", time.Now().Format("20060102"))
		w.Header().Set("Content-Type", "text/csv; charset=utf-8")
		w.Header().Set("Content-Disposition", "attachment; filename*=UTF-8''"+url.PathEscape(filename))
		w.Write(buf.Bytes())
	}
}

// ▲▲▲【修正ここまで】▲▲▲

// ImportAllMastersHandler はマスタCSVを読み込み、JCSHMSとマージしながらUpsertします。
func ImportAllMastersHandler(db *sqlx.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		file, _, err := r.FormFile("file")
		if err != nil {
			http.Error(w, "CSVファイルの読み取りに失敗: "+err.Error(), http.StatusBadRequest)
			return
		}
		defer file.Close()

		reader := csv.NewReader(parsers.SkipBOM(file))

		reader.LazyQuotes = true
		reader.FieldsPerRecord = -1 // ヘッダー数と一致かチェックするため

		header, err := reader.Read()
		if err == io.EOF {
			http.Error(w, "CSVファイルが空です。", http.StatusBadRequest)
			return
		}
		if err != nil {
			http.Error(w, "CSVヘッダーの読み取りに失敗: "+err.Error(), http.StatusBadRequest)
			return
		}

		colIndex := make(map[string]int, len(header))
		for i, h := range header {
			colIndex[strings.TrimSpace(h)] = i
		}

		if _, ok := colIndex["product_code"]; !ok {
			http.Error(w, "CSVヘッダーに 'product_code' が見つかりません。", http.StatusBadRequest)
			return
		}

		tx, err := db.Beginx()
		if err != nil {
			http.Error(w, "データベーストランザクションの開始に失敗: "+err.Error(), http.StatusInternalServerError)
			return
		}
		defer tx.Rollback() // コミット成功時以外は自動でロールバックされる

		var importedCount int
		var errors []string

		for {
			row, err := reader.Read()
			if err == io.EOF {
				break
			}
			if err != nil {
				log.Printf("WARN: CSV行の読み取りエラー (スキップ): %v", err)
				errors = append(errors, fmt.Sprintf("行スキップ: %v", err))
				continue
			}

			get := func(key string) string {
				if idx, ok := colIndex[key]; ok && idx < len(row) {
					return strings.TrimSpace(row[idx])
				}
				return ""
			}
			getFloat := func(key string) float64 {
				f, _ := strconv.ParseFloat(get(key), 64)
				return f
			}
			getInt := func(key string) int {
				i, _ := strconv.Atoi(get(key))
				return i
			}

			productCode := get("product_code")
			if productCode == "" {
				errors = append(errors, "行スキップ: product_code が空です。")
				continue
			}

			var input model.ProductMasterInput

			// 1. キーの特定: product_code (JAN) のみで JCSHMS を検索
			jcshmsInfo, _ := database.GetJcshmsInfoByJan(tx, productCode)
			// (gs1_code での再検索は行わない)

			// 2. ベースデータの決定
			if jcshmsInfo != nil {
				// 2A.JCSHMSに情報が見つかった場合
				input = mastermanager.JcshmsToProductMasterInput(jcshmsInfo)
				input.Origin = "JCSHMS" // JcshmsToProductMasterInput が設定するが、明示的に "JCSHMS" を維持

			} else {
				// 2B.JCSHMSに情報が見つからなかった場合
				csvProductName := get("product_name")
				dbProductName := csvProductName
				if !strings.HasPrefix(csvProductName, "◆") {
					dbProductName = "◆" + csvProductName
				}

				// ▼▼▼【ここに追加】CSVの剤型区分が空白なら「他」を設定 ▼▼▼
				csvUsageClass := get("usage_classification")
				if csvUsageClass == "" {
					csvUsageClass = "他"
				}
				// ▲▲▲【追加ここまで】▲▲▲

				input = model.ProductMasterInput{
					ProductCode: productCode,
					YjCode:      "", // 3B で設定するため、ここでは空
					Gs1Code:     get("gs1_code"),
					ProductName: dbProductName,
					KanaName:    get("kana_name"),
					// KanaNameShort: 4B で設定
					GenericName:         get("generic_name"),
					MakerName:           get("maker_name"),
					Specification:       get("specification"),
					UsageClassification: csvUsageClass, // ▼▼▼【修正】変更後の変数を設定
					PackageForm:         get("package_form"),
					YjUnitName:          get("yj_unit_name"),
					YjPackUnitQty:       getFloat("yj_pack_unit_qty"),
					JanPackInnerQty:     getFloat("jan_pack_inner_qty"),
					JanUnitCode:         getInt("jan_unit_code"),
					JanPackUnitQty:      getFloat("jan_pack_unit_qty"),
					Origin:              "PROVISIONAL",
					NhiPrice:            getFloat("nhi_price"),
					FlagPoison:          getInt("flag_poison"),
					FlagDeleterious:     getInt("flag_deleterious"),
					FlagNarcotic:        getInt("flag_narcotic"),
					FlagPsychotropic:    getInt("flag_psychotropic"),
					FlagStimulant:       getInt("flag_stimulant"),
					FlagStimulantRaw:    getInt("flag_stimulant_raw"),
				}
			}

			// 3. YJコードの処理 (CSVのYJは無視)
			if jcshmsInfo != nil {
				// 3A.JCSHMS由来の場合
				if jcshmsInfo.YjCode == "" {
					// JCSHMS由来だがYJなし (JC009が空)
					newYj, seqErr := database.NextSequenceInTx(tx, "MA2Y", "MA2Y", 8)
					if seqErr != nil {
						log.Printf("ERROR: YJコード自動採番失敗 (JCSHMS/YJ無/ProductCode: %s): %v. Rolling back...", productCode, seqErr)
						http.Error(w, "YJコードの自動採番に失敗しました: "+seqErr.Error(), http.StatusInternalServerError)
						return
					}
					input.YjCode = newYj
					// input.Origin は "JCSHMS" のまま
					log.Printf("INFO: Master import (JCSHMS item %s) had no YJ. Assigned MA2Y: %s. Origin remains JCSHMS.", productCode, newYj)
				}
				// else (jcshmsInfo.YjCode != ""):
				// JcshmsToProductMasterInput で input.YjCode に設定済みなので何もしない
			} else {
				// 3B.JCSHMSになかった場合(PROVISIONAL)
				// ▼▼▼【ここから修正】YJコードの採番ロジックを変更 ▼▼▼
				csvYjCode := get("yj_code")

				if csvYjCode == "" ||
					strings.HasPrefix(csvYjCode, "MA2Y") {
					// CSVのYJコードが空欄、または MA2Y で始まる場合のみ、自動採番
					newYj, seqErr := database.NextSequenceInTx(tx, "MA2Y", "MA2Y", 8)
					if seqErr != nil {
						log.Printf("ERROR: YJコード自動採番失敗 (PROVISIONAL/ProductCode: %s): %v. Rolling back...", productCode, seqErr)
						http.Error(w, "YJコードの自動採番に失敗しました: "+seqErr.Error(), http.StatusInternalServerError)
						return
					}
					input.YjCode = newYj
					if csvYjCode != "" {
						log.Printf("INFO: Master import (PROVISIONAL item %s) had MA2Y YJCode ('%s'). Re-assigned new YJ: %s.", productCode, csvYjCode, newYj)
					}
				} else {
					// CSVに MA2Y 以外（例: 610...）が記載されている場合は、その値を採用する
					input.YjCode = csvYjCode
					log.Printf("INFO: Master import (PROVISIONAL item %s) adopted YJCode from CSV: %s.", productCode, csvYjCode)
				}
				// ▲▲▲【修正ここまで】▲▲▲
			}

			// 4. カナ名短縮 (JC019) の処理
			csvKanaNameShort := get("kana_name_short")

			if jcshmsInfo != nil {
				// 4A.JCSHMS由来の場合
				// (input.KanaNameShort には JcshmsToProductMasterInput によって JC019 が入っている)
				if input.KanaNameShort == "" {
					// JCSHMS(JC019)が空だった場合のみ、CSVの値をフォールバックとして使用
					input.KanaNameShort = csvKanaNameShort
					// (CSVも空なら input.KanaNameShort は "" のまま)
				}
			} else {
				// 4B.JCSHMSになかった場合(PROVISIONAL)
				if csvKanaNameShort != "" {
					input.KanaNameShort = csvKanaNameShort
				} else {
					// CSVも空なら、CSVの製品名(◆なし)をフォールバック
					input.KanaNameShort = get("product_name")
				}
			}

			// 5. ユーザー設定項目の上書き (JCSHMS由来かどうかにかかわらず、CSVの値を優先)
			input.PurchasePrice = getFloat("purchase_price")
			input.IsOrderStopped = getInt("is_order_stopped")
			input.SupplierWholesale = get("supplier_wholesale")
			input.GroupCode = get("group_code")
			input.ShelfNumber = get("shelf_number")
			input.Category = get("category")
			input.UserNotes = get("user_notes")

			// 6. データベースへ保存
			if _, err := mastermanager.UpsertProductMasterSqlx(tx, input); err != nil {
				errors = append(errors, fmt.Sprintf("行 %s: DB登録失敗: %v", productCode, err))
				continue
			}
			importedCount++
		}

		// ▼▼▼【ここを修正】カウンターのリセット処理を「最後」に戻す ▼▼▼
		// ▼▼▼【修正】 seqErr -> err に変更 ▼▼▼
		if err := database.InitializeSequenceFromMaxYjCode(tx); err != nil {
			log.Printf("ERROR: Failed to re-initialize YJ (MA2Y) sequence: %v. Rolling back...", err)
			http.Error(w, "自動採番カウンター(MA2Y)のリセットに失敗しました: "+err.Error(), http.StatusInternalServerError)
			return
		}
		if err := database.InitializeSequenceFromMaxProductCode(tx); err != nil {
			log.Printf("ERROR: Failed to re-initialize JAN (MA2J) sequence: %v. Rolling back...", err)
			http.Error(w, "自動採番カウンター(MA2J)のリセットに失敗しました: "+err.Error(), http.StatusInternalServerError)
			return
		}
		// ▲▲▲【修正ここまで】▲▲▲
		// ▲▲▲【修正ここまで】▲▲▲

		if err := tx.Commit(); err != nil {
			log.Printf("ERROR: Failed to commit master import transaction: %v. Transaction was rolled back.", err)
			http.Error(w, "データベースのコミットに失敗: "+err.Error(), http.StatusInternalServerError)
			return
		}

		message := fmt.Sprintf("%d件の製品マスターをインポート（上書き/新規登録）しました。", importedCount)
		if len(errors) > 0 {
			message += fmt.Sprintf("\n%d件のエラーが発生しました: %s", len(errors), strings.Join(errors[:3], ", ")) // エラーが多すぎないよう制限
		}
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]string{"message": message})
	}
}


----- C:\Users\wasab\OneDrive\デスクトップ\TKR\units\handler.go -----
// C:\Users\wasab\OneDrive\デスクトップ\TKR\units\handler.go
package units

import (
	"encoding/json"
	"net/http"
)

// GetTaniMapHandlerは、ロード済みの単位マップを返します。
func GetTaniMapHandler() http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		if internalMap == nil {
			json.NewEncoder(w).Encode(make(map[string]string))
			return
		}
		json.NewEncoder(w).Encode(internalMap)
	}
}


----- C:\Users\wasab\OneDrive\デスクトップ\TKR\units\units.go -----
// C:\Users\wasab\OneDrive\デスクトップ\TKR\units\units.go

package units

import (
	"encoding/csv"
	"fmt"
	"io"
	"os"
	"tkr/model" // ★ TKRのモデルを参照

	"golang.org/x/text/encoding/japanese"
	"golang.org/x/text/transform"
)

var internalMap map[string]string
var reverseMap map[string]string

// FormatPackageSpecは、JCSHMSのデータから仕様通りの包装文字列を生成します。
func FormatPackageSpec(jcshms *model.JcshmsInfo) string {
	if jcshms == nil {
		return ""
	}

	yjUnitName := ResolveName(jcshms.YjUnitName)
	pkg := fmt.Sprintf("%s %g%s", jcshms.PackageForm, jcshms.YjPackUnitQty, yjUnitName)

	if jcshms.JanPackInnerQty.Valid && jcshms.JanPackUnitQty.Valid && jcshms.JanPackUnitQty.Float64 != 0 {
		resolveJanUnitName := func(code string) string {
			if code != "0" && code != "" {
				return ResolveName(code)
			}
			return "" // 0か空の場合は単位を省略
		}

		janUnitName := resolveJanUnitName(jcshms.JanUnitCode.String)

		pkg += fmt.Sprintf(" (%g%s×%g%s)",
			jcshms.JanPackInnerQty.Float64,
			yjUnitName,
			jcshms.JanPackUnitQty.Float64,
			janUnitName,
		)
	}
	return pkg
}

// (TKRには FormatSimplePackageSpec はありません)

// LoadTANIFile は SOU/TANI.CSV を読み込み、単位コードと単位名のマップをメモリにロードします。
func LoadTANIFile(path string) (map[string]string, error) {
	file, err := os.Open(path)
	if err != nil {
		return nil, fmt.Errorf("LoadTANIFile: open %s: %w", path, err)
	}
	defer file.Close()

	decoder := japanese.ShiftJIS.NewDecoder()
	reader := csv.NewReader(transform.NewReader(file, decoder))
	reader.LazyQuotes = true
	reader.FieldsPerRecord = -1

	m := make(map[string]string)
	for {
		record, err := reader.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			return nil, fmt.Errorf("LoadTANIFile: read %s: %w", path, err)
		}
		if len(record) < 2 {
			continue
		}
		code := record[0]
		name := record[1]
		m[code] = name
	}
	internalMap = m

	reverseMap = make(map[string]string)
	for code, name := range internalMap {
		reverseMap[name] = code
	}

	return m, nil
}

// ResolveName は単位コードを単位名に変換します。
func ResolveName(code string) string {
	if internalMap == nil {
		return code
	}
	if name, ok := internalMap[code]; ok {
		return name
	}
	return code
}

// ResolveCode は単位名を単位コードに変換します。
func ResolveCode(name string) string {
	if reverseMap == nil {
		return ""
	}
	if code, ok := reverseMap[name]; ok {
		return code
	}
	return ""
}


----- C:\Users\wasab\OneDrive\デスクトップ\TKR\usage\handler.go -----
// C:\Users\wasab\OneDrive\デスクトップ\TKR\usage\handler.go
package usage

import (
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"strconv"
	"strings"
	"tkr/config"
	"tkr/database"
	"tkr/mappers"
	"tkr/mastermanager"
	"tkr/model"
	"tkr/parsers"

	"github.com/jmoiron/sqlx"
)

func respondJSONError(w http.ResponseWriter, message string, statusCode int) {
	log.Println("Error response:", message)
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	json.NewEncoder(w).Encode(map[string]interface{}{
		"message": message,
		"results": []interface{}{},
	})
}

func UploadUsageHandler(db *sqlx.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {

		var processedFiles []string
		var successfullyInsertedTransactions []model.TransactionRecord
		var allResults []map[string]interface{}

		if strings.Contains(r.Header.Get("Content-Type"), "multipart/form-data") {
			// --- A. 手動アップロード (複数ファイル対応) ---
			log.Println("Processing manual USAGE file upload...")
			err := r.ParseMultipartForm(32 << 20) // 32MB
			if err != nil {
				respondJSONError(w, "File upload error: "+err.Error(), http.StatusBadRequest)
				return
			}
			defer r.MultipartForm.RemoveAll()

			for _, fileHeader := range r.MultipartForm.File["file"] {
				log.Printf("Processing file: %s", fileHeader.Filename)
				// ▼▼▼【SA4010 修正】appendの結果を再代入する ▼▼▼
				processedFiles = append(processedFiles, fileHeader.Filename)
				// ▲▲▲【修正ここまで】▲▲▲
				fileResult := map[string]interface{}{"filename": fileHeader.Filename}

				file, openErr := fileHeader.Open()
				if openErr != nil {
					log.Printf("Failed to open uploaded file %s: %v", fileHeader.Filename, openErr)
					fileResult["error"] = fmt.Sprintf("Failed to open file: %v", openErr)
					allResults = append(allResults, fileResult)
					continue
				}

				processedRecords, procErr := processUsageFile(db, file)
				file.Close() // ファイルごとに閉じる

				if procErr != nil {
					log.Printf("Failed to process USAGE file %s: %v", fileHeader.Filename, procErr)
					fileResult["error"] = fmt.Sprintf("Failed to process USAGE file: %v", procErr)
					allResults = append(allResults, fileResult)
					continue
				}

				log.Printf("Successfully processed %d records from %s", len(processedRecords), fileHeader.Filename)
				fileResult["success"] = true
				fileResult["records_parsed"] = len(processedRecords) // USAGEではパース=登録
				fileResult["records_inserted"] = len(processedRecords)
				allResults = append(allResults, fileResult)
				successfullyInsertedTransactions = append(successfullyInsertedTransactions, processedRecords...)
			}

		} else {
			// --- B. 自動アップロード (単一ファイル) ---
			log.Println("Processing automatic USAGE file import...")
			cfg, cfgErr := config.LoadConfig()
			if cfgErr != nil {
				respondJSONError(w, "設定ファイルの読み込みに失敗: "+cfgErr.Error(), http.StatusInternalServerError)
				return
			}
			if cfg.UsageFolderPath == "" {
				respondJSONError(w, "処方取込フォルダパス(usageFolderPath)が設定されていません。", http.StatusBadRequest)
				return
			}

			rawPath := cfg.UsageFolderPath
			unquotedPath := strings.Trim(strings.TrimSpace(rawPath), "\"")
			filePath := strings.ReplaceAll(unquotedPath, "\\", "/")

			log.Printf("Opening specified USAGE file: %s", filePath)
			f, fErr := os.Open(filePath)
			if fErr != nil {
				displayError := fmt.Sprintf("設定されたパスのファイルを開けませんでした。\nパス: %s\nエラー: %v", filePath, fErr)
				respondJSONError(w, displayError, http.StatusInternalServerError)
				return
			}
			defer f.Close()

			fileResult := map[string]interface{}{"filename": filePath}
			processedRecords, procErr := processUsageFile(db, f)
			if procErr != nil {
				fileResult["error"] = procErr.Error()
				allResults = append(allResults, fileResult)
			} else {
				fileResult["success"] = true
				fileResult["records_parsed"] = len(processedRecords)
				fileResult["records_inserted"] = len(processedRecords)
				allResults = append(allResults, fileResult)
				successfullyInsertedTransactions = processedRecords
			}
		}

		// --- 共通レスポンス ---
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		json.NewEncoder(w).Encode(map[string]interface{}{
			"message": fmt.Sprintf("Processed %d USAGE file(s). See results for details.", len(allResults)),
			"results": allResults,
			"records": successfullyInsertedTransactions,
		})
	}
}

func processUsageFile(db *sqlx.DB, file io.Reader) ([]model.TransactionRecord, error) {
	parsed, err := parsers.ParseUsage(file)
	if err != nil {
		return nil, fmt.Errorf("USAGEファイルの解析に失敗しました: %w", err)
	}

	filtered := removeUsageDuplicates(parsed)
	if len(filtered) == 0 {
		return []model.TransactionRecord{}, nil
	}

	tx, err := db.Beginx()
	if err != nil {
		return nil, fmt.Errorf("トランザクションの開始に失敗: %w", err)
	}
	defer tx.Rollback()

	minDate, maxDate := "99999999", "00000000"
	for _, rec := range filtered {
		if rec.Date < minDate {
			minDate = rec.Date
		}
		if rec.Date > maxDate {
			maxDate = rec.Date
		}
	}

	if err := database.DeleteUsageTransactionsInDateRange(tx, minDate, maxDate); err != nil {
		return nil, fmt.Errorf("既存の処方データ削除に失敗: %w", err)
	}

	var finalRecords []model.TransactionRecord
	for i, rec := range filtered {
		key := rec.JanCode
		if key == "" {
			key = rec.YjCode
			if key == "" {
				key = fmt.Sprintf("9999999999999%s", rec.ProductName)
			}
		}

		master, err := mastermanager.FindOrCreateMaster(tx, key, rec.ProductName)
		if err != nil {
			return nil, fmt.Errorf("マスターの特定/作成に失敗 (Key: %s, Name: %s): %w", key, rec.ProductName, err)
		}

		transaction := model.TransactionRecord{
			TransactionDate: rec.Date,
			ClientCode:      "",
			ReceiptNumber:   fmt.Sprintf("USAGE-%s", rec.Date),
			LineNumber:      strconv.Itoa(i + 1),
			Flag:            3, // 処方
			YjQuantity:      rec.YjQuantity,
		}

		if master.JanPackInnerQty > 0 {
			transaction.JanQuantity = rec.YjQuantity / master.JanPackInnerQty
		}

		transaction.UnitPrice = master.NhiPrice
		transaction.Subtotal = rec.YjQuantity * master.NhiPrice

		mappers.MapMasterToTransaction(&transaction, master)

		if err := database.InsertTransactionRecord(tx, transaction); err != nil {
			return nil, fmt.Errorf("処方レコードの挿入に失敗 (JAN: %s): %w", transaction.JanCode, err)
		}

		finalRecords = append(finalRecords, transaction)
	}

	if err := tx.Commit(); err != nil {
		return nil, fmt.Errorf("トランザクションのコミットに失敗: %w", err)
	}

	return finalRecords, nil
}

func removeUsageDuplicates(records []model.UnifiedInputRecord) []model.UnifiedInputRecord {
	seen := make(map[string]struct{})
	var result []model.UnifiedInputRecord
	for _, r := range records {
		key := fmt.Sprintf("%s|%s|%s|%s", r.Date, r.JanCode, r.YjCode, r.ProductName)
		if _, ok := seen[key]; ok {
			continue
		}
		seen[key] = struct{}{}
		result = append(result, r)
	}
	return result
}


----- C:\Users\wasab\OneDrive\デスクトップ\TKR\valuation\handler.go -----
// C:\Users\wasab\OneDrive\デスクトップ\TKR\valuation\handler.go
package valuation

import (
	"bytes"
	"database/sql"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"sort"
	"strings"
	"time"
	"tkr/aggregation"
	"tkr/config"
	"tkr/database"
	"tkr/model"
	"tkr/units"

	"github.com/jmoiron/sqlx"
)

// GetValuationHandler は在庫評価データをJSONで返します。
func GetValuationHandler(conn *sqlx.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		q := r.URL.Query()
		filters := model.ValuationFilters{
			Date:                q.Get("date"),
			KanaName:            q.Get("kanaName"),
			UsageClassification: q.Get("dosageForm"),
		}
		if filters.Date == "" {
			http.Error(w, "Date parameter is required", http.StatusBadRequest)
			return
		}

		results, err := runValuationAggregation(conn, filters)
		if err != nil {
			http.Error(w, "Failed to get inventory valuation: "+err.Error(), http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(results)
	}
}

func quoteAll(s string) string {
	return `"` + strings.ReplaceAll(s, `"`, `""`) + `"`
}

// ExportValuationCSVHandler
func ExportValuationCSVHandler(conn *sqlx.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		q := r.URL.Query()
		filters := model.ValuationFilters{
			Date:                q.Get("date"),
			KanaName:            q.Get("kanaName"),
			UsageClassification: q.Get("dosageForm"),
		}
		if filters.Date == "" {
			http.Error(w, "Date parameter is required", http.StatusBadRequest)
			return
		}

		results, err := runValuationAggregation(conn, filters)
		if err != nil {
			http.Error(w, "Failed to get inventory valuation for export: "+err.Error(), http.StatusInternalServerError)
			return
		}

		var buf bytes.Buffer
		buf.Write([]byte{0xEF, 0xBB, 0xBF}) // UTF-8 BOM

		header := []string{"PackageKey", "ProductName", "JAN数量"}
		buf.WriteString(strings.Join(header, ",") + "\r\n")

		for _, group := range results {
			for _, row := range group.DetailRows {
				var janQty float64
				if row.JanPackInnerQty > 0 {
					janQty = row.Stock / row.JanPackInnerQty
				} else {
					janQty = 0
				}

				record := []string{
					quoteAll(row.PackageKey),
					quoteAll(row.ProductName),
					quoteAll(fmt.Sprintf("%.2f", janQty)),
				}
				buf.WriteString(strings.Join(record, ",") + "\r\n")
			}
		}

		filename := fmt.Sprintf("TKR在庫データ(評価日_%s).csv", filters.Date)
		w.Header().Set("Content-Type", "text/csv; charset=utf-8")
		w.Header().Set("Content-Disposition", "attachment; filename*=UTF-8''"+url.PathEscape(filename))
		w.Write(buf.Bytes())
	}
}

func runValuationAggregation(conn *sqlx.DB, filters model.ValuationFilters) ([]database.ValuationGroup, error) {
	cfg, err := config.LoadConfig()
	if err != nil {
		return nil, fmt.Errorf("設定ファイルの読み込みに失敗: %w", err)
	}

	// 開始日は「90日前」とするが、実際の計算は PackageStock の日付に依存する
	startDate := time.Now().AddDate(0, 0, -cfg.CalculationPeriodDays).Format("20060102")

	aggFilters := model.AggregationFilters{
		StartDate:   startDate,
		EndDate:     filters.Date,
		KanaName:    filters.KanaName,
		DosageForm:  filters.UsageClassification,
		Coefficient: 1.0,
		YjCode:      "",
	}

	yjGroups, err := aggregation.GetStockLedger(conn, aggFilters)
	if err != nil {
		return nil, fmt.Errorf("failed to get stock ledger: %w", err)
	}

	if len(yjGroups) == 0 {
		return []database.ValuationGroup{}, nil
	}

	yjHasJcshmsMaster := make(map[string]bool)
	mastersByJanCode := make(map[string]*model.ProductMaster)

	for _, yjGroup := range yjGroups {
		for _, pkg := range yjGroup.PackageLedgers {
			for _, master := range pkg.Masters {
				if master.Origin == "JCSHMS" {
					yjHasJcshmsMaster[master.YjCode] = true
				}
				mastersByJanCode[master.ProductCode] = master
			}
		}
	}

	var detailRows []model.ValuationDetailRow

	for _, yjGroup := range yjGroups {
		for _, pkg := range yjGroup.PackageLedgers {
			totalStockForPackage, ok := pkg.EndingBalance.(float64)
			if !ok {
				totalStockForPackage = 0
			}

			// 在庫ゼロのスキップ処理は削除済み

			var repMaster *model.ProductMaster
			if len(pkg.Masters) > 0 {
				repMaster = pkg.Masters[0]
				for _, m := range pkg.Masters {
					if m.Origin == "JCSHMS" {
						repMaster = m
						break
					}
				}
			} else {
				continue
			}

			showAlert := false
			if repMaster.Origin != "JCSHMS" && !yjHasJcshmsMaster[repMaster.YjCode] {
				showAlert = true
			}

			tempJcshmsInfo := model.JcshmsInfo{
				PackageForm:     repMaster.PackageForm,
				YjUnitName:      repMaster.YjUnitName,
				YjPackUnitQty:   repMaster.YjPackUnitQty,
				JanPackInnerQty: sql.NullFloat64{Float64: repMaster.JanPackInnerQty, Valid: true},
				JanPackUnitQty:  sql.NullFloat64{Float64: repMaster.JanPackUnitQty, Valid: true},
				JanUnitCode:     sql.NullString{String: fmt.Sprintf("%d", repMaster.JanUnitCode), Valid: true},
			}
			spec := units.FormatPackageSpec(&tempJcshmsInfo)

			unitNhiPrice := repMaster.NhiPrice
			totalNhiValue := totalStockForPackage * unitNhiPrice
			packageNhiPrice := unitNhiPrice * repMaster.YjPackUnitQty

			var totalPurchaseValue float64
			if repMaster.YjPackUnitQty > 0 {
				unitPurchasePrice := repMaster.PurchasePrice / repMaster.YjPackUnitQty
				totalPurchaseValue = totalStockForPackage * unitPurchasePrice
			}

			detailRows = append(detailRows, model.ValuationDetailRow{
				YjCode:               repMaster.YjCode,
				ProductName:          repMaster.ProductName,
				ProductCode:          repMaster.ProductCode,
				PackageSpec:          spec,
				Stock:                totalStockForPackage,
				YjUnitName:           units.ResolveName(repMaster.YjUnitName),
				PackageNhiPrice:      packageNhiPrice,
				PackagePurchasePrice: repMaster.PurchasePrice,
				TotalNhiValue:        totalNhiValue,
				TotalPurchaseValue:   totalPurchaseValue,
				ShowAlert:            showAlert,
				PackageKey:           pkg.PackageKey,
				JanPackInnerQty:      repMaster.JanPackInnerQty,
			})
		}
	}

	resultGroups := make(map[string]*database.ValuationGroup)
	for _, row := range detailRows {
		master, ok := mastersByJanCode[row.ProductCode]
		if !ok {
			continue
		}
		uc := master.UsageClassification
		if uc == "" {
			uc = "他"
		}
		group, ok := resultGroups[uc]
		if !ok {
			group = &database.ValuationGroup{UsageClassification: uc}
			resultGroups[uc] = group
		}
		group.DetailRows = append(group.DetailRows, row)
		group.TotalNhiValue += row.TotalNhiValue
		group.TotalPurchaseValue += row.TotalPurchaseValue
	}

	order := map[string]int{"内": 1, "外": 2, "歯": 3, "注": 4, "機": 5, "他": 6}
	var finalResult []database.ValuationGroup
	for _, group := range resultGroups {
		sort.Slice(group.DetailRows, func(i, j int) bool {
			masterI, okI := mastersByJanCode[group.DetailRows[i].ProductCode]
			masterJ, okJ := mastersByJanCode[group.DetailRows[j].ProductCode]
			if !okI || !okJ {
				return group.DetailRows[i].ProductCode < group.DetailRows[j].ProductCode
			}
			return masterI.KanaName < masterJ.KanaName
		})
		finalResult = append(finalResult, *group)
	}
	sort.Slice(finalResult, func(i, j int) bool {
		prioI, okI := order[strings.TrimSpace(finalResult[i].UsageClassification)]
		if !okI {
			prioI = 7
		}
		prioJ, okJ := order[strings.TrimSpace(finalResult[j].UsageClassification)]
		if !okJ {
			prioJ = 7
		}
		return prioI < prioJ
	})

	return finalResult, nil
}


----- C:\Users\wasab\OneDrive\デスクトップ\TKR\config_handler.go -----
// C:\Users\wasab\OneDrive\デスクトップ\TKR\config_handler.go
package main

import (
	"encoding/json"
	"errors"
	"log"
	"net/http"
	"os"
	"tkr/config"
)

// ヘルパー関数: エラーをJSONで返す
func writeJSONError(w http.ResponseWriter, message string, statusCode int) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	json.NewEncoder(w).Encode(map[string]string{"message": message})
}

// GetConfigHandler は現在の設定を返します
func GetConfigHandler() http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		cfg := config.GetConfig()
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(cfg)
	}
}

// SaveConfigHandler は設定を保存します
func SaveConfigHandler() http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var newCfg config.Config
		if err := json.NewDecoder(r.Body).Decode(&newCfg); err != nil {
			writeJSONError(w, "リクエストが不正です。", http.StatusBadRequest)
			return
		}

		// フォルダパスの検証 (処方取込パス)
		if err := validateFolderPath(newCfg.UsageFolderPath); err != nil {
			writeJSONError(w, err.Error(), http.StatusBadRequest)
			return
		}

		// フォルダパスの検証 (伝票取込パス)
		if err := validateFolderPath(newCfg.DatFolderPath); err != nil {
			writeJSONError(w, err.Error(), http.StatusBadRequest)
			return
		}

		// CalculationPeriodDays はここでは検証不要 (config.SaveConfigでデフォルト値が設定される)

		if err := config.SaveConfig(newCfg); err != nil {
			log.Printf("Error saving config: %v", err)
			writeJSONError(w, "設定の保存に失敗しました。", http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]string{"message": "設定を保存しました。"})
	}
}

// フォルダパスを検証するヘルパー関数
func validateFolderPath(path string) error {
	if path == "" {
		return nil // 空の場合は検証しない
	}

	info, err := os.Stat(path)
	if err != nil {
		if os.IsNotExist(err) {
			return errors.New("指定されたフォルダパスが見つかりません: " + path)
		}
		log.Printf("Error checking folder path: %v", err)
		return errors.New("フォルダパスの確認中にエラーが発生しました。")
	}
	if !info.IsDir() {
		return errors.New("指定されたパスはフォルダではありません: " + path)
	}
	return nil
}


----- C:\Users\wasab\OneDrive\デスクトップ\TKR\main.go -----
package main

import (
	"html/template"
	"io/fs"
	"log"
	"net/http"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"strings"
	"time"

	"github.com/jmoiron/sqlx"
	_ "github.com/mattn/go-sqlite3"

	"tkr/config"
	"tkr/loader"
	"tkr/units"
)

var (
	appTemplate   *template.Template
	viewsFS       fs.FS
	searchFormsFS fs.FS
)

func main() {
	log.Println("Connecting to database...")
	dbConn, err := sqlx.Open("sqlite3", "./tkr.db?_journal_mode=WAL&_busy_timeout=5000")
	if err != nil {
		log.Fatalf("db open error: %v",
			err)
	}
	defer dbConn.Close()
	log.Println("Database connection successful.")

	if _, err := config.LoadConfig(); err != nil {
		log.Printf("WARN: Failed to load config file: %v. Using defaults.", err)
	}

	if err := loader.InitDatabase(dbConn); err != nil {
		log.Fatalf("Database initialization failed: %v", err)
	}
	log.Println("Database initialization complete.")

	if _, err := units.LoadTANIFile("SOU/TANI.CSV"); err != nil {
		log.Printf("WARN: Failed to load TANI.CSV: %v. Unit names may not display correctly.", err)
	} else {
		log.Println("Unit (TANI.CSV) master loaded successfully.")
	}

	staticFS := os.DirFS("static")
	viewsFS, err = fs.Sub(staticFS, "views")
	if err != nil {
		log.Printf("WARN: 'static/views' directory not found. Will only load index.html. %v", err)
	}

	searchFormsFS, err = fs.Sub(staticFS, "views")
	if err != nil {
		log.Fatalf("Failed to sub views directory for search forms: %v", err)
	}

	appTemplate, err = template.ParseFS(staticFS, "index.html")
	if err != nil {
		log.Fatalf("Failed to parse index.html: %v", err)
	}

	if viewsFS != nil {
		appTemplate, err = appTemplate.ParseFS(viewsFS, "*.html")
		if err != nil {
			log.Fatalf("Failed to parse views/*.html: %v", err)
		}
	}

	if searchFormsFS != nil {
		appTemplate, err = appTemplate.ParseFS(searchFormsFS, "search_form_group.html")
		if err != nil {
			log.Fatalf("Failed to parse views/search_form_group.html: %v", err)
		}
	}

	if viewsFS != nil {
		appTemplate, err = appTemplate.ParseFS(viewsFS, "common_search_modal.html")
		if err != nil {
			log.Fatalf("Failed to parse views/common_search_modal.html: %v", err)
		}
		appTemplate, err = appTemplate.ParseFS(viewsFS, "common_input_modal.html")
		if err != nil {
			log.Fatalf("Failed to parse views/common_input_modal.html: %v", err)
		}

		appTemplate, err = appTemplate.ParseFS(viewsFS, "_config_paths.html")
		if err != nil {
			log.Fatalf("Failed to parse views/_config_paths.html: %v", err)
		}
		appTemplate, err = appTemplate.ParseFS(viewsFS, "_config_aggregation.html")
		if err != nil {
			log.Fatalf("Failed to parse views/_config_aggregation.html: %v", err)
		}
		appTemplate, err = appTemplate.ParseFS(viewsFS, "_config_wholesalers.html")
		if err != nil {
			log.Fatalf("Failed to parse views/_config_wholesalers.html: %v", err)
		}
		appTemplate, err = appTemplate.ParseFS(viewsFS, "_config_migration.html")
		if err != nil {
			log.Fatalf("Failed to parse views/_config_migration.html: %v", err)
		}
	}

	log.Println("HTML templates loaded and parsed.")

	mux := http.NewServeMux()

	mux.Handle("/static/", http.StripPrefix("/static/",
		http.FileServer(http.Dir("./static"))))

	mux.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		if r.URL.Path != "/" {
			http.NotFound(w, r)
			return
		}

		viewFiles := []string{}
		if viewsFS != nil {
			files, err := fs.Glob(viewsFS, "*.html")
			if err != nil {
				log.Printf("Error globbing view files: %v", err)
				http.Error(w, "Internal Server Error", http.StatusInternalServerError)
				return
			}
			for _, file := range files {
				if file != "search_form_group.html" && file != "common_search_modal.html" && file != "common_input_modal.html" &&
					!strings.HasPrefix(file, "_config_") {
					viewFiles = append(viewFiles, file)
				}
			}
		}

		viewMap := make(map[string]template.HTML)
		for _, file := range viewFiles {
			key := strings.TrimSuffix(file, filepath.Ext(file))

			data :=
				struct {
					Prefix             string
					BarcodeFormID      string
					BarcodeFormInputID string
					SearchButtonID     string
					SearchButtonText   string
				}{}

			switch key {
			case "dat_view":
				data.Prefix = "dat_"
				data.BarcodeFormID = "dat-barcode-form"
				data.BarcodeFormInputID = "dat-search-barcode"
				data.SearchButtonID = "datOpenSearchModalBtn"
				data.SearchButtonText = "品目検索..."
			case "inventory_adjustment_view":
				data.Prefix = "ia_"
				data.BarcodeFormID = "ia-barcode-form"
				data.BarcodeFormInputID = "ia-barcode-input"
				data.SearchButtonID = "ia-search-btn"
				data.SearchButtonText = "この条件で検索"
			case "master_edit_view":
				data.Prefix = "master_"
				data.BarcodeFormID = "master-barcode-form"
				data.BarcodeFormInputID = "master-search-gs1-barcode"
				data.SearchButtonID = "masterSearchBtn"
				data.SearchButtonText = "既存マスタ検索"
			default:
				data.Prefix = ""
			}

			var viewContent strings.Builder
			if err := appTemplate.ExecuteTemplate(&viewContent, file, data); err != nil {
				log.Printf("Error executing view template %s: %v", file, err)
				http.Error(w, "Internal Server Error", http.StatusInternalServerError)
				return
			}
			viewMap[key] = template.HTML(viewContent.String())
		}

		currentVersion := time.Now().Format("20060102150405")

		w.Header().Set("Content-Type", "text/html; charset=utf-8")
		err = appTemplate.ExecuteTemplate(w, "index.html", struct {
			Views      map[string]template.HTML
			AppVersion string
		}{
			Views:      viewMap,
			AppVersion: currentVersion,
		})
		if err != nil {
			log.Printf("Error executing main template: %v", err)
		}
	})

	SetupRoutes(mux, dbConn)

	port := ":8080"
	log.Printf("Starting server on http://localhost%s", port)

	openBrowser("http://localhost:8080")

	if err := http.ListenAndServe(port, mux); err != nil {
		log.Fatalf("server start error: %v", err)
	}
}

func openBrowser(url string) {
	var err error
	switch runtime.GOOS {
	case "windows":
		err = exec.Command("rundll32", "url.dll,FileProtocolHandler", url).Start()
	case "darwin":
		err = exec.Command("open", url).Start()
	default:
		err = exec.Command("xdg-open", url).Start()
	}
	if err != nil {
		log.Printf("failed to open browser: %v", err)
	}
}


----- C:\Users\wasab\OneDrive\デスクトップ\TKR\routes.go -----
// C:\Users\wasab\OneDrive\デスクトップ\TKR\routes.go
package main

import (
	"encoding/json"
	"log"
	"net/http"
	"strings"
	"tkr/automation"
	"tkr/backorder"
	"tkr/client"
	"tkr/dat"
	"tkr/database"
	"tkr/deadstock"
	"tkr/inout"
	"tkr/inventoryadjustment"
	"tkr/loader"
	"tkr/masteredit"
	"tkr/precomp"
	"tkr/pricing"
	"tkr/product"
	"tkr/reorder"
	"tkr/reprocess"
	"tkr/stock"
	"tkr/units"
	"tkr/usage"
	"tkr/valuation"

	"github.com/jmoiron/sqlx"
)

func SetupRoutes(mux *http.ServeMux, dbConn *sqlx.DB) {

	mux.HandleFunc("/api/jcshms/", func(w http.ResponseWriter, r *http.Request) {
		janCode := strings.TrimPrefix(r.URL.Path, "/api/jcshms/")
		if janCode == "" {
			http.Error(w, "JAN code is required", http.StatusBadRequest)
			return
		}
		log.Printf("API request received for JAN: %s", janCode)
		info, err := database.GetJcshmsInfoByJan(dbConn, janCode)
		if err != nil {
			log.Printf("Error querying database for JAN %s: %v", janCode, err)
			http.Error(w, "Failed to retrieve JCSHMS info", http.StatusInternalServerError)
			return
		}
		if info == nil {
			log.Printf("JCSHMS info not found for JAN: %s", janCode)
			http.NotFound(w, r)
			return
		}
		w.Header().Set("Content-Type", "application/json")
		if err := json.NewEncoder(w).Encode(info); err != nil {
			log.Printf("Error encoding JSON response for JAN %s: %v", janCode, err)
		}
		log.Printf("Successfully returned JCSHMS info for JAN: %s", janCode)
	})

	mux.HandleFunc("/api/dat/upload", dat.UploadDatHandler(dbConn))
	mux.HandleFunc("/api/dat/search", dat.SearchDatHandler(dbConn))
	mux.HandleFunc("/api/usage/upload", usage.UploadUsageHandler(dbConn))

	mux.HandleFunc("/api/receipts/by_date", inout.GetReceiptNumbersByDateHandler(dbConn))
	mux.HandleFunc("/api/transaction/", inout.GetTransactionsByReceiptNumberHandler(dbConn))
	mux.HandleFunc("/api/inout/save", inout.SaveInOutHandler(dbConn))
	mux.HandleFunc("/api/transaction/delete/", inout.DeleteTransactionHandler(dbConn))
	mux.HandleFunc("/api/masters", masteredit.ListMastersHandler(dbConn))
	mux.HandleFunc("/api/masters/update", masteredit.UpdateMasterHandler(dbConn))

	mux.HandleFunc("/api/master/set_order_stopped", masteredit.SetOrderStoppedHandler(dbConn))
	mux.HandleFunc("/api/masters/bulk_update_shelf", masteredit.BulkUpdateShelfHandler(dbConn))

	mux.HandleFunc("/api/inventory/adjust/data", inventoryadjustment.GetInventoryDataHandler(dbConn))
	mux.HandleFunc("/api/inventory/adjust/save", inventoryadjustment.SaveInventoryDataHandler(dbConn))
	mux.HandleFunc("/api/inventory/clear_old", inventoryadjustment.ClearOldInventoryHandler(dbConn))

	mux.HandleFunc("/api/precomp/save", precomp.SavePrecompHandler(dbConn))
	mux.HandleFunc("/api/precomp/load", precomp.LoadPrecompHandler(dbConn))
	mux.HandleFunc("/api/precomp/clear", precomp.ClearPrecompHandler(dbConn))
	mux.HandleFunc("/api/precomp/suspend", precomp.SuspendPrecompHandler(dbConn))
	mux.HandleFunc("/api/precomp/resume", precomp.ResumePrecompHandler(dbConn))
	mux.HandleFunc("/api/precomp/status", precomp.GetStatusPrecompHandler(dbConn))
	mux.HandleFunc("/api/precomp/export/all", precomp.ExportAllPrecompHandler(dbConn))
	mux.HandleFunc("/api/precomp/import/all", precomp.ImportAllPrecompHandler(dbConn))

	mux.HandleFunc("/api/products/search_filtered", product.SearchProductsHandler(dbConn))
	mux.HandleFunc("/api/master/adopt", product.AdoptMasterHandler(dbConn))

	mux.HandleFunc("/api/product/by_barcode/", product.GetProductByBarcodeHandler(dbConn))
	mux.HandleFunc("/api/master/by_code/", func(w http.ResponseWriter, r *http.Request) {
		janCode := strings.TrimPrefix(r.URL.Path, "/api/master/by_code/")
		if janCode == "" {
			http.Error(w, "JAN code is required", http.StatusBadRequest)
			return
		}
		master, err := database.GetProductMasterByCode(dbConn, janCode)
		if err != nil {
			log.Printf("Error retrieving master by code %s: %v", janCode, err)
			http.Error(w, "Master not found or database error", http.StatusNotFound)
			return
		}
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(master)
	})

	mux.HandleFunc("/api/wholesalers/list", ListWholesalersHandler(dbConn))
	mux.HandleFunc("/api/wholesalers/create", CreateWholesalerHandler(dbConn))
	mux.HandleFunc("/api/wholesalers/delete/", DeleteWholesalerHandler(dbConn))
	mux.HandleFunc("/api/clients/import", client.ImportClientsHandler(dbConn))

	mux.HandleFunc("/api/clients", func(w http.ResponseWriter, r *http.Request) {
		clients, err := database.GetAllClients(dbConn)
		if err != nil {
			http.Error(w, "Failed to get clients", http.StatusInternalServerError)
			return
		}
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(clients)
	})

	mux.HandleFunc("/api/config", func(w http.ResponseWriter, r *http.Request) {
		switch r.Method {
		case http.MethodGet:
			GetConfigHandler()(w, r)
		case http.MethodPost:
			SaveConfigHandler()(w, r)
		default:
			http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
		}
	})

	mux.HandleFunc("/api/units/map", units.GetTaniMapHandler())

	mux.HandleFunc("/api/jcshms/reload", loader.ReloadJCSHMSHandler(dbConn))

	mux.HandleFunc("/api/reprocess/all", reprocess.ProcessTransactionsHandler(dbConn))

	mux.HandleFunc("/api/deadstock/list", deadstock.ListDeadStockHandler(dbConn))
	mux.HandleFunc("/api/deadstock/upload", deadstock.UploadDeadStockCSVHandler(dbConn))
	mux.HandleFunc("/api/deadstock/export", deadstock.ExportDeadStockHandler(dbConn))

	mux.HandleFunc("/api/stock/import/tkr", stock.ImportTKRStockCSVHandler(dbConn))

	mux.HandleFunc("/api/masters/export/all", stock.ExportAllMastersHandler(dbConn))
	mux.HandleFunc("/api/masters/import/all", stock.ImportAllMastersHandler(dbConn))

	mux.HandleFunc("/api/reorder/candidates", reorder.GenerateOrderCandidatesHandler(dbConn))
	mux.HandleFunc("/api/orders/place", reorder.PlaceOrderHandler(dbConn))
	mux.HandleFunc("/api/reorder/export_dat", reorder.ExportFixedLengthDatHandler(dbConn)) // ★追加
	mux.HandleFunc("/api/backorders", backorder.GetBackordersHandler(dbConn))
	mux.HandleFunc("/api/backorders/delete", backorder.DeleteBackorderHandler(dbConn))
	mux.HandleFunc("/api/backorders/bulk_delete_by_id", backorder.BulkDeleteBackordersByIDHandler(dbConn))
	mux.HandleFunc("/api/backorders/bulk_delete_by_date", backorder.BulkDeleteBackordersByDateHandler(dbConn))

	mux.HandleFunc("/api/returns/candidates", reorder.GenerateReturnCandidatesHandler(dbConn))

	mux.HandleFunc("/api/valuation", valuation.GetValuationHandler(dbConn))
	mux.HandleFunc("/api/valuation/export_csv", valuation.ExportValuationCSVHandler(dbConn))

	mux.HandleFunc("/api/pricing/all_masters", pricing.GetAllMastersForPricingHandler(dbConn))
	mux.HandleFunc("/api/pricing/export", pricing.GetExportDataHandler(dbConn))
	mux.HandleFunc("/api/pricing/upload", pricing.UploadQuotesHandler(dbConn))
	mux.HandleFunc("/api/pricing/update", pricing.BulkUpdateHandler(dbConn))
	mux.HandleFunc("/api/pricing/direct_import", pricing.DirectImportHandler(dbConn))
	mux.HandleFunc("/api/pricing/backup_export", pricing.BackupExportHandler(dbConn))

	mux.HandleFunc("/api/automation/medicode/download", automation.DownloadMedicodeDatHandler(dbConn))
}


----- C:\Users\wasab\OneDrive\デスクトップ\TKR\schema.sql -----
-- C:\Users\wasab\OneDrive\デスクトップ\TKR\schema.sql

CREATE TABLE IF NOT EXISTS product_master (
    product_code TEXT PRIMARY KEY,
    yj_code TEXT,
    gs1_code TEXT,
    product_name TEXT,
    kana_name TEXT,
    kana_name_short TEXT, -- ★ WASABIからの追加
    generic_name TEXT,    -- ★ WASABIからの追加
    maker_name TEXT,
    
specification 

TEXT,
    usage_classification TEXT,
    package_form TEXT,
    yj_unit_name TEXT,
    yj_pack_unit_qty REAL,
    jan_pack_inner_qty REAL,
    jan_unit_code INTEGER,
    jan_pack_unit_qty REAL,
    origin TEXT,
    nhi_price REAL,
    purchase_price REAL,
    flag_poison INTEGER,
    flag_deleterious INTEGER,
    flag_narcotic INTEGER,
    flag_psychotropic INTEGER,
    flag_stimulant INTEGER,
    flag_stimulant_raw INTEGER,
    is_order_stopped INTEGER DEFAULT 0,
    supplier_wholesale TEXT,
    group_code TEXT,
  
 

 shelf_number TEXT,
    category TEXT,
    user_notes TEXT
);
CREATE TABLE IF NOT EXISTS transaction_records (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  transaction_date TEXT,
  client_code TEXT,
  receipt_number TEXT,
  line_number TEXT,
  flag INTEGER,
  jan_code TEXT,
  yj_code TEXT,
  product_name TEXT,
  kana_name TEXT,
  usage_classification TEXT,
  package_form TEXT,
  package_spec TEXT,
  maker_name TEXT,
  dat_quantity REAL,
  jan_pack_inner_qty REAL,
  jan_quantity REAL,
  jan_pack_unit_qty REAL,
  jan_unit_name TEXT,
  jan_unit_code TEXT,
  yj_quantity REAL,
  yj_pack_unit_qty REAL,
  yj_unit_name TEXT,
  unit_price REAL,
  purchase_price REAL,
  supplier_wholesale TEXT,
  subtotal REAL,
  tax_amount REAL,
  
 tax_rate REAL, 
  

expiry_date TEXT,
  lot_number TEXT,
  flag_poison INTEGER,
  flag_deleterious INTEGER,
  flag_narcotic INTEGER,
  flag_psychotropic INTEGER,
  flag_stimulant INTEGER,
  flag_stimulant_raw INTEGER,
  process_flag_ma TEXT
);
CREATE TABLE IF NOT EXISTS jcshms (
  JC000 TEXT, JC001 TEXT, JC002 TEXT, JC003 TEXT, JC004 TEXT, JC005 TEXT, JC006 TEXT, JC007 TEXT, JC008 TEXT, JC009 TEXT,
  JC010 TEXT, JC011 TEXT, JC012 TEXT, JC013 TEXT, JC014 TEXT, JC015 TEXT, JC016 TEXT, JC017 TEXT, JC018 TEXT, JC019 TEXT,
  JC020 TEXT, JC021 TEXT, JC022 TEXT, JC023 TEXT, JC024 TEXT, JC025 TEXT, JC026 TEXT, JC027 TEXT, JC028 TEXT, JC029 TEXT,
  JC030 TEXT, JC031 TEXT, JC032 TEXT, JC033 TEXT, JC034 TEXT, JC035 TEXT, JC036 TEXT, JC037 TEXT, JC038 TEXT, JC039 TEXT,
  JC040 TEXT, JC041 TEXT, 
JC042 TEXT, JC043 TEXT, 

JC044 REAL, JC045 TEXT, JC046 TEXT, JC047 TEXT, JC048 TEXT, JC049 TEXT, 
  JC050 REAL, JC051 TEXT, JC052 TEXT, JC053 TEXT, JC054 TEXT, JC055 TEXT, JC056 TEXT, JC057 TEXT, JC058 TEXT, JC059 TEXT,
  JC060 TEXT, JC061 INTEGER, JC062 INTEGER, JC063 INTEGER, JC064 INTEGER, JC065 INTEGER, JC066 INTEGER, JC067 TEXT, JC068 TEXT, JC069 TEXT,
  JC070 TEXT, JC071 TEXT, JC072 TEXT, JC073 TEXT, JC074 TEXT, JC075 TEXT, JC076 TEXT, JC077 TEXT, JC078 TEXT, JC079 TEXT,
  JC080 TEXT, JC081 TEXT, JC082 TEXT, JC083 TEXT, JC084 TEXT, JC085 TEXT, JC086 TEXT, JC087 TEXT, JC088 TEXT, JC089 
TEXT,
  JC090 TEXT, 
JC091 TEXT, JC092 TEXT, JC093 TEXT, JC094 TEXT, JC095 TEXT, JC096 TEXT, JC097 TEXT, JC098 TEXT, JC099 TEXT, 
  JC100 TEXT, JC101 TEXT, JC102 TEXT, JC103 TEXT, JC104 TEXT, JC105 TEXT, JC106 TEXT, JC107 TEXT, JC108 TEXT, JC109 TEXT,
  JC110 TEXT, JC111 TEXT, JC112 TEXT, JC113 TEXT, JC114 TEXT, JC115 TEXT, JC116 TEXT, JC117 TEXT, JC118 TEXT, JC119 TEXT,
  JC120 TEXT, JC121 TEXT, JC122 TEXT, JC123 TEXT, JC124 REAL,
  PRIMARY KEY(JC000)
);
CREATE TABLE IF NOT EXISTS jancode (
  JA000 TEXT, JA001 TEXT, JA002 TEXT, JA003 TEXT, JA004 TEXT, JA005 TEXT, JA006 REAL, JA007 TEXT, JA008 REAL, JA009 TEXT,
  JA010 TEXT, JA011 TEXT, JA012 TEXT, JA013 TEXT, JA014 TEXT, JA015 TEXT, JA016 TEXT, JA017 TEXT, JA018 TEXT, JA019 TEXT,
  JA020 TEXT, JA021 TEXT, JA022 TEXT, JA023 TEXT, JA024 TEXT, JA025 TEXT, JA026 TEXT, JA027 TEXT, JA028 TEXT, JA029 TEXT,
  PRIMARY KEY(JA001)
);
CREATE INDEX IF NOT EXISTS idx_transactions_jan_code ON transaction_records (jan_code);
CREATE INDEX IF NOT EXISTS idx_transactions_date ON transaction_records (transaction_date);
CREATE INDEX IF NOT EXISTS idx_transactions_flag ON transaction_records (flag);
CREATE INDEX IF NOT EXISTS idx_product_master_kana_name ON product_master (kana_name);
CREATE INDEX IF NOT EXISTS idx_product_master_yj_code ON product_master (yj_code);
CREATE INDEX IF NOT EXISTS idx_jcshms_yj_code ON jcshms (JC009);
CREATE TABLE IF NOT EXISTS units (
    code TEXT PRIMARY KEY,
    name TEXT
);
CREATE TABLE IF NOT EXISTS medicine_data (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    yj_code TEXT UNIQUE,
    data TEXT
);
CREATE INDEX IF NOT EXISTS idx_medicine_data_yj_code ON medicine_data (yj_code);

CREATE TABLE IF NOT EXISTS price_revisions (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    revision_date TEXT NOT NULL,
    yj_code TEXT NOT NULL,
    old_price REAL,
    new_price REAL,
    UNIQUE(revision_date, yj_code)
);
CREATE TABLE IF NOT EXISTS price_history (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    yj_code TEXT NOT NULL,
    price REAL NOT NULL,
    start_date TEXT NOT NULL,
    end_date TEXT,
    UNIQUE(yj_code, start_date)
);
CREATE INDEX IF NOT EXISTS idx_price_history_yj_code ON price_history (yj_code);
CREATE INDEX IF NOT EXISTS idx_price_history_start_date ON price_history (start_date);
CREATE INDEX IF NOT EXISTS idx_price_history_end_date ON price_history (end_date);

CREATE INDEX IF NOT EXISTS idx_product_master_gs1_code ON product_master (gs1_code);
CREATE INDEX IF NOT EXISTS idx_transactions_receipt_number ON transaction_records (receipt_number);

CREATE INDEX IF NOT EXISTS idx_transactions_flag_date ON transaction_records (flag, transaction_date);
-- ▼▼▼【ここから変更】backorders テーブルに jan_code を追加 ▼▼▼
CREATE TABLE IF NOT EXISTS backorders (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  order_date TEXT NOT NULL,
  jan_code TEXT,
  yj_code TEXT NOT NULL,
  product_name TEXT,
  package_form TEXT NOT NULL,
  jan_pack_inner_qty REAL NOT NULL,
  yj_unit_name TEXT NOT NULL,
  order_quantity REAL NOT NULL,
  remaining_quantity REAL NOT NULL,
  wholesaler_code TEXT,
  yj_pack_unit_qty REAL,
  jan_pack_unit_qty REAL,
  jan_unit_code INTEGER
);
-- ▲▲▲【変更ここまで】▲▲▲ 
CREATE TABLE IF NOT EXISTS precomp_records (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  transaction_date TEXT,
  client_code TEXT,
  receipt_number TEXT,
  line_number TEXT,
  jan_code TEXT,
  yj_code TEXT,
  product_name TEXT,
  kana_name TEXT,
  usage_classification TEXT,
  package_form TEXT,
  package_spec TEXT,
  maker_name TEXT,
  jan_pack_inner_qty REAL,
  jan_quantity REAL,
  jan_pack_unit_qty REAL,
  jan_unit_name TEXT,
  jan_unit_code TEXT,
  yj_quantity REAL,
  yj_pack_unit_qty REAL,
  yj_unit_name TEXT,
  purchase_price REAL,
  supplier_wholesale TEXT,
  created_at TEXT NOT NULL,
  status TEXT NOT NULL DEFAULT 'active',
  UNIQUE(client_code, jan_code)
);
CREATE TABLE IF NOT EXISTS inventory_history (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    inventory_date TEXT NOT NULL,
    product_code TEXT NOT NULL,
    yj_code TEXT,
    product_name TEXT,
    yj_quantity REAL NOT NULL,
    yj_unit_name TEXT,
    package_spec TEXT,
    UNIQUE(inventory_date, product_code)
);
CREATE INDEX IF NOT EXISTS idx_inventory_history_date_code ON inventory_history (inventory_date, product_code);
CREATE INDEX IF NOT EXISTS idx_inventory_history_code_date ON inventory_history (product_code, inventory_date);
CREATE TABLE IF NOT EXISTS client_master (
  client_code TEXT PRIMARY KEY,
  client_name TEXT NOT NULL UNIQUE
);
CREATE TABLE IF NOT EXISTS wholesalers (
  wholesaler_code TEXT PRIMARY KEY,
  wholesaler_name TEXT NOT NULL
);
CREATE TABLE IF NOT EXISTS code_sequences (
  name TEXT PRIMARY KEY,
  last_no INTEGER NOT NULL
);
INSERT OR IGNORE INTO code_sequences(name, last_no) VALUES ('MA2Y', 0);
INSERT OR IGNORE INTO code_sequences(name, last_no) VALUES ('CL', 0);
-- ▼▼▼【ここに追加】仮ProductCode用シーケンス ▼▼▼
INSERT OR IGNORE INTO code_sequences(name, last_no) VALUES ('MA2J', 0);
-- ▲▲▲【追加ここまで】▲▲▲

-- ▼▼▼【ここから追加】見積・価格設定機能用テーブル ▼▼▼
CREATE TABLE IF NOT EXISTS product_quotes (
    product_code TEXT NOT NULL,
    wholesaler_code TEXT NOT NULL,
    quote_price REAL NOT NULL,
    quote_date TEXT NOT NULL,
    PRIMARY KEY (product_code, wholesaler_code)
);
CREATE INDEX IF NOT EXISTS idx_product_quotes_product_code ON product_quotes (product_code);
CREATE INDEX IF NOT EXISTS idx_product_quotes_wholesaler_code ON product_quotes (wholesaler_code);
-- ▲▲▲【追加ここまで】▲▲▲

-- ▼▼▼【ここから追加】包装キー単位の在庫起点テーブル ▼▼▼
CREATE TABLE IF NOT EXISTS package_stock (
  package_key TEXT PRIMARY KEY,          -- 包装キー (例: '2647709N1060|包装小|5|Ｇ')
  yj_code TEXT,                          -- 対応するYJコード (検索用)
  stock_quantity_yj REAL NOT NULL,       -- その包装キーのYJ単位での在庫量
  last_inventory_date TEXT NOT NULL      -- この在庫量が確定した最新の棚卸日 (YYYYMMDD)
);
CREATE INDEX IF NOT EXISTS idx_package_stock_yj_code ON package_stock (yj_code);
-- ▲▲▲【追加ここまで】▲▲▲

----- C:\Users\wasab\OneDrive\デスクトップ\TKR\wholesaler_handler.go -----
// C:\Users\wasab\OneDrive\デスクトップ\TKR\wholesaler_handler.go
package main

import (
	"encoding/json"
	"log"
	"net/http"
	"strings"
	"tkr/database"

	"github.com/jmoiron/sqlx"
)

// ListWholesalersHandler は卸一覧を返します
func ListWholesalersHandler(db *sqlx.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		wholesalers, err := database.GetAllWholesalers(db)
		if err != nil {
			log.Printf("Error getting all wholesalers: %v", err)
			http.Error(w, "卸一覧の取得に失敗しました。", http.StatusInternalServerError)
			return
		}
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(wholesalers)
	}
}

// CreateWholesalerHandler は新しい卸を作成します
func CreateWholesalerHandler(db *sqlx.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var input struct {
			Code string `json:"code"`
			Name string `json:"name"`
		}
		if err := json.NewDecoder(r.Body).Decode(&input); err != nil {
			http.Error(w, "リクエストが不正です。", http.StatusBadRequest)
			return
		}
		if input.Code == "" || input.Name == "" {
			http.Error(w, "卸コードと卸名は必須です。", http.StatusBadRequest)
			return
		}

		if err := database.CreateWholesaler(db, input.Code, input.Name); err != nil {
			log.Printf("Error creating wholesaler (Code: %s): %v", input.Code, err)
			http.Error(w, "卸の作成に失敗しました。", http.StatusInternalServerError)
			return
		}
		w.WriteHeader(http.StatusCreated)
		json.NewEncoder(w).Encode(map[string]string{"message": "作成しました。"})
	}
}

// DeleteWholesalerHandler は卸を削除します
func DeleteWholesalerHandler(db *sqlx.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// URLからコードを取得 (例: /api/wholesalers/DELETE/W001)
		code := strings.TrimPrefix(r.URL.Path, "/api/wholesalers/delete/")
		if code == "" {
			http.Error(w, "削除する卸コードが指定されていません。", http.StatusBadRequest)
			return
		}

		if err := database.DeleteWholesaler(db, code); err != nil {
			log.Printf("Error deleting wholesaler (Code: %s): %v", code, err)
			http.Error(w, "卸の削除に失敗しました。", http.StatusInternalServerError)
			return
		}
		w.WriteHeader(http.StatusOK)
		json.NewEncoder(w).Encode(map[string]string{"message": "削除しました。"})
	}
}


