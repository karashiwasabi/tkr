----- C:\Users\wasab\OneDrive\デスクトップ\WASABI\aggregation\handler.go -----
package aggregation

import (
	"database/sql"
	"encoding/json"
	"net/http"
	"strconv"
	"strings"
	"time" // time パッケージをインポート
	"wasabi/config"
	"wasabi/db"
	"wasabi/model"
)

/**
 * @brief 在庫元帳データ（集計結果）を取得するためのHTTPハンドラを返します。
 * @param conn データベース接続
 * @return http.HandlerFunc HTTPリクエストを処理するハンドラ関数
 * @details
 * HTTPリクエストのクエリパラメータからフィルタ条件を抽出し、
 * それに基づいて在庫元帳データを生成してJSON形式で返却します。
 * - coefficient: 発注点係数 (デフォルト: 1.5)
 * - startDate, endDate: 集計期間（設定の日数に基づいて動的に計算）
 * - kanaName: 製品名/カナ名での絞り込み
 * - drugTypes: 薬品種別での絞り込み (毒, 劇など)
 * - dosageForm: 剤型での絞り込み
 * - movementOnly: 期間内に動きがあった品目のみを対象とするか
 */
func GetAggregationHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		q := r.URL.Query()

		coefficient, err := strconv.ParseFloat(q.Get("coefficient"), 64)
		if err != nil {
			coefficient = 1.5 // Default value
		}

		// ▼▼▼【ここから修正】▼▼▼
		// 設定ファイルから集計日数を読み込む
		cfg, err := config.LoadConfig()
		if err != nil {
			http.Error(w, "設定ファイルの読み込みに失敗しました: "+err.Error(), http.StatusInternalServerError)
			return
		}

		// 日数から期間を動的に計算
		now := time.Now()
		// 終了日は無制限とするため、実質的に未来の最大値を設定
		endDate := "99991231"
		startDate := now.AddDate(0, 0, -cfg.CalculationPeriodDays)

		// フィルタ構造体に計算した値を使用する
		filters := model.AggregationFilters{
			StartDate:    startDate.Format("20060102"),
			EndDate:      endDate,
			KanaName:     q.Get("kanaName"),
			DrugTypes:    strings.Split(q.Get("drugTypes"), ","),
			DosageForm:   q.Get("dosageForm"),
			Coefficient:  coefficient,
			MovementOnly: q.Get("movementOnly") == "true",
		}
		// ▲▲▲【修正ここまで】▲▲▲

		results, err := db.GetStockLedger(conn, filters)
		if err != nil {
			http.Error(w, "Failed to get aggregated data: "+err.Error(), http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(results)
	}
}


----- C:\Users\wasab\OneDrive\デスクトップ\WASABI\backorder\handler.go -----
// C:\Users\wasab\OneDrive\デスクトップ\WASABI\backorder\handler.go

package backorder

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"net/http"
	"wasabi/db"
	"wasabi/model"
	"wasabi/units"
)

// BackorderView は発注残データを画面表示用に整形するための構造体です。
// model.Backorder の全フィールドに加え、画面表示用の包装仕様文字列を持ちます。
type BackorderView struct {
	model.Backorder
	FormattedPackageSpec string `json:"formattedPackageSpec"`
}

/**
 * @brief 全ての発注残リストを取得し、画面表示用に整形して返すためのHTTPハンドラです。
 * @param conn データベース接続
 * @return http.HandlerFunc HTTPリクエストを処理するハンドラ関数
 */
func GetBackordersHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		backorders, err := db.GetAllBackordersList(conn)
		if err != nil {
			http.Error(w, "Failed to get backorder list", http.StatusInternalServerError)
			return
		}

		backorderViews := make([]BackorderView, 0, len(backorders))
		for _, bo := range backorders {
			// unitsパッケージの関数に渡すため、一時的にJCShmsモデルの形式に変換
			tempJcshms := model.JCShms{
				JC037: bo.PackageForm,
				JC039: bo.YjUnitName,
				JC044: bo.YjPackUnitQty,
				JA006: sql.NullFloat64{Float64: bo.JanPackInnerQty, Valid: true},
				JA008: sql.NullFloat64{Float64: bo.JanPackUnitQty, Valid: true},
				JA007: sql.NullString{String: fmt.Sprintf("%d", bo.JanUnitCode), Valid: true},
			}

			formattedSpec := units.FormatSimplePackageSpec(&tempJcshms)

			backorderViews = append(backorderViews, BackorderView{
				Backorder:            bo,
				FormattedPackageSpec: formattedSpec,
			})
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(backorderViews)
	}
}

// ▼▼▼【ここから修正】▼▼▼
/**
 * @brief 単一の発注残レコードを削除するためのHTTPハンドラです。
 * @param conn データベース接続
 * @return http.HandlerFunc HTTPリクエストを処理するハンドラ関数
 * @details
 * HTTPリクエストのボディから削除対象のIDを受け取り、DBから削除します。
 */
func DeleteBackorderHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var payload struct {
			ID int `json:"id"`
		}
		if err := json.NewDecoder(r.Body).Decode(&payload); err != nil {
			http.Error(w, "Invalid request body", http.StatusBadRequest)
			return
		}

		tx, err := conn.Begin()
		if err != nil {
			http.Error(w, "Failed to start transaction", http.StatusInternalServerError)
			return
		}
		defer tx.Rollback()

		if err := db.DeleteBackorderInTx(tx, payload.ID); err != nil {
			http.Error(w, "Failed to delete backorder: "+err.Error(), http.StatusInternalServerError)
			return
		}

		if err := tx.Commit(); err != nil {
			http.Error(w, "Failed to commit transaction", http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]string{"message": "発注残を削除しました。"})
	}
}

/**
 * @brief 複数の発注残レコードを一括で削除するためのHTTPハンドラです。
 * @param conn データベース接続
 * @return http.HandlerFunc HTTPリクエストを処理するハンドラ関数
 * @details
 * HTTPリクエストのボディから削除対象のIDの配列を受け取り、ループ処理でDBから削除します。
 * 処理は単一のトランザクション内で行われ、一件でも失敗した場合は全てロールバックされます。
 */
func BulkDeleteBackordersHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var payload []struct {
			ID int `json:"id"`
		}
		if err := json.NewDecoder(r.Body).Decode(&payload); err != nil {
			http.Error(w, "Invalid request body", http.StatusBadRequest)
			return
		}

		if len(payload) == 0 {
			w.Header().Set("Content-Type", "application/json")
			json.NewEncoder(w).Encode(map[string]string{"message": "削除する項目がありません。"})
			return
		}

		tx, err := conn.Begin()
		if err != nil {
			http.Error(w, "Failed to start transaction", http.StatusInternalServerError)
			return
		}
		defer tx.Rollback()

		for _, bo := range payload {
			if err := db.DeleteBackorderInTx(tx, bo.ID); err != nil {
				http.Error(w, "Failed to delete backorder: "+err.Error(), http.StatusInternalServerError)
				return
			}
		}

		if err := tx.Commit(); err != nil {
			http.Error(w, "Failed to commit transaction", http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]string{"message": "選択された発注残を削除しました。"})
	}
}

// ▲▲▲【修正ここまで】▲▲▲


----- C:\Users\wasab\OneDrive\デスクトップ\WASABI\backup\handler.go -----
package backup

import (
	"database/sql"
	"encoding/csv"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"strconv"
	"strings"
	"wasabi/db"
	"wasabi/model"
)

// ▼▼▼【ここから追加】▼▼▼

// ExportCustomersHandler は得意先と卸業者の両方を1つのCSVファイルに出力します。
func ExportCustomersHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		clients, err := db.GetAllClients(conn)
		if err != nil {
			http.Error(w, "Failed to get clients", http.StatusInternalServerError)
			return
		}

		wholesalers, err := db.GetAllWholesalers(conn)
		if err != nil {
			http.Error(w, "Failed to get wholesalers", http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "text/csv")
		w.Header().Set("Content-Disposition", `attachment; filename="customer_master.csv"`)
		w.Write([]byte{0xEF, 0xBB, 0xBF}) // UTF-8 BOM

		csvWriter := csv.NewWriter(w)
		defer csvWriter.Flush()

		headers := []string{"種別", "コード", "名称"}
		if err := csvWriter.Write(headers); err != nil {
			http.Error(w, "Failed to write CSV header", http.StatusInternalServerError)
			return
		}

		// 得意先を書き込み
		for _, client := range clients {
			record := []string{
				"得意先",
				fmt.Sprintf("=%q", client.Code),
				client.Name,
			}
			if err := csvWriter.Write(record); err != nil {
				log.Printf("Failed to write client row to CSV (Code: %s): %v", client.Code, err)
			}
		}

		// 卸業者を書き込み
		for _, wholesaler := range wholesalers {
			record := []string{
				"卸業者",
				fmt.Sprintf("=%q", wholesaler.Code),
				wholesaler.Name,
			}
			if err := csvWriter.Write(record); err != nil {
				log.Printf("Failed to write wholesaler row to CSV (Code: %s): %v", wholesaler.Code, err)
			}
		}
	}
}

// ImportCustomersHandler は得意先と卸業者の両方を含むCSVファイルをインポートします。
func ImportCustomersHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		file, _, err := r.FormFile("file")
		if err != nil {
			http.Error(w, "No file uploaded", http.StatusBadRequest)
			return
		}
		defer file.Close()

		csvReader := csv.NewReader(file)
		csvReader.LazyQuotes = true
		rows, err := csvReader.ReadAll()
		if err != nil {
			http.Error(w, "Failed to parse CSV file: "+err.Error(), http.StatusBadRequest)
			return
		}

		tx, err := conn.Begin()
		if err != nil {
			http.Error(w, "Failed to start transaction", http.StatusInternalServerError)
			return
		}
		defer tx.Rollback()

		clientStmt, err := tx.Prepare("INSERT OR REPLACE INTO client_master (client_code, client_name) VALUES (?, ?)")
		if err != nil {
			http.Error(w, "Failed to prepare client DB statement", http.StatusInternalServerError)
			return
		}
		defer clientStmt.Close()

		wholesalerStmt, err := tx.Prepare("INSERT OR REPLACE INTO wholesalers (wholesaler_code, wholesaler_name) VALUES (?, ?)")
		if err != nil {
			http.Error(w, "Failed to prepare wholesaler DB statement", http.StatusInternalServerError)
			return
		}
		defer wholesalerStmt.Close()

		var clientCount, wholesalerCount int
		for i, row := range rows {
			if i == 0 || len(row) < 3 { // Skip header or short rows
				continue
			}
			customerType := strings.TrimSpace(row[0])
			code := strings.Trim(strings.TrimSpace(row[1]), `="`)
			name := strings.TrimSpace(row[2])

			switch customerType {
			case "得意先":
				if _, err := clientStmt.Exec(code, name); err != nil {
					log.Printf("Failed to import client row %d: %v", i+1, err)
					http.Error(w, fmt.Sprintf("Failed to import client row %d", i+1), http.StatusInternalServerError)
					return
				}
				clientCount++
			case "卸業者":
				if _, err := wholesalerStmt.Exec(code, name); err != nil {
					log.Printf("Failed to import wholesaler row %d: %v", i+1, err)
					http.Error(w, fmt.Sprintf("Failed to import wholesaler row %d", i+1), http.StatusInternalServerError)
					return
				}
				wholesalerCount++
			default:
				// Unknown type, skip
			}
		}

		if err := db.InitializeSequenceFromMaxClientCode(tx); err != nil {
			log.Printf("Warning: failed to re-initialize client sequence after import: %v", err)
		}

		if err := tx.Commit(); err != nil {
			http.Error(w, "Failed to commit transaction", http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]string{
			"message": fmt.Sprintf("%d件の得意先、%d件の卸業者をインポートしました。", clientCount, wholesalerCount),
		})
	}
}

// ▲▲▲【追加ここまで】▲▲▲

// ExportClientsHandler は古い関数として残しますが、新しいUIからは呼び出されません。
func ExportClientsHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// (元のコードのまま)
		clients, err := db.GetAllClients(conn)
		if err != nil {
			http.Error(w, "Failed to get clients", http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "text/csv")
		w.Header().Set("Content-Disposition", `attachment; filename="client_master.csv"`)
		w.Write([]byte{0xEF, 0xBB, 0xBF}) // UTF-8 BOM

		csvWriter := csv.NewWriter(w)
		defer csvWriter.Flush()

		headers := []string{"client_code", "client_name"}
		if err := csvWriter.Write(headers); err != nil {
			http.Error(w, "Failed to write CSV header", http.StatusInternalServerError)
			return
		}

		for _, client := range clients {
			record := []string{
				fmt.Sprintf("=%q", client.Code),
				client.Name,
			}
			if err := csvWriter.Write(record); err != nil {
				log.Printf("Failed to write client row to CSV (Code: %s): %v", client.Code, err)
			}
		}
	}
}

// ImportClientsHandler は古い関数として残しますが、新しいUIからは呼び出されません。
func ImportClientsHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// (元のコードのまま)
		file, _, err := r.FormFile("file")
		if err != nil {
			http.Error(w, "No file uploaded", http.StatusBadRequest)
			return
		}
		defer file.Close()

		csvReader := csv.NewReader(file)
		csvReader.LazyQuotes = true
		rows, err := csvReader.ReadAll()
		if err != nil {
			http.Error(w, "Failed to parse CSV file: "+err.Error(), http.StatusBadRequest)
			return
		}

		tx, err := conn.Begin()
		if err != nil {
			http.Error(w, "Failed to start transaction", http.StatusInternalServerError)
			return
		}
		defer tx.Rollback()

		stmt, err := tx.Prepare("INSERT OR REPLACE INTO client_master (client_code, client_name) VALUES (?, ?)")
		if err != nil {
			http.Error(w, "Failed to prepare DB statement", http.StatusInternalServerError)
			return
		}
		defer stmt.Close()

		var importedCount int
		for i, row := range rows {
			if i == 0 || len(row) < 2 { // Skip header or short rows
				continue
			}
			clientCode := strings.Trim(strings.TrimSpace(row[0]), `="`)
			clientName := strings.TrimSpace(row[1])

			if _, err := stmt.Exec(clientCode, clientName); err != nil {
				log.Printf("Failed to import client row %d: %v", i+1, err)
				http.Error(w, fmt.Sprintf("Failed to import client row %d", i+1), http.StatusInternalServerError)
				return
			}
			importedCount++
		}

		if err := db.InitializeSequenceFromMaxClientCode(tx); err != nil {
			log.Printf("Warning: failed to re-initialize client sequence after import: %v", err)
		}

		if err := tx.Commit(); err != nil {
			http.Error(w, "Failed to commit transaction", http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]string{
			"message": fmt.Sprintf("%d件の得意先をインポートしました。", importedCount),
		})
	}
}

func ExportProductsHandler(conn *sql.DB) http.HandlerFunc {
	// (この関数は変更なし)
	return func(w http.ResponseWriter, r *http.Request) {
		products, err := db.GetAllProductMasters(conn)
		if err != nil {
			http.Error(w, "Failed to get products", http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "text/csv")
		w.Header().Set("Content-Disposition", `attachment; filename="product_master_editable.csv"`)
		w.Write([]byte{0xEF, 0xBB, 0xBF}) // UTF-8 BOM for Excel compatibility

		csvWriter := csv.NewWriter(w)
		defer csvWriter.Flush()

		header := []string{
			"product_code", "yj_code", "gs1_code", "product_name", "specification", "kana_name", "maker_name",
			"usage_classification", "package_form", "yj_unit_name", "yj_pack_unit_qty",
			"jan_pack_inner_qty", "jan_unit_code", "jan_pack_unit_qty", "origin",
			"nhi_price", "purchase_price",
			"flag_poison", "flag_deleterious", "flag_narcotic", "flag_psychotropic", "flag_stimulant", "flag_stimulant_raw",
			"is_order_stopped", "supplier_wholesale",
			"group_code", "shelf_number", "category", "user_notes",
		}
		if err := csvWriter.Write(header); err != nil {
			http.Error(w, "Failed to write CSV header", http.StatusInternalServerError)
			return
		}

		for _, p := range products {
			record := []string{
				fmt.Sprintf("=%q", p.ProductCode),
				p.YjCode,
				p.Gs1Code,
				p.ProductName,
				p.Specification,
				p.KanaName,
				p.MakerName,
				p.UsageClassification,
				p.PackageForm,
				p.YjUnitName,
				strconv.FormatFloat(p.YjPackUnitQty, 'f', -1, 64),
				strconv.FormatFloat(p.JanPackInnerQty, 'f', -1, 64),
				strconv.Itoa(p.JanUnitCode),
				strconv.FormatFloat(p.JanPackUnitQty, 'f', -1, 64),
				p.Origin,
				strconv.FormatFloat(p.NhiPrice, 'f', -1, 64),
				strconv.FormatFloat(p.PurchasePrice, 'f', -1, 64),
				strconv.Itoa(p.FlagPoison),
				strconv.Itoa(p.FlagDeleterious),
				strconv.Itoa(p.FlagNarcotic),
				strconv.Itoa(p.FlagPsychotropic),
				strconv.Itoa(p.FlagStimulant),
				strconv.Itoa(p.FlagStimulantRaw),
				strconv.Itoa(p.IsOrderStopped),
				p.SupplierWholesale,
				p.GroupCode,
				p.ShelfNumber,
				p.Category,
				p.UserNotes,
			}
			if err := csvWriter.Write(record); err != nil {
				log.Printf("Failed to write product row to CSV (JAN: %s): %v", p.ProductCode, err)
			}
		}
	}
}

func ImportProductsHandler(conn *sql.DB) http.HandlerFunc {
	// (この関数は変更なし)
	return func(w http.ResponseWriter, r *http.Request) {
		file, _, err := r.FormFile("file")
		if err != nil {
			http.Error(w, "No file uploaded", http.StatusBadRequest)
			return
		}
		defer file.Close()

		csvReader := csv.NewReader(file)
		csvReader.LazyQuotes = true

		rows, err := csvReader.ReadAll()
		if err != nil {
			http.Error(w, "Failed to parse CSV file: "+err.Error(), http.StatusBadRequest)
			return
		}

		tx, err := conn.Begin()
		if err != nil {
			http.Error(w, "Failed to start transaction", http.StatusInternalServerError)
			return
		}
		defer tx.Rollback()

		var importedCount int
		for i, row := range rows {
			if i == 0 || len(row) < 29 {
				continue
			}

			yjPackUnitQty, _ := strconv.ParseFloat(row[10], 64)
			janPackInnerQty, _ := strconv.ParseFloat(row[11], 64)
			janUnitCode, _ := strconv.Atoi(row[12])
			janPackUnitQty, _ := strconv.ParseFloat(row[13], 64)
			nhiPrice, _ := strconv.ParseFloat(row[15], 64)
			purchasePrice, _ := strconv.ParseFloat(row[16], 64)
			flagPoison, _ := strconv.Atoi(row[17])
			flagDeleterious, _ := strconv.Atoi(row[18])
			flagNarcotic, _ := strconv.Atoi(row[19])
			flagPsychotropic, _ := strconv.Atoi(row[20])
			flagStimulant, _ := strconv.Atoi(row[21])
			flagStimulantRaw, _ := strconv.Atoi(row[22])
			isOrderStopped, _ := strconv.Atoi(row[23])
			productCode := strings.Trim(strings.TrimSpace(row[0]), `="`)

			input := model.ProductMasterInput{
				ProductCode:         productCode,
				YjCode:              strings.TrimSpace(row[1]),
				Gs1Code:             strings.TrimSpace(row[2]),
				ProductName:         strings.TrimSpace(row[3]),
				Specification:       strings.TrimSpace(row[4]),
				KanaName:            strings.TrimSpace(row[5]),
				MakerName:           strings.TrimSpace(row[6]),
				UsageClassification: strings.TrimSpace(row[7]),
				PackageForm:         strings.TrimSpace(row[8]),
				YjUnitName:          strings.TrimSpace(row[9]),
				YjPackUnitQty:       yjPackUnitQty,
				JanPackInnerQty:     janPackInnerQty,
				JanUnitCode:         janUnitCode,
				JanPackUnitQty:      janPackUnitQty,
				Origin:              strings.TrimSpace(row[14]),
				NhiPrice:            nhiPrice,
				PurchasePrice:       purchasePrice,
				FlagPoison:          flagPoison,
				FlagDeleterious:     flagDeleterious,
				FlagNarcotic:        flagNarcotic,
				FlagPsychotropic:    flagPsychotropic,
				FlagStimulant:       flagStimulant,
				FlagStimulantRaw:    flagStimulantRaw,
				IsOrderStopped:      isOrderStopped,
				SupplierWholesale:   strings.TrimSpace(row[24]),
				GroupCode:           strings.TrimSpace(row[25]),
				ShelfNumber:         strings.TrimSpace(row[26]),
				Category:            strings.TrimSpace(row[27]),
				UserNotes:           strings.TrimSpace(row[28]),
			}

			if err := db.UpsertProductMasterInTx(tx, input); err != nil {
				log.Printf("Failed to import product row %d: %v", i+1, err)
				http.Error(w, fmt.Sprintf("Failed to import product row %d", i+1), http.StatusInternalServerError)
				return
			}
			importedCount++
		}

		if err := db.InitializeSequenceFromMaxYjCode(tx); err != nil {
			log.Printf("Warning: failed to re-initialize YJ sequence after import: %v", err)
		}

		if err := tx.Commit(); err != nil {
			http.Error(w, "Failed to commit transaction", http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]string{
			"message": fmt.Sprintf("%d件の製品をインポートしました。", importedCount),
		})
	}
}


----- C:\Users\wasab\OneDrive\デスクトップ\WASABI\cleanup\handler.go -----
// C:\Users\wasab\OneDrive\デスクトップ\WASABI\cleanup\handler.go

package cleanup

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"net/http"
	"wasabi/db"
)

// GetCandidatesHandler は整理対象のマスター候補をリストアップします。
func GetCandidatesHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		candidates, err := db.GetCleanupCandidates(conn)
		if err != nil {
			http.Error(w, "Failed to get cleanup candidates: "+err.Error(), http.StatusInternalServerError)
			return
		}
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(candidates)
	}
}

// ExecuteCleanupHandler は指定されたマスターを削除します。
func ExecuteCleanupHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var payload struct {
			ProductCodes []string `json:"productCodes"`
		}
		if err := json.NewDecoder(r.Body).Decode(&payload); err != nil {
			http.Error(w, "Invalid request body", http.StatusBadRequest)
			return
		}

		tx, err := conn.Begin()
		if err != nil {
			http.Error(w, "Failed to start transaction", http.StatusInternalServerError)
			return
		}
		defer tx.Rollback()

		rowsAffected, err := db.DeleteMastersByCodesInTx(tx, payload.ProductCodes)
		if err != nil {
			http.Error(w, "Failed to execute cleanup: "+err.Error(), http.StatusInternalServerError)
			return
		}

		if err := tx.Commit(); err != nil {
			http.Error(w, "Failed to commit transaction", http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]string{
			"message": fmt.Sprintf("%d件の製品マスターを削除しました。", rowsAffected),
		})
	}
}


----- C:\Users\wasab\OneDrive\デスクトップ\WASABI\client\handlers.go -----
// C:\Users\wasab\OneDrive\デスクトップ\WASABI\client\handler.go

package client

import (
	"database/sql"
	"encoding/json"
	"net/http"
	"wasabi/db"
)

/**
 * @brief 全ての得意先リストを取得するAPIハンドラ (/api/clients)
 * @param conn データベース接続
 * @return http.HandlerFunc HTTPリクエストを処理するハンドラ関数
 */
func GetAllClientsHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		clients, err := db.GetAllClients(conn)
		if err != nil {
			http.Error(w, "Failed to get clients", http.StatusInternalServerError)
			return
		}
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(clients)
	}
}


----- C:\Users\wasab\OneDrive\デスクトップ\WASABI\config\config.go -----
// C:\Users\wasab\OneDrive\デスクトップ\WASABI\config\config.go

package config

import (
	"encoding/json"
	"os"
	"sync"
)

// Config はアプリケーションの設定情報を保持する構造体です。
// `config.json`ファイルにこの構造体の内容が保存されます。
type Config struct {
	EmednetUserID   string `json:"emednetUserId"`
	EmednetPassword string `json:"emednetPassword"`
	EdeUserID       string `json:"edeUserId"`
	EdePassword     string `json:"edePassword"`
	UsageFolderPath string `json:"usageFolderPath"`
	// ▼▼▼【ここから修正】▼▼▼
	// 2つの日付フィールドを削除し、集計日数を保持するフィールドを1つ追加
	CalculationPeriodDays int `json:"calculationPeriodDays"`
	// ▲▲▲【修正ここまで】▲▲▲
	// ▼▼▼【ここに追加】▼▼▼
	EdgePath string `json:"edgePath"` // Edgeの実行可能ファイルパス
	// ▲▲▲【追加ここまで】▲▲▲
}

var (
	// cfg はアプリケーション全体で共有される設定情報を保持するグローバル変数です。
	cfg Config
	// mu は設定情報への同時アクセスを防ぎ、データの競合を避けるためのロックです。
	mu sync.RWMutex
)

// configFilePath は設定ファイルのパスを定義する定数です。
const configFilePath = "./config.json"

/**
 * @brief config.json ファイルから設定を読み込み、メモリにキャッシュします。
 * @return Config 読み込まれた設定情報
 * @return error ファイルの読み込みや解析中にエラーが発生した場合
 * @details
 * ファイルが存在しない場合は、空の設定情報とnilエラーを返します。
 * 読み込み中は読み取りロックをかけ、スレッドセーフを保証します。
 */
func LoadConfig() (Config, error) {
	mu.RLock()
	defer mu.RUnlock()

	file, err := os.ReadFile(configFilePath)
	if err != nil {
		if os.IsNotExist(err) {
			// ファイルが存在しないのは初回起動時などの正常なケースなのでエラーとはしない
			return Config{
				// ▼▼▼【修正】日数のデフォルト値を設定 ▼▼▼
				CalculationPeriodDays: 90,
			}, nil
		}
		return Config{}, err
	}

	var tempCfg Config
	if err := json.Unmarshal(file, &tempCfg); err != nil {
		return Config{}, err
	}
	cfg = tempCfg
	return cfg, nil
}

/**
 * @brief 新しい設定情報を config.json ファイルに保存します。
 * @param newCfg 保存する新しい設定情報
 * @return error ファイルの書き込み中にエラーが発生した場合
 * @details
 * 書き込み中は書き込みロックをかけ、スレッドセーフを保証します。
 * 保存が成功すると、メモリ上のグローバルな設定情報も更新されます。
 */
func SaveConfig(newCfg Config) error {
	mu.Lock()
	defer mu.Unlock()

	file, err := json.MarshalIndent(newCfg, "", "  ")
	if err != nil {
		return err
	}

	if err := os.WriteFile(configFilePath, file, 0644); err != nil {
		return err
	}
	cfg = newCfg
	return nil
}

/**
 * @brief メモリにキャッシュされている現在の設定情報を取得します。
 * @return Config 現在の設定情報
 * @details
 * 読み取り中は読み取りロックをかけ、スレッドセーフを保証します。
 */
func GetConfig() Config {
	mu.RLock()
	defer mu.RUnlock()
	return cfg
}


----- C:\Users\wasab\OneDrive\デスクトップ\WASABI\dat\handler.go -----
// C:\Users\wasab\OneDrive\デスクトップ\WASABI\dat\handler.go (全体)

package dat

import (
	"bufio"
	"database/sql"
	"encoding/json"
	"fmt"
	"html/template"
	"io"
	"log"
	"net/http"
	"os"
	"path/filepath"
	"strings"
	"time"
	"wasabi/db"
	"wasabi/mappers"
	"wasabi/mastermanager"
	"wasabi/model"
	"wasabi/parsers"
	"wasabi/units" // ◀◀◀ 追加
)

// insertTransactionQuery は取引レコードをデータベースに挿入または置換するためのSQLクエリです。
const insertTransactionQuery = `
INSERT OR REPLACE INTO transaction_records (
    transaction_date, client_code, receipt_number, line_number, flag,
    jan_code, yj_code, product_name, kana_name, usage_classification, package_form, package_spec, maker_name,
    dat_quantity, jan_pack_inner_qty, jan_quantity, jan_pack_unit_qty, jan_unit_name, jan_unit_code,
    yj_quantity, yj_pack_unit_qty, yj_unit_name, unit_price, purchase_price, supplier_wholesale,
    subtotal, tax_amount, tax_rate, expiry_date, lot_number, flag_poison,
    flag_deleterious, flag_narcotic, flag_psychotropic, flag_stimulant,
    flag_stimulant_raw, process_flag_ma
) VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)`

// UploadDatHandler はDATファイルのアップロードを処理するHTTPハンドラです。
func UploadDatHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		if err := r.ParseMultipartForm(32 << 20); err != nil {
			http.Error(w, "File upload error: "+err.Error(), http.StatusBadRequest)
			return
		}
		defer r.MultipartForm.RemoveAll()

		var allFilePaths []string
		for _, fileHeader := range r.MultipartForm.File["file"] {
			file, err := fileHeader.Open()
			if err != nil {
				log.Printf("Failed to open uploaded file %s: %v", fileHeader.Filename, err)
				continue
			}

			tempFile, err := os.CreateTemp("", "dat-*.tmp")
			if err != nil {
				log.Printf("Failed to create temp file: %v", err)
				file.Close()
				continue
			}
			_, err = io.Copy(tempFile, file)
			file.Close()
			if err != nil {
				log.Printf("Failed to copy to temp file: %v", err)
				tempFile.Close()
				os.Remove(tempFile.Name())
				continue
			}
			tempFile.Seek(0, 0)
			scanner := bufio.NewScanner(tempFile)
			var destDir string
			var newBaseName string
			if scanner.Scan() {
				firstLine := scanner.Text()
				if strings.HasPrefix(firstLine, "S") && len(firstLine) >= 39 {
					timestampStr := firstLine[27:39]
					yy, mm, dd, h, m, s := timestampStr[0:2], timestampStr[2:4], timestampStr[4:6], timestampStr[6:8], timestampStr[8:10], timestampStr[10:12]
					newBaseName = fmt.Sprintf("20%s%s%s_%s%s%s", yy, mm, dd, h, m, s)
				}
			}
			if newBaseName != "" {
				destDir = filepath.Join("download", "DAT")
			} else {
				destDir = filepath.Join("download", "DAT", "unorganized")
				newBaseName = time.Now().Format("20060102150405")
			}
			os.MkdirAll(destDir, 0755)
			destPath := filepath.Join(destDir, newBaseName+filepath.Ext(fileHeader.Filename))

			if err := os.Rename(tempFile.Name(), destPath); err != nil {
				tempFile.Seek(0, 0)
				destFile, createErr := os.Create(destPath)
				if createErr != nil {
					log.Printf("Failed to create destination file for copying: %v", createErr)
					tempFile.Close()
					os.Remove(tempFile.Name())
					continue
				}
				_, copyErr := io.Copy(destFile, tempFile)
				destFile.Close()
				tempFile.Close()
				os.Remove(tempFile.Name())
				if copyErr != nil {
					log.Printf("Failed to copy temp file to destination: %v", copyErr)
					os.Remove(destPath)
					continue
				}
			}

			log.Printf("Successfully saved and organized file to: %s", destPath)
			allFilePaths = append(allFilePaths, destPath)
		}

		var allProcessedRecords []model.TransactionRecord
		for _, path := range allFilePaths {
			processed, err := ProcessDatFile(conn, path)
			if err != nil {
				log.Printf("Failed to process DAT file %s: %v", path, err)
				// 1つのファイルの処理に失敗しても他のファイルの処理は続ける
				continue
			}
			allProcessedRecords = append(allProcessedRecords, processed...)
		}

		// ▼▼▼【ここから修正】▼▼▼
		// 処理した納品データを使って発注残を消し込む
		if len(allProcessedRecords) > 0 {
			var deliveredItems []model.Backorder
			for _, rec := range allProcessedRecords {
				// 納品(flag=1)の取引のみを消し込み対象とする
				if rec.Flag == 1 {
					deliveredItems = append(deliveredItems, model.Backorder{
						YjCode:          rec.YjCode,
						PackageForm:     rec.PackageForm,
						JanPackInnerQty: rec.JanPackInnerQty,
						YjUnitName:      rec.YjUnitName,
						YjQuantity:      rec.YjQuantity,
					})
				}
			}

			if len(deliveredItems) > 0 {
				if err := db.ReconcileBackorders(conn, deliveredItems); err != nil {
					// 消し込みに失敗しても、納品登録自体は完了しているため、エラーログを出力するに留める
					log.Printf("WARN: Failed to reconcile backorders after DAT import: %v", err)
					http.Error(w, "納品データの登録には成功しましたが、発注残の自動消し込みに失敗しました。手動で調整してください。: "+err.Error(), http.StatusMultiStatus)
					return
				}
				log.Printf("Successfully reconciled %d backorder items.", len(deliveredItems))
			}
		}
		// ▲▲▲【修正ここまで】▲▲▲

		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		json.NewEncoder(w).Encode(map[string]interface{}{
			"message": fmt.Sprintf("Parsed and processed %d DAT files successfully.", len(allFilePaths)),
			"records": allProcessedRecords,
		})
	}
}

// ProcessDatFile は単一のDATファイルを解析し、内容をデータベースに登録します。
func ProcessDatFile(conn *sql.DB, filePath string) ([]model.TransactionRecord, error) {
	file, err := os.Open(filePath)
	if err != nil {
		return nil, fmt.Errorf("failed to open organized file %s: %w", filePath, err)
	}
	defer file.Close()

	parsed, err := parsers.ParseDat(file)
	if err != nil {
		return nil, fmt.Errorf("failed to parse file %s: %w", filePath, err)
	}

	filteredRecords := removeDatDuplicates(parsed)
	if len(filteredRecords) == 0 {
		return []model.TransactionRecord{}, nil
	}

	tx, err := conn.Begin()
	if err != nil {
		return nil, fmt.Errorf("failed to begin transaction: %w", err)
	}
	defer tx.Rollback()

	var keyList, janList []string
	keySet, janSet := make(map[string]struct{}), make(map[string]struct{})
	for _, rec := range filteredRecords {
		if rec.JanCode != "" && rec.JanCode != "0000000000000" {
			if _, seen := janSet[rec.JanCode]; !seen {
				janSet[rec.JanCode] = struct{}{}
				janList = append(janList, rec.JanCode)
			}
		}
		key := rec.JanCode
		if key == "" || key == "0000000000000" {
			key = fmt.Sprintf("9999999999999%s", rec.ProductName)
		}
		if _, seen := keySet[key]; !seen {
			keySet[key] = struct{}{}
			keyList = append(keyList, key)
		}
	}

	mastersMap, err := db.GetProductMastersByCodesMap(tx, keyList)
	if err != nil {
		return nil, fmt.Errorf("failed to pre-fetch product masters: %w", err)
	}

	jcshmsMap, err := db.GetJcshmsByCodesMap(tx, janList)
	if err != nil {
		return nil, fmt.Errorf("failed to pre-fetch JCSHMS data: %w", err)
	}

	stmt, err := tx.Prepare(insertTransactionQuery)
	if err != nil {
		return nil, fmt.Errorf("failed to prepare statement: %w", err)
	}
	defer stmt.Close()

	var finalRecords []model.TransactionRecord
	for _, rec := range filteredRecords {
		ar := model.TransactionRecord{
			TransactionDate: rec.Date, ClientCode: rec.ClientCode, ReceiptNumber: rec.ReceiptNumber,
			LineNumber: rec.LineNumber, Flag: rec.Flag, JanCode: rec.JanCode,
			ProductName: rec.ProductName, DatQuantity: rec.DatQuantity,
			ExpiryDate: rec.ExpiryDate, LotNumber: rec.LotNumber,
		}

		master, err := mastermanager.FindOrCreate(tx, rec.JanCode, rec.ProductName, mastersMap, jcshmsMap)
		if err != nil {
			return nil, fmt.Errorf("mastermanager failed for jan %s: %w", rec.JanCode, err)
		}

		if master.YjPackUnitQty > 0 {
			ar.YjQuantity = ar.DatQuantity * master.YjPackUnitQty
		}
		if master.JanPackUnitQty > 0 {
			ar.JanQuantity = ar.DatQuantity * master.JanPackUnitQty
		}

		packagePurchasePrice := rec.UnitPrice
		if packagePurchasePrice <= 0 && master.PurchasePrice > 0 {
			packagePurchasePrice = master.PurchasePrice
		}

		if master.YjPackUnitQty > 0 && packagePurchasePrice > 0 {
			ar.UnitPrice = packagePurchasePrice / master.YjPackUnitQty
		} else {
			ar.UnitPrice = rec.UnitPrice
		}

		ar.Subtotal = ar.YjQuantity * ar.UnitPrice
		ar.PurchasePrice = packagePurchasePrice

		mappers.MapProductMasterToTransaction(&ar, master)
		ar.ProcessFlagMA = "COMPLETE"

		_, err = stmt.Exec(
			ar.TransactionDate, ar.ClientCode, ar.ReceiptNumber, ar.LineNumber, ar.Flag,
			ar.JanCode, ar.YjCode, ar.ProductName, ar.KanaName, ar.UsageClassification, ar.PackageForm, ar.PackageSpec, ar.MakerName,
			ar.DatQuantity, ar.JanPackInnerQty, ar.JanQuantity, ar.JanPackUnitQty, ar.JanUnitName, ar.JanUnitCode,
			ar.YjQuantity, ar.YjPackUnitQty, ar.YjUnitName, ar.UnitPrice, ar.PurchasePrice, ar.SupplierWholesale,
			ar.Subtotal, ar.TaxAmount, ar.TaxRate, ar.ExpiryDate, ar.LotNumber, ar.FlagPoison,
			ar.FlagDeleterious, ar.FlagNarcotic, ar.FlagPsychotropic, ar.FlagStimulant,
			ar.FlagStimulantRaw, ar.ProcessFlagMA,
		)
		if err != nil {
			return nil, fmt.Errorf("failed to insert record for JAN %s: %w", ar.JanCode, err)
		}
		finalRecords = append(finalRecords, ar)
	}

	if err := tx.Commit(); err != nil {
		return nil, fmt.Errorf("transaction commit error (final): %w", err)
	}

	return finalRecords, nil
}

// removeDatDuplicates はDATレコードから重複を除外します。
func removeDatDuplicates(records []model.UnifiedInputRecord) []model.UnifiedInputRecord {
	seen := make(map[string]struct{})
	var result []model.UnifiedInputRecord
	for _, r := range records {
		key := fmt.Sprintf("%s|%s|%s|%s", r.Date, r.ClientCode, r.ReceiptNumber, r.LineNumber)
		if _, ok := seen[key]; ok {
			continue
		}
		seen[key] = struct{}{}
		result = append(result, r)
	}
	return result
}

// --- ここから dat/handler.go の末尾に追加 ---

// transactionTypeMap はGoテンプレート内で使用するヘルパーです
var transactionTypeMap = map[int]string{
	0: "棚卸", 1: "納品", 2: "返品", 3: "処方", 4: "棚卸増",
	5: "棚卸減", 11: "入庫", 12: "出庫", 30: "月末",
}

// datTemplate はHTML部品を生成するためのテンプレートです
// パフォーマンスのため、一度だけコンパイルします
var datTemplate = template.Must(template.New("dat_content").Funcs(template.FuncMap{
	// テンプレート内で 'getTxType .Flag' のように呼び出せる関数を登録
	"getTxType": func(flag int) string {
		if name, ok := transactionTypeMap[flag]; ok {
			return name
		}
		return fmt.Sprintf("%d", flag)
	},
	// テンプレート内で 'getClientName .Flag .ClientCode' のように呼び出せる関数を登録
	"getClientName": func(clientMap, wholesalerMap map[string]string, flag int, code string) string {
		if code == "" {
			return ""
		}
		if flag == 1 || flag == 2 { // 納品・返品
			if name, ok := wholesalerMap[code]; ok {
				return name
			}
		} else { // その他 (処方など)
			if name, ok := clientMap[code]; ok {
				return name
			}
		}
		return code // 見つからない場合はコードをそのまま返す
	},
	"resolveUnitName": func(code string) string {
		return units.ResolveName(code) // units パッケージの関数を呼び出す
	},
}).Parse(`
<table id="upload-output-table" class="data-table">
    <colgroup>
      <col class="col-1"><col class="col-2"><col class="col-3"><col class="col-4"><col class="col-5">
      <col class="col-6"><col class="col-7"><col class="col-8"><col class="col-9"><col class="col-10">
      <col class="col-11"><col class="col-12"><col class="col-13"><col class="col-14">
    </colgroup>
    <thead>
      <tr>
        <th rowspan="2">－</th>
        <th>日付</th><th class="yj-jan-code">YJ</th><th colspan="2">製品名</th>
        <th>個数</th><th>YJ数量</th><th>YJ包装数</th><th>YJ単位</th>
        <th>単価</th><th>税額</th><th>期限</th><th>得意先</th><th>行</th> 
      </tr>
      <tr>
        <th>種別</th><th class="yj-jan-code">JAN</th><th>包装</th><th>メーカー</th>
        <th>剤型</th><th>JAN数量</th><th>JAN包装数</th><th>JAN単位</th>
        <th>金額</th><th>税率</th><th>ロット</th><th>伝票番号</th><th>MA</th>
      </tr>
    </thead>
    <tbody>
    {{if not .Records}}
        <tr><td colspan="14">対象データがありません。</td></tr>
    {{else}}
        {{range .Records}}
            <tr class="{{if eq .Flag 2}}tx-return{{else if eq .Flag 0}}tx-inventory{{end}}"> 
                <td rowspan="2"></td>
                <td>{{.TransactionDate}}</td>
                <td class="yj-jan-code">{{.YjCode}}</td>
                <td class="left" colspan="2">{{.ProductName}}</td>
                <td class="right">{{printf "%.2f" .DatQuantity}}</td>
                <td class="right">{{printf "%.2f" .YjQuantity}}</td> 
                <td class="right">{{.YjPackUnitQty}}</td>
                <td>{{.YjUnitName}}</td>
                <td class="right">{{printf "%.4f" .UnitPrice}}</td>
                <td class="right">{{printf "%.2f" .TaxAmount}}</td>
                <td>{{.ExpiryDate}}</td>
                <td class="left">{{getClientName $.ClientMap $.WholesalerMap .Flag .ClientCode}}</td> 
                <td class="right">{{.LineNumber}}</td>
            </tr>
            <tr class="{{if eq .Flag 2}}tx-return{{else if eq .Flag 0}}tx-inventory{{end}}">
                <td>{{getTxType .Flag}}</td>
                <td class="yj-jan-code">{{.JanCode}}</td>
                <td class="left">{{.PackageSpec}}</td> 
                <td class="left">{{.MakerName}}</td>
                <td class="left">{{.UsageClassification}}</td>
                <td class="right">{{printf "%.2f" .JanQuantity}}</td>
                <td class="right">{{.JanPackUnitQty}}</td>
                <td>{{.JanUnitName}}</td> 
                <td class="right">{{printf "%.2f" .Subtotal}}</td>
                <td class="right">{{printf "%.0f" .TaxRate}}%</td>
                <td class="left">{{.LotNumber}}</td>
                <td class="left">{{.ReceiptNumber}}</td>
                <td class="left">{{.ProcessFlagMA}}</td>
            </tr> 
        {{end}}
    {{end}}
    </tbody>
</table>
`))

// UploadDatAsHTMLHandler はDATファイルのアップロードを処理し、結果をHTMLテーブルとして返します。
func UploadDatAsHTMLHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// 1. ファイルのパースと保存 (既存の UploadDatHandler と同じロジック)
		if err := r.ParseMultipartForm(32 << 20); err != nil {
			http.Error(w, "File upload error: "+err.Error(), http.StatusBadRequest)
			return
		}
		defer r.MultipartForm.RemoveAll()

		var allFilePaths []string
		for _, fileHeader := range r.MultipartForm.File["file"] {
			file, err := fileHeader.Open()
			if err != nil {
				log.Printf("Failed to open uploaded file %s: %v", fileHeader.Filename, err)
				continue
			}

			// (中略... から までのファイル保存ロジックをそのままコピー)
			tempFile, err := os.CreateTemp("", "dat-*.tmp")
			if err != nil {
				log.Printf("Failed to create temp file: %v", err)
				file.Close()
				continue
			}
			_, err = io.Copy(tempFile, file)
			file.Close()
			if err != nil {
				log.Printf("Failed to copy to temp file: %v", err)
				tempFile.Close()
				os.Remove(tempFile.Name())
				continue
			}
			tempFile.Seek(0, 0)
			scanner := bufio.NewScanner(tempFile)
			var destDir string
			var newBaseName string
			if scanner.Scan() {
				firstLine := scanner.Text()
				if strings.HasPrefix(firstLine, "S") && len(firstLine) >= 39 {
					timestampStr := firstLine[27:39]
					yy, mm, dd, h, m, s := timestampStr[0:2], timestampStr[2:4], timestampStr[4:6], timestampStr[6:8], timestampStr[8:10], timestampStr[10:12]
					newBaseName = fmt.Sprintf("20%s%s%s_%s%s%s", yy, mm, dd, h, m, s)
				}
			}
			if newBaseName != "" {
				destDir = filepath.Join("download", "DAT")
			} else {
				destDir = filepath.Join("download", "DAT", "unorganized")
				newBaseName = time.Now().Format("20060102150405")
			}
			os.MkdirAll(destDir, 0755)
			destPath := filepath.Join(destDir, newBaseName+filepath.Ext(fileHeader.Filename))

			if err := os.Rename(tempFile.Name(), destPath); err != nil {
				tempFile.Seek(0, 0)
				destFile, createErr := os.Create(destPath)
				if createErr != nil {
					log.Printf("Failed to create destination file for copying: %v", createErr)
					tempFile.Close()
					os.Remove(tempFile.Name())
					continue
				}
				_, copyErr := io.Copy(destFile, tempFile)
				destFile.Close()
				tempFile.Close()
				os.Remove(tempFile.Name())
				if copyErr != nil {
					log.Printf("Failed to copy temp file to destination: %v", copyErr)
					os.Remove(destPath)
					continue
				}
			}
			// (ファイル保存ロジックここまで)

			log.Printf("Successfully saved and organized file to: %s", destPath)
			allFilePaths = append(allFilePaths, destPath)
		}

		// 2. ファイル処理とDB登録 (既存の UploadDatHandler と同じロジック)
		var allProcessedRecords []model.TransactionRecord
		for _, path := range allFilePaths {
			processed, err := ProcessDatFile(conn, path)
			if err != nil {
				log.Printf("Failed to process DAT file %s: %v", path, err)
				continue
			}
			allProcessedRecords = append(allProcessedRecords, processed...)
		}

		// 3. 発注残の消し込み (既存の UploadDatHandler と同じロジック)
		if len(allProcessedRecords) > 0 {
			var deliveredItems []model.Backorder
			for _, rec := range allProcessedRecords {
				if rec.Flag == 1 {
					deliveredItems = append(deliveredItems, model.Backorder{
						YjCode:          rec.YjCode,
						PackageForm:     rec.PackageForm,
						JanPackInnerQty: rec.JanPackInnerQty,
						YjUnitName:      rec.YjUnitName,
						YjQuantity:      rec.YjQuantity,
					})
				}
			}

			if len(deliveredItems) > 0 {
				if err := db.ReconcileBackorders(conn, deliveredItems); err != nil {
					log.Printf("WARN: Failed to reconcile backorders after DAT import: %v", err)
					// HTMLを返すハンドラではエラーをHTMLで返すと親切
					http.Error(w, "納品データの登録には成功しましたが、発注残の自動消し込みに失敗しました。手動で調整してください。: "+err.Error(), http.StatusMultiStatus)
					return
				}
				log.Printf("Successfully reconciled %d backorder items.", len(deliveredItems))
			}
		}

		// 4. HTMLレンダリングのためのヘルパーマップを取得
		clientRows, err := db.GetAllClients(conn)
		if err != nil {
			log.Printf("WARN: Failed to get client map for HTML rendering: %v", err)
		}
		clientMap := make(map[string]string)
		for _, c := range clientRows {
			clientMap[c.Code] = c.Name
		}

		wholesalerRows, err := db.GetAllWholesalers(conn)
		if err != nil {
			log.Printf("WARN: Failed to get wholesaler map for HTML rendering: %v", err)
		}
		wholesalerMap := make(map[string]string)
		for _, w := range wholesalerRows {
			wholesalerMap[w.Code] = w.Name
		}

		// 5. JSONの代わりにHTMLをレンダリングして返す
		w.Header().Set("Content-Type", "text/html; charset=utf-8")
		err = datTemplate.Execute(w, struct {
			Records       []model.TransactionRecord
			ClientMap     map[string]string
			WholesalerMap map[string]string
		}{
			Records:       allProcessedRecords,
			ClientMap:     clientMap,
			WholesalerMap: wholesalerMap,
		})

		if err != nil {
			log.Printf("ERROR: Failed to render DAT HTML template: %v", err)
			http.Error(w, "HTMLのレンダリングに失敗しました: "+err.Error(), http.StatusInternalServerError)
		}
	}
}

// --- 追加ここまで ---


----- C:\Users\wasab\OneDrive\デスクトップ\WASABI\db\aggregation.go -----
// C:\Users\wasab\OneDrive\デスクトップ\WASABI\db\aggregation.go
package db

import (
	"database/sql"
	"fmt"
	"sort"
	"strings"
	"wasabi/model"
	"wasabi/units"
)

// ▼▼▼【ここから修正】▼▼▼

/**
 * @brief 在庫元帳レポートを生成します。
 * @param conn データベース接続
 * @param filters 絞り込み条件
 * @return []model.StockLedgerYJGroup 集計結果のスライス
 * @return error 処理中にエラーが発生した場合
 * @details
 * この関数はアプリケーションの在庫計算における中心的なロジックです。
 * 以下のステップで在庫元帳を生成します。
 * 1. フィルタ条件に合致する製品マスターから、対象となるYJコード群を特定します。
 * 2. 各YJコードについて、product_master と transaction_records の両方から関連する全ての製品コード(JAN)を収集します。
 * 3. 収集した製品コードに関連する全期間の取引履歴を一括で取得します。
 * 4. YJコードグループ全体の取引履歴から「最新の棚卸日」を特定します。
 * 5. 各包装グループについて、グループ全体の「最新棚卸日」を基点とした「期間前在庫（繰越在庫）」を算出します。
 * - 最新棚卸日に記録がない包装は、その時点での在庫を0とみなします。
 * 6. 期間内の取引を時系列で処理し、「期間内変動」「最大使用量」「期間終了在庫」を算出します。
 * 7. 発注残と予製引当数を考慮し、「有効在庫」と「発注点」を計算します。
 * 8. 全ての包装グループのデータをYJコードごとに集計し、最終的なレポートを生成します。
 * 9. 結果を剤型とカナ名でソートして返却します。
 */
func GetStockLedger(conn *sql.DB, filters model.AggregationFilters) ([]model.StockLedgerYJGroup, error) {
	backordersMap, err := GetAllBackordersMap(conn)
	if err != nil {
		return nil, fmt.Errorf("failed to get backorders for aggregation: %w", err)
	}
	precompTotals, err := GetPreCompoundingTotals(conn)
	if err != nil {
		return nil, fmt.Errorf("failed to get pre-compounding totals for aggregation: %w", err)
	}

	// ステップ1: フィルターに合致する製品マスターを取得し、対象YJコードを特定
	masterQuery := `SELECT ` + SelectColumns + ` FROM product_master p WHERE 1=1 `
	var masterArgs []interface{}
	if filters.YjCode != "" {
		masterQuery += " AND p.yj_code = ? "
		masterArgs = append(masterArgs, filters.YjCode)
	}
	if filters.KanaName != "" {
		masterQuery += " AND (p.kana_name LIKE ? OR p.product_name LIKE ?) "
		masterArgs = append(masterArgs, "%"+filters.KanaName+"%", "%"+filters.KanaName+"%")
	}
	if filters.DosageForm != "" && filters.DosageForm != "all" {
		masterQuery += " AND p.usage_classification = ? "
		masterArgs = append(masterArgs, filters.DosageForm)
	}
	if filters.ShelfNumber != "" {
		masterQuery += " AND p.shelf_number LIKE ? "
		masterArgs = append(masterArgs, "%"+filters.ShelfNumber+"%")
	}
	if len(filters.DrugTypes) > 0 && filters.DrugTypes[0] != "" {
		var conditions []string
		flagMap := map[string]string{
			"poison":        "p.flag_poison = 1",
			"deleterious":   "p.flag_deleterious = 1",
			"narcotic":      "p.flag_narcotic = 1",
			"psychotropic1": "p.flag_psychotropic = 1",
			"psychotropic2": "p.flag_psychotropic = 2",
			"psychotropic3": "p.flag_psychotropic = 3",
			"stimulant":     "p.flag_stimulant = 1",
			"stimulant_raw": "p.flag_stimulant_raw = 1",
		}
		for _, dt := range filters.DrugTypes {
			if cond, ok := flagMap[dt]; ok {
				conditions = append(conditions, cond)
			}
		}
		if len(conditions) > 0 {
			masterQuery += " AND (" + strings.Join(conditions, " OR ") + ")"
		}
	}

	masterRows, err := conn.Query(masterQuery, masterArgs...)
	if err != nil {
		return nil, err
	}
	defer masterRows.Close()

	mastersByYjCode := make(map[string][]*model.ProductMaster)
	yjCodeMap := make(map[string]bool)
	for masterRows.Next() {
		m, err := ScanProductMaster(masterRows)
		if err != nil {
			return nil, err
		}
		if m.YjCode != "" {
			mastersByYjCode[m.YjCode] = append(mastersByYjCode[m.YjCode], m)
			yjCodeMap[m.YjCode] = true
		}
	}
	if len(yjCodeMap) == 0 {
		return []model.StockLedgerYJGroup{}, nil
	}

	var yjCodes []string
	for yj := range yjCodeMap {
		yjCodes = append(yjCodes, yj)
	}

	// ステップ2 & 3: 関連する全ての製品コードと取引履歴を取得
	allProductCodes, err := getAllProductCodesForYjCodes(conn, yjCodes)
	if err != nil {
		return nil, fmt.Errorf("failed to get all product codes for yj codes: %w", err)
	}

	allMasters, err := getMastersByProductCodes(conn, allProductCodes)
	if err != nil {
		return nil, fmt.Errorf("failed to get all masters for product codes: %w", err)
	}

	transactionsByProductCode, err := getTransactionsByProductCodes(conn, allProductCodes)
	if err != nil {
		return nil, fmt.Errorf("failed to get all transactions for product codes: %w", err)
	}

	// ステップ4: YJコードごとに集計処理
	var result []model.StockLedgerYJGroup
	for _, yjCode := range yjCodes {
		mastersInYjGroup := mastersByYjCode[yjCode]
		if len(mastersInYjGroup) == 0 {
			continue
		}

		// YJグループの代表情報を設定
		var representativeProductName, representativeYjUnitName string
		if len(mastersInYjGroup) > 0 {
			representativeProductName = mastersInYjGroup[0].ProductName
			representativeYjUnitName = mastersInYjGroup[0].YjUnitName
			for _, m := range mastersInYjGroup {
				if m.Origin == "JCSHMS" {
					representativeProductName = m.ProductName
					representativeYjUnitName = m.YjUnitName
					break
				}
			}
		}
		yjGroup := model.StockLedgerYJGroup{
			YjCode:      yjCode,
			ProductName: representativeProductName,
			YjUnitName:  units.ResolveName(representativeYjUnitName),
		}

		// YJグループに属する全ての取引を集める
		var allTxsForYjGroup []*model.TransactionRecord
		for _, m := range allMasters {
			if m.YjCode == yjCode {
				allTxsForYjGroup = append(allTxsForYjGroup, transactionsByProductCode[m.ProductCode]...)
			}
		}
		sort.Slice(allTxsForYjGroup, func(i, j int) bool {
			if allTxsForYjGroup[i].TransactionDate != allTxsForYjGroup[j].TransactionDate {
				return allTxsForYjGroup[i].TransactionDate < allTxsForYjGroup[j].TransactionDate
			}
			return allTxsForYjGroup[i].ID < allTxsForYjGroup[j].ID
		})

		// YJグループ全体の最新棚卸日を特定
		latestInventoryDateForGroup := ""
		for _, t := range allTxsForYjGroup {
			if t.Flag == 0 && t.TransactionDate > latestInventoryDateForGroup {
				latestInventoryDateForGroup = t.TransactionDate
			}
		}

		// 包装キーでマスターをグループ化
		mastersByPackageKey := make(map[string][]*model.ProductMaster)
		for _, m := range mastersInYjGroup {
			key := fmt.Sprintf("%s|%s|%g|%s", m.YjCode, m.PackageForm, m.JanPackInnerQty, m.YjUnitName)
			mastersByPackageKey[key] = append(mastersByPackageKey[key], m)
		}

		var allPackageLedgers []model.StockLedgerPackageGroup
		for key, mastersInPackageGroup := range mastersByPackageKey {
			var startingBalance float64
			// ステップ5: 期間前在庫を計算
			if latestInventoryDateForGroup != "" {
				baseStockOnDate := 0.0
				for _, m := range mastersInPackageGroup {
					for _, t := range transactionsByProductCode[m.ProductCode] {
						if t.Flag == 0 && t.TransactionDate == latestInventoryDateForGroup {
							baseStockOnDate += t.YjQuantity
						}
					}
				}

				netChangeAfterInv := 0.0
				for _, m := range mastersInPackageGroup {
					for _, t := range transactionsByProductCode[m.ProductCode] {
						if t.TransactionDate > latestInventoryDateForGroup && t.TransactionDate < filters.StartDate {
							netChangeAfterInv += t.SignedYjQty()
						}
					}
				}
				startingBalance = baseStockOnDate + netChangeAfterInv
			} else {
				// 棚卸履歴が全くない場合
				netChangeBeforePeriod := 0.0
				for _, m := range mastersInPackageGroup {
					for _, t := range transactionsByProductCode[m.ProductCode] {
						if t.TransactionDate < filters.StartDate {
							netChangeBeforePeriod += t.SignedYjQty()
						}
					}
				}
				startingBalance = netChangeBeforePeriod
			}

			// ステップ6: 期間内変動を計算
			var transactionsInPeriod []model.LedgerTransaction
			var netChange, maxUsage float64
			runningBalance := startingBalance

			var txsForPackageInPeriod []*model.TransactionRecord
			for _, m := range mastersInPackageGroup {
				for _, t := range transactionsByProductCode[m.ProductCode] {
					if t.TransactionDate >= filters.StartDate && t.TransactionDate <= filters.EndDate {
						txsForPackageInPeriod = append(txsForPackageInPeriod, t)
					}
				}
			}
			sort.Slice(txsForPackageInPeriod, func(i, j int) bool {
				if txsForPackageInPeriod[i].TransactionDate != txsForPackageInPeriod[j].TransactionDate {
					return txsForPackageInPeriod[i].TransactionDate < txsForPackageInPeriod[j].TransactionDate
				}
				return txsForPackageInPeriod[i].ID < txsForPackageInPeriod[j].ID
			})

			periodInventorySums := make(map[string]float64)
			for _, t := range txsForPackageInPeriod {
				if t.Flag == 0 {
					periodInventorySums[t.TransactionDate] += t.YjQuantity
				}
			}

			lastProcessedDate := ""
			for _, t := range txsForPackageInPeriod {
				if t.TransactionDate != lastProcessedDate && lastProcessedDate != "" {
					if inventorySum, ok := periodInventorySums[lastProcessedDate]; ok {
						runningBalance = inventorySum
					}
				}

				if t.Flag == 0 {
					if inventorySum, ok := periodInventorySums[t.TransactionDate]; ok {
						runningBalance = inventorySum
					}
				} else {
					runningBalance += t.SignedYjQty()
				}
				transactionsInPeriod = append(transactionsInPeriod, model.LedgerTransaction{TransactionRecord: *t, RunningBalance: runningBalance})
				netChange += t.SignedYjQty()
				if t.Flag == 3 && t.YjQuantity > maxUsage {
					maxUsage = t.YjQuantity
				}
				lastProcessedDate = t.TransactionDate
			}

			// ステップ7: 発注点などを計算
			backorderQty := backordersMap[key]
			effectiveEndingBalance := runningBalance + backorderQty

			pkg := model.StockLedgerPackageGroup{
				PackageKey:             key,
				StartingBalance:        startingBalance,
				EndingBalance:          runningBalance,
				EffectiveEndingBalance: effectiveEndingBalance,
				Transactions:           transactionsInPeriod,
				NetChange:              netChange,
				MaxUsage:               maxUsage,
			}

			var precompTotalForPackage float64
			for _, master := range mastersInPackageGroup {
				// 現在マスターにない製品の在庫は0として扱う
				if _, ok := allMasters[master.ProductCode]; !ok {
					pkg.EndingBalance = 0
					pkg.EffectiveEndingBalance = 0
					pkg.StartingBalance = 0
				}
				if total, ok := precompTotals[master.ProductCode]; ok {
					precompTotalForPackage += total
				}
			}

			pkg.BaseReorderPoint = maxUsage * filters.Coefficient
			pkg.PrecompoundedTotal = precompTotalForPackage
			pkg.ReorderPoint = pkg.BaseReorderPoint + pkg.PrecompoundedTotal
			pkg.IsReorderNeeded = effectiveEndingBalance < pkg.ReorderPoint && pkg.MaxUsage > 0
			if len(mastersInPackageGroup) > 0 {
				pkg.Masters = mastersInPackageGroup
			}
			allPackageLedgers = append(allPackageLedgers, pkg)
		}

		// ステップ8: YJグループ全体で集計
		if len(allPackageLedgers) > 0 {
			var yjTotalEnding, yjTotalNetChange, yjTotalReorderPoint, yjTotalBaseReorderPoint, yjTotalPrecompounded float64
			var yjTotalStarting float64
			isYjReorderNeeded := false
			for _, pkg := range allPackageLedgers {
				if start, ok := pkg.StartingBalance.(float64); ok {
					yjTotalStarting += start
				}
				if end, ok := pkg.EndingBalance.(float64); ok {
					yjTotalEnding += end
				}
				yjTotalNetChange += pkg.NetChange
				yjTotalReorderPoint += pkg.ReorderPoint
				yjTotalBaseReorderPoint += pkg.BaseReorderPoint
				yjTotalPrecompounded += pkg.PrecompoundedTotal
				if pkg.IsReorderNeeded {
					isYjReorderNeeded = true
				}
			}
			yjGroup.StartingBalance = yjTotalStarting
			yjGroup.EndingBalance = yjTotalEnding
			yjGroup.NetChange = yjTotalNetChange
			yjGroup.TotalReorderPoint = yjTotalReorderPoint
			yjGroup.TotalBaseReorderPoint = yjTotalBaseReorderPoint
			yjGroup.TotalPrecompounded = yjTotalPrecompounded
			yjGroup.IsReorderNeeded = isYjReorderNeeded
			yjGroup.PackageLedgers = allPackageLedgers
			result = append(result, yjGroup)
		}
	}

	// ステップ9: ソートと最終フィルタリング
	sort.Slice(result, func(i, j int) bool {
		prio := map[string]int{"1": 1, "内": 1, "2": 2, "外": 2, "3": 3, "注": 3, "4": 4, "歯": 4, "5": 5, "機": 5, "6": 6, "他": 6}
		masterI := mastersByYjCode[result[i].YjCode][0]
		masterJ := mastersByYjCode[result[j].YjCode][0]
		prioI, okI := prio[strings.TrimSpace(masterI.UsageClassification)]
		if !okI {
			prioI = 7
		}
		prioJ, okJ := prio[strings.TrimSpace(masterJ.UsageClassification)]
		if !okJ {
			prioJ = 7
		}
		if prioI != prioJ {
			return prioI < prioJ
		}
		return masterI.KanaName < masterJ.KanaName
	})

	if filters.MovementOnly {
		var filteredResult []model.StockLedgerYJGroup
		for _, yjGroup := range result {
			hasMovement := false
			for _, pkg := range yjGroup.PackageLedgers {
				for _, tx := range pkg.Transactions {
					if tx.Flag != 0 {
						hasMovement = true
						break
					}
				}
				if hasMovement {
					break
				}
			}
			if hasMovement {
				filteredResult = append(filteredResult, yjGroup)
			}
		}
		return filteredResult, nil
	}

	return result, nil
}

// ヘルパー関数群
func getAllProductCodesForYjCodes(conn *sql.DB, yjCodes []string) ([]string, error) {
	if len(yjCodes) == 0 {
		return []string{}, nil
	}

	placeholders := strings.Repeat("?,", len(yjCodes)-1) + "?"
	query := fmt.Sprintf(`
		SELECT DISTINCT product_code FROM product_master WHERE yj_code IN (%s)
		UNION
		SELECT DISTINCT jan_code FROM transaction_records WHERE yj_code IN (%s)
	`, placeholders, placeholders)

	args := make([]interface{}, len(yjCodes)*2)
	for i, code := range yjCodes {
		args[i] = code
		args[i+len(yjCodes)] = code
	}

	rows, err := conn.Query(query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var codes []string
	for rows.Next() {
		var code string
		if err := rows.Scan(&code); err != nil {
			return nil, err
		}
		if code != "" {
			codes = append(codes, code)
		}
	}
	return codes, nil
}

func getMastersByProductCodes(conn *sql.DB, productCodes []string) (map[string]*model.ProductMaster, error) {
	mastersMap := make(map[string]*model.ProductMaster)
	if len(productCodes) == 0 {
		return mastersMap, nil
	}

	const batchSize = 500
	for i := 0; i < len(productCodes); i += batchSize {
		end := i + batchSize
		if end > len(productCodes) {
			end = len(productCodes)
		}
		batch := productCodes[i:end]

		if len(batch) > 0 {
			placeholders := strings.Repeat("?,", len(batch)-1) + "?"
			query := fmt.Sprintf("SELECT "+SelectColumns+" FROM product_master WHERE product_code IN (%s)", placeholders)
			args := make([]interface{}, len(batch))
			for j, pc := range batch {
				args[j] = pc
			}

			rows, err := conn.Query(query, args...)
			if err != nil {
				return nil, err
			}

			for rows.Next() {
				m, err := ScanProductMaster(rows)
				if err != nil {
					rows.Close()
					return nil, err
				}
				mastersMap[m.ProductCode] = m
			}
			rows.Close()
		}
	}
	return mastersMap, nil
}

func getTransactionsByProductCodes(conn *sql.DB, productCodes []string) (map[string][]*model.TransactionRecord, error) {
	transactionsMap := make(map[string][]*model.TransactionRecord)
	if len(productCodes) == 0 {
		return transactionsMap, nil
	}

	const batchSize = 500
	for i := 0; i < len(productCodes); i += batchSize {
		end := i + batchSize
		if end > len(productCodes) {
			end = len(productCodes)
		}
		batch := productCodes[i:end]

		if len(batch) > 0 {
			placeholders := strings.Repeat("?,", len(batch)-1) + "?"
			query := fmt.Sprintf("SELECT "+TransactionColumns+" FROM transaction_records WHERE jan_code IN (%s) ORDER BY transaction_date, id", placeholders)
			args := make([]interface{}, len(batch))
			for j, pc := range batch {
				args[j] = pc
			}

			rows, err := conn.Query(query, args...)
			if err != nil {
				return nil, err
			}

			for rows.Next() {
				t, err := ScanTransactionRecord(rows)
				if err != nil {
					rows.Close()
					return nil, err
				}
				transactionsMap[t.JanCode] = append(transactionsMap[t.JanCode], t)
			}
			rows.Close()
		}
	}
	return transactionsMap, nil
}

// ▲▲▲【修正ここまで】▲▲▲


----- C:\Users\wasab\OneDrive\デスクトップ\WASABI\db\backorders.go -----
// C:\Users\wasab\OneDrive\デスクトップ\WASABI\db\backorders.go

package db

import (
	"database/sql"
	"fmt"
	"wasabi/model"
)

// ▼▼▼【ここから修正】▼▼▼

/**
 * @brief 複数の発注残レコードをトランザクション内で登録します（INSERT）。
 * @param tx SQLトランザクションオブジェクト
 * @param backorders 登録する発注残レコードのスライス
 * @return error 処理中にエラーが発生した場合
 * @details
 * 発注ごとに新しいレコードとしてデータベースに挿入します。
 */
func InsertBackordersInTx(tx *sql.Tx, backorders []model.Backorder) error {
	const q = `
		INSERT INTO backorders (
			order_date, yj_code, product_name, package_form, jan_pack_inner_qty, 
			yj_unit_name, order_quantity, remaining_quantity, wholesaler_code,
			yj_pack_unit_qty, jan_pack_unit_qty, jan_unit_code
		) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`
	stmt, err := tx.Prepare(q)
	if err != nil {
		return fmt.Errorf("failed to prepare backorder insert statement: %w", err)
	}
	defer stmt.Close()

	for _, bo := range backorders {
		_, err := stmt.Exec(
			bo.OrderDate, bo.YjCode, bo.ProductName, bo.PackageForm, bo.JanPackInnerQty,
			bo.YjUnitName, bo.OrderQuantity, bo.RemainingQuantity, bo.WholesalerCode,
			bo.YjPackUnitQty, bo.JanPackUnitQty, bo.JanUnitCode,
		)
		if err != nil {
			return fmt.Errorf("failed to execute backorder insert for yj %s: %w", bo.YjCode, err)
		}
	}
	return nil
}

/**
 * @brief 納品データに基づいて発注残を消し込みます（FIFO: 先入れ先出し）。
 * @param conn データベース接続
 * @param deliveredItems 納品された品物のスライス
 * @return error 処理中にエラーが発生した場合
 * @details
 * 納品された各品物について、対応する発注残を古いものから順に消し込みます。
 * 発注残数量が0になったレコードは削除されます。
 */
func ReconcileBackorders(conn *sql.DB, deliveredItems []model.Backorder) error {
	tx, err := conn.Begin()
	if err != nil {
		return fmt.Errorf("failed to begin transaction for reconciliation: %w", err)
	}
	defer tx.Rollback()

	for _, item := range deliveredItems {
		deliveryQty := item.YjQuantity

		rows, err := tx.Query(`
			SELECT id, remaining_quantity FROM backorders 
			WHERE yj_code = ? AND package_form = ? AND jan_pack_inner_qty = ? AND yj_unit_name = ?
			ORDER BY order_date, id`,
			item.YjCode, item.PackageForm, item.JanPackInnerQty, item.YjUnitName,
		)
		if err != nil {
			return fmt.Errorf("failed to query backorders for reconciliation: %w", err)
		}

		for rows.Next() {
			if deliveryQty <= 0 {
				break
			}
			var id int
			var remainingQty float64
			if err := rows.Scan(&id, &remainingQty); err != nil {
				rows.Close()
				return fmt.Errorf("failed to scan backorder row: %w", err)
			}

			if deliveryQty >= remainingQty {
				// 納品数で発注残が完全にカバーされる場合
				if _, err := tx.Exec(`DELETE FROM backorders WHERE id = ?`, id); err != nil {
					rows.Close()
					return fmt.Errorf("failed to delete reconciled backorder id %d: %w", id, err)
				}
				deliveryQty -= remainingQty
			} else {
				// 納品数の一部で発注残を減らす場合
				newRemaining := remainingQty - deliveryQty
				if _, err := tx.Exec(`UPDATE backorders SET remaining_quantity = ? WHERE id = ?`, newRemaining, id); err != nil {
					rows.Close()
					return fmt.Errorf("failed to update partially reconciled backorder id %d: %w", id, err)
				}
				deliveryQty = 0
			}
		}
		rows.Close()
	}
	return tx.Commit()
}

/**
 * @brief 全ての発注残を、集計で高速に参照できるマップ形式で取得します。
 * @param conn データベース接続
 * @return map[string]float64 包装ごとのキーを文字列にしたマップ
 * @return error 処理中にエラーが発生した場合
 * @details
 * キーは "YJコード|包装形態|内包装数量|YJ単位名" の形式で生成されます。
 * 在庫元帳の計算（GetStockLedger）で使われます。
 */
func GetAllBackordersMap(conn *sql.DB) (map[string]float64, error) {
	const q = `
		SELECT yj_code, package_form, jan_pack_inner_qty, yj_unit_name, SUM(remaining_quantity)
		FROM backorders
		GROUP BY yj_code, package_form, jan_pack_inner_qty, yj_unit_name`
	rows, err := conn.Query(q)
	if err != nil {
		return nil, fmt.Errorf("failed to query all backorders map: %w", err)
	}
	defer rows.Close()

	backordersMap := make(map[string]float64)
	for rows.Next() {
		var yjCode, packageForm, yjUnitName string
		var janPackInnerQty, totalRemaining float64
		if err := rows.Scan(&yjCode, &packageForm, &janPackInnerQty, &yjUnitName, &totalRemaining); err != nil {
			return nil, err
		}
		key := fmt.Sprintf("%s|%s|%g|%s", yjCode, packageForm, janPackInnerQty, yjUnitName)
		backordersMap[key] = totalRemaining
	}
	return backordersMap, nil
}

/**
 * @brief 全ての発注残を画面表示用のリスト形式で取得します。
 * @param conn データベース接続
 * @return []model.Backorder 発注残レコードのスライス
 * @return error 処理中にエラーが発生した場合
 */
func GetAllBackordersList(conn *sql.DB) ([]model.Backorder, error) {
	const q = `
		SELECT
			id, order_date, yj_code, product_name, package_form, jan_pack_inner_qty, 
			yj_unit_name, order_quantity, remaining_quantity, wholesaler_code,
			yj_pack_unit_qty, jan_pack_unit_qty, jan_unit_code
		FROM backorders
		ORDER BY order_date, product_name, id
	`
	rows, err := conn.Query(q)
	if err != nil {
		return nil, fmt.Errorf("failed to query all backorders list: %w", err)
	}
	defer rows.Close()

	var backorders []model.Backorder
	for rows.Next() {
		var bo model.Backorder
		if err := rows.Scan(
			&bo.ID, &bo.OrderDate, &bo.YjCode, &bo.ProductName, &bo.PackageForm, &bo.JanPackInnerQty,
			&bo.YjUnitName, &bo.OrderQuantity, &bo.RemainingQuantity, &bo.WholesalerCode,
			&bo.YjPackUnitQty, &bo.JanPackUnitQty, &bo.JanUnitCode,
		); err != nil {
			return nil, err
		}
		backorders = append(backorders, bo)
	}
	return backorders, nil
}

/**
 * @brief 指定されたIDの発注残レコードをトランザクション内で削除します。
 * @param tx SQLトランザクションオブジェクト
 * @param id 削除対象のID
 * @return error 処理中にエラーが発生した場合
 */
func DeleteBackorderInTx(tx *sql.Tx, id int) error {
	const q = `DELETE FROM backorders WHERE id = ?`

	res, err := tx.Exec(q, id)
	if err != nil {
		return fmt.Errorf("failed to delete backorder for id %d: %w", id, err)
	}
	rowsAffected, err := res.RowsAffected()
	if err != nil {
		return fmt.Errorf("failed to get rows affected for backorder id %d: %w", id, err)
	}
	if rowsAffected == 0 {
		return fmt.Errorf("no backorder found to delete for id %d", id)
	}
	return nil
}

// ▲▲▲【修正ここまで】▲▲▲


----- C:\Users\wasab\OneDrive\デスクトップ\WASABI\db\cleanup.go -----
// C:\Users\wasab\OneDrive\デスクトップ\WASABI\db\cleanup.go

package db

import (
	"database/sql"
	"fmt"
	"strings"
	"time"
	"wasabi/model"
)

// GetCleanupCandidates は整理対象となる製品マスターのリストを取得します。
func GetCleanupCandidates(conn *sql.DB) ([]*model.ProductMaster, error) {
	// 1. 全製品の現在の理論在庫を取得
	stockMap, err := GetAllCurrentStockMap(conn)
	if err != nil {
		return nil, fmt.Errorf("failed to get all current stock: %w", err)
	}

	// 在庫がゼロの製品コードをリストアップ
	var zeroStockProductCodes []string
	allProductCodes, err := getAllProductCodes(conn)
	if err != nil {
		return nil, err
	}
	for _, pc := range allProductCodes {
		if stock, ok := stockMap[pc]; !ok || stock == 0 {
			zeroStockProductCodes = append(zeroStockProductCodes, pc)
		}
	}

	if len(zeroStockProductCodes) == 0 {
		return []*model.ProductMaster{}, nil
	}

	// 2. 在庫ゼロの製品について、過去3ヶ月の取引履歴を確認
	cutoffDate := time.Now().AddDate(0, -3, 0).Format("20060102")

	placeholders := strings.Repeat("?,", len(zeroStockProductCodes)-1) + "?"
	query := fmt.Sprintf(`
		SELECT DISTINCT jan_code FROM transaction_records
		WHERE flag IN (1, 2, 3, 11, 12)
		AND transaction_date >= ?
		AND jan_code IN (%s)
	`, placeholders)

	args := make([]interface{}, 0, len(zeroStockProductCodes)+1)
	args = append(args, cutoffDate)
	for _, pc := range zeroStockProductCodes {
		args = append(args, pc)
	}

	rows, err := conn.Query(query, args...)
	if err != nil {
		return nil, fmt.Errorf("failed to query recent transactions: %w", err)
	}
	defer rows.Close()

	// 期間内に動きがあった製品をマップに記録
	movedProducts := make(map[string]bool)
	for rows.Next() {
		var productCode string
		if err := rows.Scan(&productCode); err != nil {
			return nil, err
		}
		movedProducts[productCode] = true
	}

	// 3. 動きがなかった製品コードのみを抽出
	var finalCandidateCodes []string
	for _, pc := range zeroStockProductCodes {
		if !movedProducts[pc] {
			finalCandidateCodes = append(finalCandidateCodes, pc)
		}
	}

	if len(finalCandidateCodes) == 0 {
		return []*model.ProductMaster{}, nil
	}

	// 4. 最終候補のマスター情報を取得して返す
	mastersMap, err := GetProductMastersByCodesMap(conn, finalCandidateCodes)
	if err != nil {
		return nil, fmt.Errorf("failed to get final candidate masters: %w", err)
	}

	var result []*model.ProductMaster
	for _, code := range finalCandidateCodes {
		if master, ok := mastersMap[code]; ok {
			result = append(result, master)
		}
	}
	return result, nil
}

// DeleteMastersByCodesInTx は指定された製品コードのマスターを削除します。
func DeleteMastersByCodesInTx(tx *sql.Tx, productCodes []string) (int64, error) {
	if len(productCodes) == 0 {
		return 0, nil
	}
	placeholders := strings.Repeat("?,", len(productCodes)-1) + "?"
	query := fmt.Sprintf("DELETE FROM product_master WHERE product_code IN (%s)", placeholders)

	args := make([]interface{}, len(productCodes))
	for i, code := range productCodes {
		args[i] = code
	}

	res, err := tx.Exec(query, args...)
	if err != nil {
		return 0, fmt.Errorf("failed to delete masters: %w", err)
	}
	return res.RowsAffected()
}

// getAllProductCodes は product_master から全ての製品コードを取得するヘルパー関数です。
func getAllProductCodes(conn *sql.DB) ([]string, error) {
	rows, err := conn.Query("SELECT product_code FROM product_master")
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var codes []string
	for rows.Next() {
		var code string
		if err := rows.Scan(&code); err != nil {
			return nil, err
		}
		codes = append(codes, code)
	}
	return codes, nil
}


----- C:\Users\wasab\OneDrive\デスクトップ\WASABI\db\clients.go -----
// C:\Users\wasab\OneDrive\デスクトップ\WASABI\db\clients.go

package db

import (
	"database/sql"
	"fmt"
	"wasabi/model"
)

/**
 * @brief 新しい得意先レコードをトランザクション内で作成します。
 * @param tx SQLトランザクションオブジェクト
 * @param code 新しい得意先コード
 * @param name 新しい得意先名
 * @return error 処理中にエラーが発生した場合
 */
func CreateClientInTx(tx *sql.Tx, code, name string) error {
	const q = `INSERT INTO client_master (client_code, client_name) VALUES (?, ?)`
	_, err := tx.Exec(q, code, name)
	if err != nil {
		return fmt.Errorf("CreateClientInTx failed: %w", err)
	}
	return nil
}

/**
 * @brief 指定された名前の得意先が既に存在するかをトランザクション内で確認します。
 * @param tx SQLトランザクションオブジェクト
 * @param name 確認する得意先名
 * @return bool 存在する場合は true, しない場合は false
 * @return error 処理中にエラーが発生した場合
 */
func CheckClientExistsByName(tx *sql.Tx, name string) (bool, error) {
	var exists int
	const q = `SELECT 1 FROM client_master WHERE client_name = ? LIMIT 1`
	err := tx.QueryRow(q, name).Scan(&exists)
	if err != nil {
		if err == sql.ErrNoRows {
			// レコードが存在しないのはエラーではない
			return false, nil
		}
		return false, fmt.Errorf("CheckClientExistsByName failed: %w", err)
	}
	return true, nil
}

/**
 * @brief 全ての得意先を client_code 順で取得します。
 * @param conn データベース接続
 * @return []model.Client 得意先のスライス
 * @return error 処理中にエラーが発生した場合
 */
func GetAllClients(conn *sql.DB) ([]model.Client, error) {
	rows, err := conn.Query("SELECT client_code, client_name FROM client_master ORDER BY client_code")
	if err != nil {
		return nil, fmt.Errorf("failed to get all clients: %w", err)
	}
	defer rows.Close()

	// 空のスライスで初期化することで、得意先が0件の場合にJSONでnullではなく空配列[]を返す
	clients := make([]model.Client, 0)
	for rows.Next() {
		var c model.Client
		if err := rows.Scan(&c.Code, &c.Name); err != nil {
			return nil, err
		}
		clients = append(clients, c)
	}
	return clients, nil
}


----- C:\Users\wasab\OneDrive\デスクトップ\WASABI\db\db.go -----
// C:\Users\wasab\OneDrive\デスクトップ\WASABI\db\db.go

package db

import "database/sql"

// DBTXは、*sql.DB（データベース接続プール）と*sql.Tx（トランザクション）の両方が
// 満たすことができるインターフェースです。
//
// このインターフェースを関数の引数として使用することで、同じデータベース操作のロジックを
// トランザクションの内外で再利用できます。これにより、コードの重複が削減され、
// メンテナンス性が向上します。
type DBTX interface {
	Exec(query string, args ...interface{}) (sql.Result, error)
	Query(query string, args ...interface{}) (*sql.Rows, error)
	QueryRow(query string, args ...interface{}) *sql.Row
}


----- C:\Users\wasab\OneDrive\デスクトップ\WASABI\db\deadstock.go -----
// C:\Users\wasab\OneDrive\デスクトップ\WASABI\db\dead_stock.go
package db

import (
	"database/sql"
	"fmt"
	"sort"
	"strings"
	"time"
	"wasabi/model"
)

func DeleteDeadStockByProductCodesInTx(tx *sql.Tx, productCodes []string) error {
	if len(productCodes) == 0 {
		return nil
	}
	placeholders := strings.Repeat("?,", len(productCodes)-1) + "?"
	query := fmt.Sprintf("DELETE FROM dead_stock_list WHERE product_code IN (%s)", placeholders)

	args := make([]interface{}, len(productCodes))
	for i, code := range productCodes {
		args[i] = code
	}

	_, err := tx.Exec(query, args...)
	if err != nil {
		return fmt.Errorf("failed to delete dead stock records by product codes: %w", err)
	}
	return nil
}

func GetDeadStockList(conn *sql.DB, filters model.DeadStockFilters) ([]model.DeadStockGroup, error) {
	currentStockMap, err := GetAllCurrentStockMap(conn)
	if err != nil {
		return nil, fmt.Errorf("failed to get current stock for dead stock list: %w", err)
	}

	lastUsageDateMap, err := getLastTransactionDateMap(conn, 3) // flag=3 は処方
	if err != nil {
		return nil, fmt.Errorf("failed to get last usage dates: %w", err)
	}

	var deadStockProductCodes []string
	for productCode, stock := range currentStockMap {
		if stock <= 0 {
			continue
		}
		lastUsageDate, ok := lastUsageDateMap[productCode]
		if !ok || lastUsageDate < filters.StartDate {
			deadStockProductCodes = append(deadStockProductCodes, productCode)
		}
	}

	if len(deadStockProductCodes) == 0 {
		return []model.DeadStockGroup{}, nil
	}

	mastersMap, err := GetProductMastersByCodesMap(conn, deadStockProductCodes)
	if err != nil {
		return nil, fmt.Errorf("failed to get masters for dead stock candidates: %w", err)
	}

	filteredMastersMap := make(map[string]*model.ProductMaster)
	for code, master := range mastersMap {
		keep := true
		if filters.KanaName != "" {
			if !strings.Contains(master.ProductName, filters.KanaName) && !strings.Contains(master.KanaName, filters.KanaName) {
				keep = false
			}
		}
		if filters.DosageForm != "" {
			if master.UsageClassification != filters.DosageForm {
				keep = false
			}
		}
		if filters.ShelfNumber != "" {
			if !strings.Contains(master.ShelfNumber, filters.ShelfNumber) {
				keep = false
			}
		}
		if keep {
			filteredMastersMap[code] = master
		}
	}

	var filteredProductCodes []string
	for code := range filteredMastersMap {
		filteredProductCodes = append(filteredProductCodes, code)
	}

	if len(filteredProductCodes) == 0 {
		return []model.DeadStockGroup{}, nil
	}

	deadStockRecordsMap, err := getDeadStockRecordsByProductCodes(conn, filteredProductCodes)
	if err != nil {
		return nil, fmt.Errorf("failed to get dead stock records for candidates: %w", err)
	}

	groups := make(map[string]*model.DeadStockGroup)
	for _, productCode := range filteredProductCodes {
		master, ok := filteredMastersMap[productCode]
		if !ok {
			continue
		}

		group, ok := groups[master.YjCode]
		if !ok {
			group = &model.DeadStockGroup{
				YjCode:      master.YjCode,
				ProductName: master.ProductName,
			}
			groups[master.YjCode] = group
		}

		packageKey := fmt.Sprintf("%s|%g|%s", master.PackageForm, master.JanPackInnerQty, master.YjUnitName)
		var pkgGroup *model.DeadStockPackageGroup
		for i := range group.PackageGroups {
			if group.PackageGroups[i].PackageKey == packageKey {
				pkgGroup = &group.PackageGroups[i]
				break
			}
		}
		if pkgGroup == nil {
			group.PackageGroups = append(group.PackageGroups, model.DeadStockPackageGroup{PackageKey: packageKey})
			pkgGroup = &group.PackageGroups[len(group.PackageGroups)-1]
		}

		dsProduct := model.DeadStockProduct{
			ProductMaster: *master,
			CurrentStock:  currentStockMap[productCode],
			SavedRecords:  deadStockRecordsMap[productCode],
			LastUsageDate: lastUsageDateMap[productCode],
		}

		pkgGroup.Products = append(pkgGroup.Products, dsProduct)
		pkgGroup.TotalStock += dsProduct.CurrentStock
		group.TotalStock += dsProduct.CurrentStock
	}

	var result []model.DeadStockGroup
	for _, group := range groups {
		result = append(result, *group)
	}

	sort.Slice(result, func(i, j int) bool {
		prio := map[string]int{
			"1": 1, "内": 1, "2": 2, "外": 2, "3": 3, "注": 3,
			"4": 4, "歯": 4, "5": 5, "機": 5, "6": 6, "他": 6,
		}

		var masterI, masterJ *model.ProductMaster
		if len(result[i].PackageGroups) > 0 && len(result[i].PackageGroups[0].Products) > 0 {
			masterI = &result[i].PackageGroups[0].Products[0].ProductMaster
		}
		if len(result[j].PackageGroups) > 0 && len(result[j].PackageGroups[0].Products) > 0 {
			masterJ = &result[j].PackageGroups[0].Products[0].ProductMaster
		}

		if masterI == nil || masterJ == nil {
			return result[i].YjCode < result[j].YjCode
		}

		prioI, okI := prio[strings.TrimSpace(masterI.UsageClassification)]
		if !okI {
			prioI = 7
		}
		prioJ, okJ := prio[strings.TrimSpace(masterJ.UsageClassification)]
		if !okJ {
			prioJ = 7
		}
		if prioI != prioJ {
			return prioI < prioJ
		}
		return masterI.KanaName < masterJ.KanaName
	})

	return result, nil
}

func getLastTransactionDateMap(conn *sql.DB, flag int) (map[string]string, error) {
	query := `SELECT jan_code, MAX(transaction_date) FROM transaction_records WHERE flag = ? GROUP BY jan_code`
	rows, err := conn.Query(query, flag)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	dateMap := make(map[string]string)
	for rows.Next() {
		var janCode, date string
		if err := rows.Scan(&janCode, &date); err != nil {
			return nil, err
		}
		dateMap[janCode] = date
	}
	return dateMap, nil
}

func getDeadStockRecordsByProductCodes(conn *sql.DB, productCodes []string) (map[string][]model.DeadStockRecord, error) {
	recordsMap := make(map[string][]model.DeadStockRecord)
	if len(productCodes) == 0 {
		return recordsMap, nil
	}

	placeholders := strings.Repeat("?,", len(productCodes)-1) + "?"
	query := fmt.Sprintf(`SELECT id, product_code, stock_quantity_jan, expiry_date, lot_number FROM dead_stock_list WHERE product_code IN (%s)`, placeholders)

	args := make([]interface{}, len(productCodes))
	for i, code := range productCodes {
		args[i] = code
	}

	rows, err := conn.Query(query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	for rows.Next() {
		var r model.DeadStockRecord
		if err := rows.Scan(&r.ID, &r.ProductCode, &r.StockQuantityJan, &r.ExpiryDate, &r.LotNumber); err != nil {
			return nil, err
		}
		recordsMap[r.ProductCode] = append(recordsMap[r.ProductCode], r)
	}
	return recordsMap, nil
}

func SaveDeadStockListInTx(tx *sql.Tx, records []model.DeadStockRecord) error {
	const q = `
        INSERT OR REPLACE INTO dead_stock_list 
        (product_code, yj_code, package_form, jan_pack_inner_qty, yj_unit_name, 
        stock_quantity_jan, expiry_date, lot_number, created_at)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`

	stmt, err := tx.Prepare(q)
	if err != nil {
		return fmt.Errorf("failed to prepare statement for dead_stock_list: %w", err)
	}
	defer stmt.Close()

	createdAt := time.Now().Format("2006-01-02 15:04:05")

	for _, rec := range records {
		_, err := stmt.Exec(
			rec.ProductCode, rec.YjCode, rec.PackageForm, rec.JanPackInnerQty, rec.YjUnitName,
			rec.StockQuantityJan, rec.ExpiryDate, rec.LotNumber, createdAt,
		)
		if err != nil {
			return fmt.Errorf("failed to insert/replace dead_stock_list for product %s: %w", rec.ProductCode, err)
		}
	}
	return nil
}

func GetDeadStockByYjCode(tx *sql.Tx, yjCode string) ([]model.DeadStockRecord, error) {
	const q = `
		SELECT id, product_code, stock_quantity_jan, expiry_date, lot_number 
		FROM dead_stock_list 
		WHERE yj_code = ? 
		ORDER BY product_code, expiry_date, lot_number`

	rows, err := tx.Query(q, yjCode)
	if err != nil {
		return nil, fmt.Errorf("failed to query dead stock by yj_code: %w", err)
	}
	defer rows.Close()

	var records []model.DeadStockRecord
	for rows.Next() {
		var r model.DeadStockRecord
		if err := rows.Scan(&r.ID, &r.ProductCode, &r.StockQuantityJan, &r.ExpiryDate, &r.LotNumber); err != nil {
			return nil, err
		}
		records = append(records, r)
	}
	return records, nil
}


----- C:\Users\wasab\OneDrive\デスクトップ\WASABI\db\guided_inventory.go -----
package db

import (
	"database/sql"
	"fmt"
	"strings"
	"wasabi/mappers"
	"wasabi/model"
)

func SaveGuidedInventoryData(tx *sql.Tx, date string, yjCode string, allPackagings []model.ProductMaster, inventoryData map[string]float64, deadstockData []model.DeadStockRecord) error {
	var allProductCodes []string
	mastersMap := make(map[string]*model.ProductMaster)
	for _, pkg := range allPackagings {
		allProductCodes = append(allProductCodes, pkg.ProductCode)
		p := pkg
		mastersMap[pkg.ProductCode] = &p
	}

	if len(allProductCodes) > 0 {
		placeholders := strings.Repeat("?,", len(allProductCodes)-1) + "?"
		pastDeleteQuery := fmt.Sprintf(`DELETE FROM transaction_records WHERE flag = 0 AND transaction_date < ? AND jan_code IN (%s)`, placeholders)
		args := make([]interface{}, 0, len(allProductCodes)+1)
		args = append(args, date)
		for _, code := range allProductCodes {
			args = append(args, code)
		}
		if _, err := tx.Exec(pastDeleteQuery, args...); err != nil {
			return fmt.Errorf("failed to delete past inventory records: %w", err)
		}
	}

	if err := DeleteTransactionsByFlagAndDateAndCodes(tx, 0, date, allProductCodes); err != nil {
		return fmt.Errorf("failed to delete old inventory records for the same day: %w", err)
	}

	const q = `
INSERT INTO transaction_records (
    transaction_date, client_code, receipt_number, line_number, flag,
    jan_code, yj_code, product_name, kana_name, usage_classification, package_form, package_spec, maker_name,
    dat_quantity, jan_pack_inner_qty, jan_quantity, jan_pack_unit_qty, jan_unit_name, jan_unit_code,
    yj_quantity, yj_pack_unit_qty, yj_unit_name, unit_price, purchase_price, supplier_wholesale,
    subtotal, tax_amount, tax_rate, expiry_date, lot_number, flag_poison,
    flag_deleterious, flag_narcotic, flag_psychotropic, flag_stimulant,
    flag_stimulant_raw, process_flag_ma
) VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)`

	stmt, err := tx.Prepare(q)
	if err != nil {
		return fmt.Errorf("failed to prepare statement for inventory records: %w", err)
	}
	defer stmt.Close()

	receiptNumber := fmt.Sprintf("ADJ-%s-%s", date, yjCode)
	var productCodesWithInventory []string

	for i, productCode := range allProductCodes {
		master, ok := mastersMap[productCode]
		if !ok {
			continue
		}

		janQty := inventoryData[productCode]
		if janQty > 0 {
			productCodesWithInventory = append(productCodesWithInventory, productCode)
		}

		tr := model.TransactionRecord{
			TransactionDate: date,
			Flag:            0,
			ReceiptNumber:   receiptNumber,
			LineNumber:      fmt.Sprintf("%d", i+1),
			JanQuantity:     janQty,
			ProcessFlagMA:   "COMPLETE",
		}

		tr.YjQuantity = janQty * master.JanPackInnerQty
		mappers.MapProductMasterToTransaction(&tr, master)
		tr.ClientCode = ""
		tr.SupplierWholesale = ""

		// ▼▼▼【修正】Subtotalを計算する処理を追加 ▼▼▼
		tr.Subtotal = tr.YjQuantity * tr.UnitPrice
		// ▲▲▲【修正ここまで】▲▲▲

		_, err := stmt.Exec(
			tr.TransactionDate, tr.ClientCode, tr.ReceiptNumber, tr.LineNumber, tr.Flag,
			tr.JanCode, tr.YjCode, tr.ProductName, tr.KanaName, tr.UsageClassification, tr.PackageForm, tr.PackageSpec, tr.MakerName,
			tr.DatQuantity, tr.JanPackInnerQty, tr.JanQuantity, tr.JanPackUnitQty, tr.JanUnitName, tr.JanUnitCode,
			tr.YjQuantity, tr.YjPackUnitQty, tr.YjUnitName, tr.UnitPrice, tr.PurchasePrice, tr.SupplierWholesale,
			tr.Subtotal, tr.TaxAmount, tr.TaxRate, tr.ExpiryDate, tr.LotNumber, tr.FlagPoison,
			tr.FlagDeleterious, tr.FlagNarcotic, tr.FlagPsychotropic, tr.FlagStimulant,
			tr.FlagStimulantRaw, tr.ProcessFlagMA,
		)
		if err != nil {
			return fmt.Errorf("failed to insert inventory record for %s: %w", productCode, err)
		}
	}

	if len(productCodesWithInventory) > 0 {
		var relevantDeadstockData []model.DeadStockRecord
		for _, ds := range deadstockData {
			for _, pid := range productCodesWithInventory {
				if ds.ProductCode == pid {
					relevantDeadstockData = append(relevantDeadstockData, ds)
					break
				}
			}
		}

		if err := DeleteDeadStockByProductCodesInTx(tx, productCodesWithInventory); err != nil {
			return fmt.Errorf("failed to delete old dead stock records: %w", err)
		}
		if err := SaveDeadStockListInTx(tx, relevantDeadstockData); err != nil {
			return fmt.Errorf("failed to upsert new dead stock records: %w", err)
		}
	}

	return nil
}


----- C:\Users\wasab\OneDrive\デスクトップ\WASABI\db\jcshms.go -----
// C:\Users\wasab\OneDrive\デスクトップ\WASABI\db\jcshms.go
package db

import (
	"database/sql"
	"fmt"
	"strconv"
	"strings"
	"wasabi/model"
)

/**
 * @brief 複数のJANコードに対応するJCSHMSおよびJANCODEマスター情報を一括で取得し、マップ形式で返します。
 * @param tx SQLトランザクションオブジェクト
 * @param jans 検索対象のJANコードのスライス
 * @return map[string]*model.JCShms JANコードをキーとしたJCSHMS情報のマップ
 * @return error 処理中にエラーが発生した場合
 */
func GetJcshmsByCodesMap(tx *sql.Tx, jans []string) (map[string]*model.JCShms, error) {
	if len(jans) == 0 {
		return make(map[string]*model.JCShms), nil
	}

	results := make(map[string]*model.JCShms)
	args := make([]interface{}, len(jans))
	for i, jan := range jans {
		args[i] = jan
		results[jan] = &model.JCShms{}
	}

	inClause := `(?` + strings.Repeat(",?", len(jans)-1) + `)`

	q1 := `SELECT JC000, JC009, JC013, JC018, JC020, JC022, JC030, JC037, JC039, JC044, JC049, JC050,
	              JC061, JC062, JC063, JC064, JC065, JC066, JC122, JC124
	        FROM jcshms WHERE JC000 IN ` + inClause

	rows1, err := tx.Query(q1, args...)
	if err != nil {
		return nil, fmt.Errorf("jcshms bulk search failed: %w", err)
	}
	defer rows1.Close()

	for rows1.Next() {
		var jan string
		var jcshmsPart model.JCShms
		var jc050 sql.NullString
		// ▼▼▼【ここから修正】▼▼▼
		var jc124 sql.NullFloat64
		if err := rows1.Scan(&jan, &jcshmsPart.JC009, &jcshmsPart.JC013, &jcshmsPart.JC018, &jcshmsPart.JC020, &jcshmsPart.JC022, &jcshmsPart.JC030,
			&jcshmsPart.JC037, &jcshmsPart.JC039, &jcshmsPart.JC044, &jcshmsPart.JC049, &jc050,
			&jcshmsPart.JC061, &jcshmsPart.JC062, &jcshmsPart.JC063, &jcshmsPart.JC064, &jcshmsPart.JC065, &jcshmsPart.JC066, &jcshmsPart.JC122, &jc124,
		); err != nil {
			return nil, err
		}
		// ▲▲▲【修正ここまで】▲▲▲

		res := results[jan]
		res.JC009, res.JC013, res.JC018, res.JC020, res.JC022 = jcshmsPart.JC009, jcshmsPart.JC013, jcshmsPart.JC018, jcshmsPart.JC020, jcshmsPart.JC022
		res.JC030, res.JC037, res.JC039 = jcshmsPart.JC030, jcshmsPart.JC037, jcshmsPart.JC039
		res.JC044 = jcshmsPart.JC044
		res.JC061, res.JC062, res.JC063, res.JC064, res.JC065, res.JC066 = jcshmsPart.JC061, jcshmsPart.JC062, jcshmsPart.JC063, jcshmsPart.JC064, jcshmsPart.JC065, jcshmsPart.JC066
		res.JC122 = jcshmsPart.JC122
		res.JC049 = jcshmsPart.JC049
		// ▼▼▼【ここから修正】▼▼▼
		res.JC124 = jc124.Float64
		// ▲▲▲【修正ここまで】▲▲▲

		val, err := strconv.ParseFloat(jc050.String, 64)
		if err != nil {
			res.JC050 = 0
		} else {
			res.JC050 = val
		}
	}

	q2 := `SELECT JA001, JA006, JA007, JA008 FROM jancode WHERE JA001 IN ` + inClause
	rows2, err := tx.Query(q2, args...)
	if err != nil {
		return nil, fmt.Errorf("jancode bulk search failed: %w", err)
	}
	defer rows2.Close()

	for rows2.Next() {
		var jan string
		var jaPart struct {
			JA006 sql.NullFloat64
			JA007 sql.NullString
			JA008 sql.NullFloat64
		}
		if err := rows2.Scan(&jan, &jaPart.JA006, &jaPart.JA007, &jaPart.JA008); err != nil {
			return nil, err
		}
		results[jan].JA006 = jaPart.JA006
		results[jan].JA007 = jaPart.JA007
		results[jan].JA008 = jaPart.JA008
	}

	return results, nil
}

/**
 * @brief 単一のJANコードに対応するJCSHMSおよびJANCODEマスター情報を取得します。
 * @param tx SQLトランザクションオブジェクト
 * @param jan 検索対象のJANコード
 * @return *model.JCShms JCSHMS情報
 * @return error 処理中にエラーが発生した場合
 */
func GetJcshmsRecordByJan(tx *sql.Tx, jan string) (*model.JCShms, error) {
	jcshms := &model.JCShms{}
	var jc050 sql.NullString
	// ▼▼▼【ここから修正】▼▼▼
	var jc124 sql.NullFloat64
	// ▲▲▲【修正ここまで】▲▲▲

	q1 := `SELECT JC009, JC013, JC018, JC020, JC022, JC030, JC037, JC039, JC044, JC049, JC050,
				  JC061, JC062, JC063, JC064, JC065, JC066, JC122, JC124
		   FROM jcshms WHERE JC000 = ?`
	// ▼▼▼【ここから修正】▼▼▼
	err := tx.QueryRow(q1, jan).Scan(
		&jcshms.JC009, &jcshms.JC013, &jcshms.JC018, &jcshms.JC020, &jcshms.JC022, &jcshms.JC030,
		&jcshms.JC037, &jcshms.JC039, &jcshms.JC044, &jcshms.JC049, &jc050,
		&jcshms.JC061, &jcshms.JC062, &jcshms.JC063, &jcshms.JC064, &jcshms.JC065, &jcshms.JC066, &jcshms.JC122, &jc124,
	)
	// ▲▲▲【修正ここまで】▲▲▲
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, err
		}
		return nil, fmt.Errorf("jcshms single search failed for jan %s: %w", jan, err)
	}

	// ▼▼▼【ここから修正】▼▼▼
	jcshms.JC124 = jc124.Float64
	// ▲▲▲【修正ここまで】▲▲▲
	val, err := strconv.ParseFloat(jc050.String, 64)
	if err != nil {
		jcshms.JC050 = 0
	} else {
		jcshms.JC050 = val
	}

	q2 := `SELECT JA006, JA007, JA008 FROM jancode WHERE JA001 = ?`
	err = tx.QueryRow(q2, jan).Scan(&jcshms.JA006, &jcshms.JA007, &jcshms.JA008)
	if err != nil && err != sql.ErrNoRows {
		return nil, fmt.Errorf("jancode single search failed for jan %s: %w", jan, err)
	}

	return jcshms, nil
}

/**
 * @brief 単一のGS1コードに対応するJCSHMSおよびJANCODEマスター情報を取得します。
 * @param tx SQLトランザクションオブジェクト
 * @param gs1Code 検索対象のGS1コード
 * @return *model.JCShms JCSHMS情報
 * @return string 見つかったJANコード
 * @return error 処理中にエラーが発生した場合
 */
func GetJcshmsRecordByGS1(tx *sql.Tx, gs1Code string) (*model.JCShms, string, error) {
	jcshms := &model.JCShms{}
	var jc050 sql.NullString
	var janCode string
	// ▼▼▼【ここから修正】▼▼▼
	var jc124 sql.NullFloat64
	// ▲▲▲【修正ここまで】▲▲▲

	q1 := `SELECT JC000, JC009, JC013, JC018, JC020, JC022, JC030, JC037, JC039, JC044, JC049, JC050,
				  JC061, JC062, JC063, JC064, JC065, JC066, JC122, JC124
		   FROM jcshms WHERE JC122 = ?`
	// ▼▼▼【ここから修正】▼▼▼
	err := tx.QueryRow(q1, gs1Code).Scan(
		&janCode, &jcshms.JC009, &jcshms.JC013, &jcshms.JC018, &jcshms.JC020, &jcshms.JC022, &jcshms.JC030,
		&jcshms.JC037, &jcshms.JC039, &jcshms.JC044, &jcshms.JC049, &jc050,
		&jcshms.JC061, &jcshms.JC062, &jcshms.JC063, &jcshms.JC064, &jcshms.JC065, &jcshms.JC066, &jcshms.JC122, &jc124,
	)
	// ▲▲▲【修正ここまで】▲▲▲
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, "", err
		}
		return nil, "", fmt.Errorf("jcshms single search by gs1 failed for gs1 %s: %w", gs1Code, err)
	}

	// ▼▼▼【ここから修正】▼▼▼
	jcshms.JC124 = jc124.Float64
	// ▲▲▲【修正ここまで】▲▲▲
	val, err := strconv.ParseFloat(jc050.String, 64)
	if err != nil {
		jcshms.JC050 = 0
	} else {
		jcshms.JC050 = val
	}

	q2 := `SELECT JA006, JA007, JA008 FROM jancode WHERE JA001 = ?`
	err = tx.QueryRow(q2, janCode).Scan(&jcshms.JA006, &jcshms.JA007, &jcshms.JA008)
	if err != nil && err != sql.ErrNoRows {
		return nil, "", fmt.Errorf("jancode single search failed for jan %s: %w", janCode, err)
	}

	return jcshms, janCode, nil
}


----- C:\Users\wasab\OneDrive\デスクトップ\WASABI\db\migrations.go -----
// C:\Users\wasab\OneDrive\デスクトップ\WASABI\db\migrations.go

package db

import (
	"database/sql"
	"fmt"
	"log"
)

/**
 * @brief データベースのマイグレーション（スキーマの更新）を適用します。
 * @param conn データベース接続
 * @return error 処理中にエラーが発生した場合
 * @details
 * アプリケーションの起動時に呼び出され、不足しているインデックスなどを追加します。
 * 各SQL文は `IF NOT EXISTS` を使用しているため、何度実行しても安全です。
 */
func ApplyMigrations(conn *sql.DB) error {
	migrations := []string{
		// パフォーマンス改善のためのインデックス
		`CREATE INDEX IF NOT EXISTS idx_transactions_receipt_number ON transaction_records (receipt_number);`,
		`CREATE INDEX IF NOT EXISTS idx_transactions_process_flag_ma ON transaction_records (process_flag_ma);`,
		`CREATE INDEX IF NOT EXISTS idx_transactions_flag_date ON transaction_records (flag, transaction_date);`,
	}

	log.Println("Applying database migrations...")
	for _, migration := range migrations {
		if _, err := conn.Exec(migration); err != nil {
			return fmt.Errorf("failed to apply migration (%s): %w", migration, err)
		}
	}
	log.Println("Database migrations applied successfully.")
	return nil
}


----- C:\Users\wasab\OneDrive\デスクトップ\WASABI\db\precomp.go -----
// C:\Users\wasab\OneDrive\デスクトップ\WASABI\db\precomp.go

package db

import (
	"database/sql"
	"fmt"
	"strings"
	"time"
	"wasabi/mappers"
	"wasabi/model"
)

// PrecompRecordInput はフロントエンドから受け取る予製レコードの構造体です。
type PrecompRecordInput struct {
	ProductCode string  `json:"productCode"`
	JanQuantity float64 `json:"janQuantity"`
}

// PrecompRecordView は予製データを画面に表示するための構造体です。
// NOTE: この構造体は現在直接使用されていませんが、将来的な拡張のために残されています。
type PrecompRecordView struct {
	model.TransactionRecord
	FormattedPackageSpec string `json:"formattedPackageSpec"`
	JanUnitName          string `json:"janUnitName"`
}

// ▼▼▼【ここから修正・追加】▼▼▼

/**
 * @brief 特定の患者の予製レコードをデータベースと安全に同期します。
 * @param tx SQLトランザクションオブジェクト
 * @param patientNumber 対象の患者番号
 * @param records フロントエンドから送信された最新の予製レコードのスライス
 * @return error 処理中にエラーが発生した場合
 * @details
 * データベースの状態をフロントエンドの状態と完全に一致させます。
 * この際、ステータスは常に 'active' (有効) に設定されます。
 */
func UpsertPreCompoundingRecordsInTx(tx *sql.Tx, patientNumber string, records []PrecompRecordInput) error {
	if len(records) == 0 {
		if _, err := tx.Exec("DELETE FROM precomp_records WHERE client_code = ?", patientNumber); err != nil {
			return fmt.Errorf("failed to delete all precomp records for patient %s: %w", patientNumber, err)
		}
		return nil
	}

	productCodesInPayload := make([]interface{}, len(records)+1)
	placeholders := make([]string, len(records))
	productCodesInPayload[0] = patientNumber
	for i, rec := range records {
		placeholders[i] = "?"
		productCodesInPayload[i+1] = rec.ProductCode
	}

	deleteQuery := fmt.Sprintf("DELETE FROM precomp_records WHERE client_code = ? AND jan_code NOT IN (%s)", strings.Join(placeholders, ","))
	if _, err := tx.Exec(deleteQuery, productCodesInPayload...); err != nil {
		return fmt.Errorf("failed to delete removed precomp records for patient %s: %w", patientNumber, err)
	}

	var productCodes []string
	for _, rec := range records {
		productCodes = append(productCodes, rec.ProductCode)
	}
	mastersMap, err := GetProductMastersByCodesMap(tx, productCodes)
	if err != nil {
		return fmt.Errorf("failed to get product masters for precomp: %w", err)
	}

	const q = `INSERT INTO precomp_records (
		transaction_date, client_code, receipt_number, line_number, jan_code, yj_code, product_name, kana_name,
		usage_classification, package_form, package_spec, maker_name, jan_pack_inner_qty, jan_quantity,
		jan_pack_unit_qty, jan_unit_name, jan_unit_code, yj_quantity, yj_pack_unit_qty, yj_unit_name,
		purchase_price, supplier_wholesale, created_at, status
	) VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
	ON CONFLICT(client_code, jan_code) DO UPDATE SET
		jan_quantity = excluded.jan_quantity,
		yj_quantity = excluded.yj_quantity,
		created_at = excluded.created_at,
		status = excluded.status`

	stmt, err := tx.Prepare(q)
	if err != nil {
		return fmt.Errorf("failed to prepare precomp upsert statement: %w", err)
	}
	defer stmt.Close()

	now := time.Now()
	dateStr := now.Format("20060102")
	receiptNumber := fmt.Sprintf("PRECOMP-%s", patientNumber)

	for i, rec := range records {
		master, ok := mastersMap[rec.ProductCode]
		if !ok {
			continue
		}

		tr := model.TransactionRecord{
			TransactionDate: dateStr,
			ClientCode:      patientNumber,
			ReceiptNumber:   receiptNumber,
			LineNumber:      fmt.Sprintf("%d", i+1),
			JanCode:         rec.ProductCode,
			JanQuantity:     rec.JanQuantity,
		}
		if master.JanPackInnerQty > 0 {
			tr.YjQuantity = rec.JanQuantity * master.JanPackInnerQty
		}

		mappers.MapProductMasterToTransaction(&tr, master)

		_, err := stmt.Exec(
			tr.TransactionDate, tr.ClientCode, tr.ReceiptNumber, tr.LineNumber, tr.JanCode, tr.YjCode, tr.ProductName, tr.KanaName,
			tr.UsageClassification, tr.PackageForm, tr.PackageSpec, tr.MakerName, tr.JanPackInnerQty, tr.JanQuantity,
			tr.JanPackUnitQty, tr.JanUnitName, tr.JanUnitCode, tr.YjQuantity, tr.YjPackUnitQty, tr.YjUnitName,
			tr.PurchasePrice, tr.SupplierWholesale, now.Format("2006-01-02 15:04:05"), "active",
		)
		if err != nil {
			return fmt.Errorf("failed to upsert precomp record for product %s: %w", rec.ProductCode, err)
		}
	}

	return nil
}

/**
 * @brief 特定の患者の予製レコードをリストで取得します。
 * @param conn データベース接続
 * @param patientNumber 対象の患者番号
 * @return []model.TransactionRecord 予製レコードのスライス
 * @return error 処理中にエラーが発生した場合
 * @details
 * 予製レコードをTransactionRecordの形式で取得します。flagは5（予製）として固定値を設定します。
 */
func GetPreCompoundingRecordsByPatient(conn *sql.DB, patientNumber string) ([]model.TransactionRecord, error) {
	const q = `SELECT
		id, transaction_date, client_code, receipt_number, line_number, 5 AS flag,
		jan_code, yj_code, product_name, kana_name, usage_classification, package_form, package_spec, maker_name,
		0.0, jan_pack_inner_qty, jan_quantity, jan_pack_unit_qty, jan_unit_name, jan_unit_code,
		yj_quantity, yj_pack_unit_qty, yj_unit_name, 0.0, purchase_price, supplier_wholesale,
		0.0, 0.0, 0.0, '', '', 0, 0, 0, 0, 0, 0, ''
		FROM precomp_records WHERE client_code = ? ORDER BY id`

	rows, err := conn.Query(q, patientNumber)
	if err != nil {
		return nil, fmt.Errorf("failed to query precomp records for patient %s: %w", patientNumber, err)
	}
	defer rows.Close()

	var records []model.TransactionRecord
	for rows.Next() {
		r, err := ScanTransactionRecord(rows)
		if err != nil {
			return nil, fmt.Errorf("failed to scan precomp record: %w", err)
		}
		records = append(records, *r)
	}
	return records, nil
}

/**
 * @brief 特定の患者の予製レコードをすべて削除します。
 * @param conn データベース接続
 * @param patientNumber 対象の患者番号
 * @return error 処理中にエラーが発生した場合
 */
func DeletePreCompoundingRecordsByPatient(conn *sql.DB, patientNumber string) error {
	const q = `DELETE FROM precomp_records WHERE client_code = ?`
	if _, err := conn.Exec(q, patientNumber); err != nil {
		return fmt.Errorf("failed to delete precomp records for patient %s: %w", patientNumber, err)
	}
	return nil
}

/**
 * @brief 全製品の有効な予製引当数量の合計をマップで返します。
 * @param conn データベース接続
 * @return map[string]float64 JANコードをキー、YJ単位での合計引当数量を値とするマップ
 * @return error 処理中にエラーが発生した場合
 * @details
 * この関数が返す値は、在庫元帳の計算において発注点の調整に使用されます。
 * statusが'active'のレコードのみを集計対象とします。
 */
func GetPreCompoundingTotals(conn *sql.DB) (map[string]float64, error) {
	const q = `SELECT jan_code, SUM(yj_quantity) FROM precomp_records WHERE status = 'active' GROUP BY jan_code`
	rows, err := conn.Query(q)
	if err != nil {
		return nil, fmt.Errorf("failed to query precomp totals: %w", err)
	}
	defer rows.Close()

	totals := make(map[string]float64)
	for rows.Next() {
		var productCode string
		var totalQuantity float64
		if err := rows.Scan(&productCode, &totalQuantity); err != nil {
			return nil, fmt.Errorf("failed to scan precomp total: %w", err)
		}
		totals[productCode] = totalQuantity
	}
	return totals, nil
}

/**
 * @brief 複数の製品コードに紐づく有効な予製レコードを全て取得します。
 * @param conn データベース接続
 * @param productCodes 取得対象の製品コードのスライス
 * @return []model.TransactionRecord 予製レコードのスライス
 * @return error 処理中にエラーが発生した場合
 * @details
 * 「棚卸調整」画面で、理論在庫と実在庫の差を分析する際の参考情報として使用されます。
 */
func GetPreCompoundingDetailsByProductCodes(conn *sql.DB, productCodes []string) ([]model.TransactionRecord, error) {
	if len(productCodes) == 0 {
		return []model.TransactionRecord{}, nil
	}

	placeholders := strings.Repeat("?,", len(productCodes)-1) + "?"
	query := fmt.Sprintf(`
		SELECT
			p.id, p.transaction_date, p.client_code, p.receipt_number, p.line_number, 5 AS flag,
			p.jan_code, p.yj_code, p.product_name, p.kana_name, p.usage_classification, p.package_form, p.package_spec, p.maker_name,
			0.0, p.jan_pack_inner_qty, p.jan_quantity, p.jan_pack_unit_qty, p.jan_unit_name, p.jan_unit_code,
			p.yj_quantity, p.yj_pack_unit_qty, p.yj_unit_name, 0.0, p.purchase_price, p.supplier_wholesale,
			0.0, 0.0, 0.0, '', '', 0, 0, 0, 0, 0, 0, ''
		FROM precomp_records AS p
		WHERE p.jan_code IN (%s)
		ORDER BY p.created_at, p.client_code`, placeholders)

	args := make([]interface{}, len(productCodes))
	for i, code := range productCodes {
		args[i] = code
	}

	rows, err := conn.Query(query, args...)
	if err != nil {
		return nil, fmt.Errorf("failed to query precomp details by product codes: %w", err)
	}
	defer rows.Close()

	var records []model.TransactionRecord
	for rows.Next() {
		r, err := ScanTransactionRecord(rows)
		if err != nil {
			return nil, fmt.Errorf("failed to scan precomp detail record: %w", err)
		}
		records = append(records, *r)
	}
	return records, nil
}

/**
 * @brief 全患者の有効な予製レコードを全て取得します。
 * @param conn データベース接続
 * @return []model.TransactionRecord 予製レコードのスライス
 * @return error 処理中にエラーが発生した場合
 * @details
 * 予製データの一括CSVエクスポート機能で使用されます。
 */
func GetAllPreCompoundingRecords(conn *sql.DB) ([]model.TransactionRecord, error) {
	const q = `SELECT
		id, transaction_date, client_code, receipt_number, line_number, 5 AS flag,
		jan_code, yj_code, product_name, kana_name, usage_classification, package_form, package_spec, maker_name,
		0.0, jan_pack_inner_qty, jan_quantity, jan_pack_unit_qty, jan_unit_name, jan_unit_code,
		yj_quantity, yj_pack_unit_qty, yj_unit_name, 0.0, purchase_price, supplier_wholesale,
		0.0, 0.0, 0.0, '', '', 0, 0, 0, 0, 0, 0, ''
		FROM precomp_records 
		ORDER BY client_code, id`

	rows, err := conn.Query(q)
	if err != nil {
		return nil, fmt.Errorf("failed to query all precomp records: %w", err)
	}
	defer rows.Close()

	var records []model.TransactionRecord
	for rows.Next() {
		r, err := ScanTransactionRecord(rows)
		if err != nil {
			return nil, fmt.Errorf("failed to scan precomp record: %w", err)
		}
		records = append(records, *r)
	}
	return records, nil
}

/**
 * @brief 指定された患者の予製レコードを中断状態（inactive）にします。
 * @param tx SQLトランザクションオブジェクト
 * @param patientNumber 対象の患者番号
 * @return error 処理中にエラーが発生した場合
 */
func SuspendPreCompoundingRecordsByPatient(tx *sql.Tx, patientNumber string) error {
	const q = `UPDATE precomp_records SET status = 'inactive' WHERE client_code = ?`
	if _, err := tx.Exec(q, patientNumber); err != nil {
		return fmt.Errorf("failed to suspend precomp records for patient %s: %w", patientNumber, err)
	}
	return nil
}

/**
 * @brief 指定された患者の予製レコードを再開状態（active）にします。
 * @param tx SQLトランザクションオブジェクト
 * @param patientNumber 対象の患者番号
 * @return error 処理中にエラーが発生した場合
 */
func ResumePreCompoundingRecordsByPatient(tx *sql.Tx, patientNumber string) error {
	const q = `UPDATE precomp_records SET status = 'active' WHERE client_code = ?`
	if _, err := tx.Exec(q, patientNumber); err != nil {
		return fmt.Errorf("failed to resume precomp records for patient %s: %w", patientNumber, err)
	}
	return nil
}

/**
 * @brief 指定された患者の現在の予製ステータスを取得します。
 * @param conn データベース接続
 * @param patientNumber 対象の患者番号
 * @return string ステータス ('active', 'inactive', 'none')
 * @return error 処理中にエラーが発生した場合
 */
func GetPreCompoundingStatusByPatient(conn *sql.DB, patientNumber string) (string, error) {
	var status string
	const q = `SELECT status FROM precomp_records WHERE client_code = ? LIMIT 1`
	err := conn.QueryRow(q, patientNumber).Scan(&status)
	if err != nil {
		if err == sql.ErrNoRows {
			return "none", nil // レコードが存在しない
		}
		return "", fmt.Errorf("failed to get precomp status for patient %s: %w", patientNumber, err)
	}
	return status, nil
}

// ▲▲▲【修正ここまで】▲▲▲


----- C:\Users\wasab\OneDrive\デスクトップ\WASABI\db\product_master.go -----
package db

import (
	"database/sql"
	"fmt"
	"strings"
	"wasabi/model"
)

// SelectColumns は、product_masterテーブルから全列を取得するためのSQLスニペットです。
const SelectColumns = `
	product_code, yj_code, gs1_code, product_name, kana_name, maker_name,
	specification, usage_classification, package_form, yj_unit_name, yj_pack_unit_qty,
	jan_pack_inner_qty, jan_unit_code, jan_pack_unit_qty, origin,
	nhi_price, purchase_price,
	flag_poison, flag_deleterious, flag_narcotic, flag_psychotropic, flag_stimulant, flag_stimulant_raw,
	is_order_stopped, supplier_wholesale,
	group_code, shelf_number, category, user_notes
`

// ScanProductMaster は、データベースの行データから model.ProductMaster 構造体に値を割り当てます。
func ScanProductMaster(row interface{ Scan(...interface{}) error }) (*model.ProductMaster, error) {
	var m model.ProductMaster
	err := row.Scan(
		// 基本情報
		&m.ProductCode, &m.YjCode, &m.Gs1Code, &m.ProductName, &m.KanaName, &m.MakerName,
		// 製品仕様情報
		&m.Specification, &m.UsageClassification, &m.PackageForm, &m.YjUnitName, &m.YjPackUnitQty,
		&m.JanPackInnerQty, &m.JanUnitCode, &m.JanPackUnitQty, &m.Origin,
		// 価格情報
		&m.NhiPrice, &m.PurchasePrice,
		// 管理フラグ・情報
		&m.FlagPoison, &m.FlagDeleterious, &m.FlagNarcotic, &m.FlagPsychotropic, &m.FlagStimulant, &m.FlagStimulantRaw,
		&m.IsOrderStopped, &m.SupplierWholesale,
		// ユーザー定義項目
		&m.GroupCode, &m.ShelfNumber, &m.Category, &m.UserNotes,
	)
	if err != nil {
		return nil, err
	}
	return &m, nil
}

// UpsertProductMasterInTx は、製品マスターレコードをトランザクション内でUPSERTします。
func UpsertProductMasterInTx(tx *sql.Tx, rec model.ProductMasterInput) error {
	const q = `INSERT INTO product_master (
		product_code, yj_code, gs1_code, product_name, kana_name, maker_name,
		specification, usage_classification, package_form, yj_unit_name, yj_pack_unit_qty,
		jan_pack_inner_qty, jan_unit_code, jan_pack_unit_qty, origin,
		nhi_price, purchase_price,
		flag_poison, flag_deleterious, flag_narcotic, flag_psychotropic, flag_stimulant, flag_stimulant_raw,
		is_order_stopped, supplier_wholesale,
		group_code, shelf_number, category, user_notes
	) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
	ON CONFLICT(product_code) DO UPDATE SET
		yj_code=excluded.yj_code, gs1_code=excluded.gs1_code, product_name=excluded.product_name, kana_name=excluded.kana_name, maker_name=excluded.maker_name,
		specification=excluded.specification, usage_classification=excluded.usage_classification, package_form=excluded.package_form, yj_unit_name=excluded.yj_unit_name, yj_pack_unit_qty=excluded.yj_pack_unit_qty,
		jan_pack_inner_qty=excluded.jan_pack_inner_qty, jan_unit_code=excluded.jan_unit_code, jan_pack_unit_qty=excluded.jan_pack_unit_qty, origin=excluded.origin,
		nhi_price=excluded.nhi_price, purchase_price=excluded.purchase_price,
		flag_poison=excluded.flag_poison, flag_deleterious=excluded.flag_deleterious, flag_narcotic=excluded.flag_narcotic, flag_psychotropic=excluded.flag_psychotropic, flag_stimulant=excluded.flag_stimulant, flag_stimulant_raw=excluded.flag_stimulant_raw,
		is_order_stopped=excluded.is_order_stopped, supplier_wholesale=excluded.supplier_wholesale,
		group_code=excluded.group_code, shelf_number=excluded.shelf_number, category=excluded.category, user_notes=excluded.user_notes
	`

	_, err := tx.Exec(q,
		rec.ProductCode, rec.YjCode, rec.Gs1Code, rec.ProductName, rec.KanaName, rec.MakerName,
		rec.Specification, rec.UsageClassification, rec.PackageForm, rec.YjUnitName, rec.YjPackUnitQty,
		rec.JanPackInnerQty, rec.JanUnitCode, rec.JanPackUnitQty, rec.Origin,
		rec.NhiPrice, rec.PurchasePrice,
		rec.FlagPoison, rec.FlagDeleterious, rec.FlagNarcotic, rec.FlagPsychotropic, rec.FlagStimulant, rec.FlagStimulantRaw,
		rec.IsOrderStopped, rec.SupplierWholesale,
		rec.GroupCode, rec.ShelfNumber, rec.Category, rec.UserNotes,
	)
	if err != nil {
		return fmt.Errorf("UpsertProductMasterInTx failed: %w", err)
	}
	return nil
}

// GetProductMastersByCodesMap は、複数の製品コードをキーに製品マスターをマップ形式で取得します。
func GetProductMastersByCodesMap(dbtx DBTX, codes []string) (map[string]*model.ProductMaster, error) {
	if len(codes) == 0 {
		return make(map[string]*model.ProductMaster), nil
	}
	q := `SELECT ` + SelectColumns + ` FROM product_master WHERE product_code IN (?` + strings.Repeat(",?", len(codes)-1) + `)`

	args := make([]interface{}, len(codes))
	for i, code := range codes {
		args[i] = code
	}

	rows, err := dbtx.Query(q, args...)
	if err != nil {
		return nil, fmt.Errorf("query for masters by codes failed: %w", err)
	}
	defer rows.Close()

	mastersMap := make(map[string]*model.ProductMaster)
	for rows.Next() {
		m, err := ScanProductMaster(rows)
		if err != nil {
			return nil, err
		}
		mastersMap[m.ProductCode] = m
	}
	return mastersMap, nil
}

// GetProductMasterByCode は、単一の製品コードをキーに製品マスターを取得します。
func GetProductMasterByCode(dbtx DBTX, code string) (*model.ProductMaster, error) {
	q := `SELECT ` + SelectColumns + ` FROM product_master WHERE product_code = ?`
	row := dbtx.QueryRow(q, code)
	m, err := ScanProductMaster(row)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, fmt.Errorf("GetProductMasterByCode failed for code %s: %w", code, err)
	}
	return m, nil
}

// ▼▼▼【ここから追加】▼▼▼
// GetProductMasterByGS1Code は、単一のGS1コードをキーに製品マスターを取得します。
func GetProductMasterByGS1Code(dbtx DBTX, gs1Code string) (*model.ProductMaster, error) {
	q := `SELECT ` + SelectColumns + ` FROM product_master WHERE gs1_code = ?`
	row := dbtx.QueryRow(q, gs1Code)
	m, err := ScanProductMaster(row)
	if err == sql.ErrNoRows {
		return nil, nil // 見つからない場合はエラーではなく、nilを返す
	}
	if err != nil {
		return nil, fmt.Errorf("GetProductMasterByGS1Code failed for gs1_code %s: %w", gs1Code, err)
	}
	return m, nil
}

// ▲▲▲【追加ここまで】▲▲▲

// GetAllProductMasters は、product_masterテーブルの全レコードを取得します。
func GetAllProductMasters(dbtx DBTX) ([]*model.ProductMaster, error) {
	q := `SELECT ` + SelectColumns + ` FROM product_master ORDER BY
		CASE
			WHEN TRIM(usage_classification) = '内' OR TRIM(usage_classification) = '1' THEN 1
			WHEN TRIM(usage_classification) = '外' OR TRIM(usage_classification) = '2' THEN 2
			WHEN TRIM(usage_classification) = '注' OR TRIM(usage_classification) = '3' THEN 3
			WHEN TRIM(usage_classification) = '歯' OR TRIM(usage_classification) = '4' THEN 4
			WHEN TRIM(usage_classification) = '機' OR TRIM(usage_classification) = '5' THEN 5
			WHEN TRIM(usage_classification) = '他' OR TRIM(usage_classification) = '6' THEN 6
			ELSE 7
		END,
		kana_name`

	rows, err := dbtx.Query(q)
	if err != nil {
		return nil, fmt.Errorf("GetAllProductMasters query failed: %w", err)
	}
	defer rows.Close()

	var masters []*model.ProductMaster
	for rows.Next() {
		m, err := ScanProductMaster(rows)
		if err != nil {
			return nil, err
		}
		masters = append(masters, m)
	}
	return masters, nil
}

// GetProductMastersByYjCode は、YJコードをキーに製品マスターを取得します。
func GetProductMastersByYjCode(dbtx DBTX, yjCode string) ([]*model.ProductMaster, error) {
	q := `SELECT ` + SelectColumns + ` FROM product_master WHERE yj_code = ? ORDER BY product_code`
	rows, err := dbtx.Query(q, yjCode)
	if err != nil {
		return nil, fmt.Errorf("query for masters by yj code failed: %w", err)
	}
	defer rows.Close()

	var masters []*model.ProductMaster
	for rows.Next() {
		m, err := ScanProductMaster(rows)
		if err != nil {
			return nil, err
		}
		masters = append(masters, m)
	}
	return masters, nil
}

// UpdatePricesAndSuppliersInTx は、納入価と採用卸を一括更新します。
func UpdatePricesAndSuppliersInTx(tx *sql.Tx, updates []model.PriceUpdate) error {
	const q = `UPDATE product_master SET purchase_price = ?, supplier_wholesale = ? WHERE product_code = ?`
	stmt, err := tx.Prepare(q)
	if err != nil {
		return fmt.Errorf("UpdatePricesAndSuppliersInTx failed to prepare statement: %w", err)
	}
	defer stmt.Close()

	for _, u := range updates {
		_, err := stmt.Exec(u.NewPurchasePrice, u.NewSupplier, u.ProductCode)
		if err != nil {
			// 1件のエラーで全体を止めずに、エラーを返しつつも処理を継続する（ロールバックは呼び出し元に任せる）
			return fmt.Errorf("UpdatePricesAndSuppliersInTx failed for product %s: %w", u.ProductCode, err)
		}
	}
	return nil
}

// ClearAllProductMasters は、product_masterテーブルの全レコードを削除します。
func ClearAllProductMasters(tx *sql.Tx) error {
	const q = `DELETE FROM product_master`
	_, err := tx.Exec(q)
	if err != nil {
		return fmt.Errorf("ClearAllProductMasters failed: %w", err)
	}
	return nil
}


----- C:\Users\wasab\OneDrive\デスクトップ\WASABI\db\search.go -----
// C:\Users\wasab\OneDrive\デスクトップ\WASABI\db\search.go

package db

import (
	"database/sql"
	"fmt"
	"log"
	"strconv"
	"strings" // stringsパッケージをインポート
	"wasabi/model"
	"wasabi/units"
)

/**
 * @brief 製品名またはカナ名でJCSHMSマスタを検索し、表示用のモデルを返します。
 * @param conn データベース接続
 * @param nameQuery 検索キーワード
 * @return []model.ProductMasterView 検索結果のスライス
 * @return error 処理中にエラーが発生した場合
 * @details
 * この関数は `product_master` テーブルではなく、`jcshms` と `jancode` テーブルを直接検索します。
 * アプリ内にまだ存在しない公式の医薬品マスターを探すために使用されます。
 */
func SearchJcshmsByName(conn *sql.DB, nameQuery string) ([]model.ProductMasterView, error) {
	// ▼▼▼【ここから修正】▼▼▼
	const q = `
		SELECT
			j.JC000, j.JC009, j.JC018, j.JC022, j.JC030, j.JC013, j.JC037, j.JC039,
			j.JC044, j.JC050,
			ja.JA006, ja.JA008, ja.JA007
		FROM jcshms AS j
		LEFT JOIN jancode AS ja ON j.JC000 = ja.JA001
		WHERE j.JC018 LIKE ? OR j.JC022 LIKE ?
		ORDER BY
			CASE
				WHEN TRIM(j.JC013) = '内' OR TRIM(j.JC013) = '1' THEN 1
				WHEN TRIM(j.JC013) = '外' OR TRIM(j.JC013) = '2' THEN 2
				WHEN TRIM(j.JC013) = '注' OR TRIM(j.JC013) = '3' THEN 3
				WHEN TRIM(j.JC013) = '歯' OR TRIM(j.JC013) = '4' THEN 4
				WHEN TRIM(j.JC013) = '機' OR TRIM(j.JC013) = '5' THEN 5
				WHEN TRIM(j.JC013) = '他' OR TRIM(j.JC013) = '6' THEN 6
				ELSE 7
			END,
			j.JC022
		LIMIT 500`

	rows, err := conn.Query(q, "%"+nameQuery+"%", "%"+nameQuery+"%")
	if err != nil {
		return nil, fmt.Errorf("SearchJcshmsByName failed: %w", err)
	}
	defer rows.Close()

	type tempResult struct {
		jcshms   model.JCShms
		jc000    string
		jc009    string
		jc018    string
		jc022    string
		jc030    string
		nhiPrice float64
	}

	var tempResults []tempResult
	var janCodes []interface{}

	for rows.Next() {
		var tempJcshms model.JCShms
		var jc000, jc009, jc018, jc022, jc030, jc013, jc037, jc039, jc050 sql.NullString
		var jc044 sql.NullFloat64

		if err := rows.Scan(
			&jc000, &jc009, &jc018, &jc022, &jc030, &jc013, &jc037, &jc039,
			&jc044, &jc050,
			&tempJcshms.JA006, &tempJcshms.JA008, &tempJcshms.JA007,
		); err != nil {
			return nil, err
		}

		tempJcshms.JC013 = jc013.String
		tempJcshms.JC037 = jc037.String
		tempJcshms.JC039 = jc039.String
		tempJcshms.JC044 = jc044.Float64

		nhiPriceVal, err := strconv.ParseFloat(jc050.String, 64)
		if err != nil {
			nhiPriceVal = 0
			if jc050.String != "" {
				log.Printf("[WARN] Invalid JC050 data during search: '%s'", jc050.String)
			}
		}

		tempResults = append(tempResults, tempResult{
			jcshms:   tempJcshms,
			jc000:    jc000.String,
			jc009:    jc009.String,
			jc018:    jc018.String,
			jc022:    jc022.String,
			jc030:    jc030.String,
			nhiPrice: nhiPriceVal,
		})
		janCodes = append(janCodes, jc000.String)
	}

	adoptedMap := make(map[string]bool)
	if len(janCodes) > 0 {
		query := "SELECT product_code FROM product_master WHERE product_code IN (?" + strings.Repeat(",?", len(janCodes)-1) + ")"
		adoptedRows, err := conn.Query(query, janCodes...)
		if err != nil {
			return nil, fmt.Errorf("failed to check adopted products: %w", err)
		}
		defer adoptedRows.Close()
		for adoptedRows.Next() {
			var productCode string
			if err := adoptedRows.Scan(&productCode); err != nil {
				return nil, err
			}
			adoptedMap[productCode] = true
		}
	}

	var results []model.ProductMasterView
	for _, temp := range tempResults {
		tempJcshms := temp.jcshms
		tempJcshms.JC050 = temp.nhiPrice

		var unitNhiPrice float64
		if tempJcshms.JC044 > 0 {
			unitNhiPrice = tempJcshms.JC050 / tempJcshms.JC044
		}

		janUnitCodeInt, _ := strconv.Atoi(tempJcshms.JA007.String)

		view := model.ProductMasterView{
			ProductMaster: model.ProductMaster{
				ProductCode:         temp.jc000,
				YjCode:              temp.jc009,
				ProductName:         temp.jc018,
				KanaName:            temp.jc022,
				MakerName:           temp.jc030,
				UsageClassification: tempJcshms.JC013,
				PackageForm:         tempJcshms.JC037,
				YjUnitName:          units.ResolveName(tempJcshms.JC039),
				YjPackUnitQty:       tempJcshms.JC044,
				JanPackInnerQty:     tempJcshms.JA006.Float64,
				JanPackUnitQty:      tempJcshms.JA008.Float64,
				JanUnitCode:         janUnitCodeInt,
				NhiPrice:            unitNhiPrice,
			},
			FormattedPackageSpec: units.FormatPackageSpec(&tempJcshms),
			IsAdopted:            adoptedMap[temp.jc000],
		}

		if view.ProductMaster.JanUnitCode == 0 {
			view.JanUnitName = view.ProductMaster.YjUnitName
		} else {
			view.JanUnitName = units.ResolveName(tempJcshms.JA007.String)
		}
		results = append(results, view)
	}
	return results, nil
	// ▲▲▲【修正ここまで】▲▲▲
}

/**
 * @brief 製品名またはカナ名で `product_master` テーブル全体を検索します。
 * @param conn データベース接続
 * @param nameQuery 検索キーワード
 * @return []model.ProductMasterView 検索結果のスライス
 * @return error 処理中にエラーが発生した場合
 * @details
 * JCSHMS由来のマスターと、手動で登録されたPROVISIONALマスターの両方が検索対象になります。
 */
func SearchAllProductMastersByName(conn *sql.DB, nameQuery string) ([]model.ProductMasterView, error) {
	q := `SELECT ` + SelectColumns + ` FROM product_master 
		  WHERE kana_name LIKE ? OR product_name LIKE ? 
		  ORDER BY
			CASE
				WHEN TRIM(usage_classification) = '内' OR TRIM(usage_classification) = '1' THEN 1
				WHEN TRIM(usage_classification) = '外' OR TRIM(usage_classification) = '2' THEN 2
				WHEN TRIM(usage_classification) = '注' OR TRIM(usage_classification) = '3' THEN 3
				WHEN TRIM(usage_classification) = '歯' OR TRIM(usage_classification) = '4' THEN 4
				WHEN TRIM(usage_classification) = '機' OR TRIM(usage_classification) = '5' THEN 5
				WHEN TRIM(usage_classification) = '他' OR TRIM(usage_classification) = '6' THEN 6
				ELSE 7
			END,
			kana_name
		  LIMIT 500`

	rows, err := conn.Query(q, "%"+nameQuery+"%", "%"+nameQuery+"%")
	if err != nil {
		return nil, fmt.Errorf("SearchAllProductMastersByName failed: %w", err)
	}
	defer rows.Close()

	var mastersView []model.ProductMasterView
	for rows.Next() {
		m, err := ScanProductMaster(rows)
		if err != nil {
			return nil, err
		}

		tempJcshms := model.JCShms{
			JC037: m.PackageForm,
			JC039: m.YjUnitName,
			JC044: m.YjPackUnitQty,
			JA006: sql.NullFloat64{Float64: m.JanPackInnerQty, Valid: true},
			JA008: sql.NullFloat64{Float64: m.JanPackUnitQty, Valid: true},
			JA007: sql.NullString{String: fmt.Sprintf("%d", m.JanUnitCode), Valid: true},
		}
		formattedSpec := units.FormatPackageSpec(&tempJcshms)

		mastersView = append(mastersView, model.ProductMasterView{
			ProductMaster:        *m,
			FormattedPackageSpec: formattedSpec,
		})
	}
	return mastersView, nil
}


----- C:\Users\wasab\OneDrive\デスクトップ\WASABI\db\sequence.go -----
package db

import (
	"database/sql"
	"fmt"
	"strconv"
	"strings"
)

/**
 * @brief 指定されたシーケンスの次の値を発行します。
 * @param tx SQLトランザクションオブジェクト
 * @param name シーケンス名 (例: "MA2Y", "CL")
 * @param prefix 新しいコードに付与する接頭辞 (例: "MA2Y", "CL")
 * @param padding ゼロ埋めする桁数
 * @return string 生成された新しいコード (例: "CL0001")
 * @return error 処理中にエラーが発生した場合
 */
func NextSequenceInTx(tx *sql.Tx, name, prefix string, padding int) (string, error) {
	var lastNo int
	err := tx.QueryRow("SELECT last_no FROM code_sequences WHERE name = ?", name).Scan(&lastNo)
	if err != nil {
		if err == sql.ErrNoRows {
			// シーケンスが存在しない場合は、ここで作成するロジックを追加することも可能
			return "", fmt.Errorf("sequence '%s' not found", name)
		}
		return "", fmt.Errorf("failed to get sequence '%s': %w", name, err)
	}

	newNo := lastNo + 1
	_, err = tx.Exec("UPDATE code_sequences SET last_no = ? WHERE name = ?", newNo, name)
	if err != nil {
		return "", fmt.Errorf("failed to update sequence '%s': %w", name, err)
	}

	format := fmt.Sprintf("%s%%0%dd", prefix, padding)
	return fmt.Sprintf(format, newNo), nil
}

func InitializeSequenceFromMaxClientCode(tx *sql.Tx) error {
	var maxCode string
	err := tx.QueryRow("SELECT client_code FROM client_master ORDER BY client_code DESC LIMIT 1").Scan(&maxCode)
	if err != nil {
		if err == sql.ErrNoRows {
			// レコードがない場合は0で初期化
			_, err = tx.Exec("UPDATE code_sequences SET last_no = 0 WHERE name = 'CL'")
			return err
		}
		return err
	}
	if strings.HasPrefix(maxCode, "CL") {
		numPart := strings.TrimPrefix(maxCode, "CL")
		maxNum, _ := strconv.Atoi(numPart)
		_, err = tx.Exec("UPDATE code_sequences SET last_no = ? WHERE name = 'CL'", maxNum)
		return err
	}
	return nil
}

func InitializeSequenceFromMaxYjCode(tx *sql.Tx) error {
	var maxYj string
	err := tx.QueryRow("SELECT yj_code FROM product_master WHERE yj_code LIKE 'MA2Y%' ORDER BY yj_code DESC LIMIT 1").Scan(&maxYj)
	if err != nil {
		if err == sql.ErrNoRows {
			_, err = tx.Exec("UPDATE code_sequences SET last_no = 0 WHERE name = 'MA2Y'")
			return err
		}
		return err
	}
	if strings.HasPrefix(maxYj, "MA2Y") {
		numPart := strings.TrimPrefix(maxYj, "MA2Y")
		maxNum, _ := strconv.Atoi(numPart)
		_, err = tx.Exec("UPDATE code_sequences SET last_no = ? WHERE name = 'MA2Y'", maxNum)
		return err
	}
	return nil
}


----- C:\Users\wasab\OneDrive\デスクトップ\WASABI\db\stock.go -----
// C:\Users\wasab\OneDrive\デスクトップ\WASABI\WASABI\db\stock.go

package db

import (
	"database/sql"
	"fmt"
)

/**
 * @brief 指定された単一製品の現在の理論在庫を、棚卸を考慮して正確に計算します。
 */
func CalculateCurrentStockForProduct(executor DBTX, janCode string) (float64, error) {
	var latestInventoryDate sql.NullString
	err := executor.QueryRow(`
		SELECT MAX(transaction_date) FROM transaction_records
		WHERE jan_code = ? AND flag = 0`, janCode).Scan(&latestInventoryDate)
	if err != nil && err != sql.ErrNoRows {
		return 0, fmt.Errorf("failed to get latest inventory date for %s: %w", janCode, err)
	}

	var baseStock float64
	var netChangeQuery string
	var args []interface{}

	if latestInventoryDate.Valid && latestInventoryDate.String != "" {
		err := executor.QueryRow(`
			SELECT SUM(yj_quantity) FROM transaction_records
			WHERE jan_code = ? AND flag = 0 AND transaction_date = ?`,
			janCode, latestInventoryDate.String).Scan(&baseStock)
		if err != nil {
			return 0, fmt.Errorf("failed to sum inventory for %s on %s: %w", janCode, latestInventoryDate.String, err)
		}

		netChangeQuery = `
			SELECT
				SUM(CASE
					WHEN flag IN (1, 4, 11) THEN yj_quantity
					WHEN flag IN (2, 3, 5, 12) THEN -yj_quantity
					ELSE 0
				END)
			FROM transaction_records
			WHERE jan_code = ? AND transaction_date > ?`
		args = []interface{}{janCode, latestInventoryDate.String}

	} else {
		baseStock = 0
		netChangeQuery = `
			SELECT
				SUM(CASE
					WHEN flag IN (1, 4, 11) THEN yj_quantity
					WHEN flag IN (2, 3, 5, 12) THEN -yj_quantity
					ELSE 0
				END)
			FROM transaction_records
			WHERE jan_code = ?`
		args = []interface{}{janCode}
	}

	var nullNetChange sql.NullFloat64
	err = executor.QueryRow(netChangeQuery, args...).Scan(&nullNetChange)
	if err != nil && err != sql.ErrNoRows {
		return 0, fmt.Errorf("failed to calculate net change for %s: %w", janCode, err)
	}
	netChange := nullNetChange.Float64

	return baseStock + netChange, nil
}

/**
 * @brief 全製品の現在庫を効率的に計算し、マップで返します。
 */
func GetAllCurrentStockMap(conn *sql.DB) (map[string]float64, error) {
	rows, err := conn.Query(`
		SELECT jan_code, transaction_date, flag, yj_quantity 
		FROM transaction_records 
		ORDER BY jan_code, transaction_date, id`)
	if err != nil {
		return nil, fmt.Errorf("failed to get all transactions for stock calculation: %w", err)
	}
	defer rows.Close()

	stockMap := make(map[string]float64)

	type txRecord struct {
		Date string
		Flag int
		Qty  float64
	}
	recordsByJan := make(map[string][]txRecord)

	for rows.Next() {
		var janCode, date string
		var flag int
		var qty float64
		if err := rows.Scan(&janCode, &date, &flag, &qty); err != nil {
			return nil, err
		}
		if janCode == "" {
			continue
		}
		recordsByJan[janCode] = append(recordsByJan[janCode], txRecord{Date: date, Flag: flag, Qty: qty})
	}

	for janCode, records := range recordsByJan {
		var latestInvDate string
		baseStock := 0.0

		invStocksOnDate := make(map[string]float64)
		for _, r := range records {
			if r.Flag == 0 {
				if r.Date > latestInvDate {
					latestInvDate = r.Date
				}
				invStocksOnDate[r.Date] += r.Qty
			}
		}
		if latestInvDate != "" {
			baseStock = invStocksOnDate[latestInvDate]
		}

		netChange := 0.0
		for _, r := range records {
			startDate := "00000000"
			if latestInvDate != "" {
				startDate = latestInvDate
			}

			if r.Date > startDate {
				switch r.Flag {
				case 1, 4, 11:
					netChange += r.Qty
				case 2, 3, 5, 12:
					netChange -= r.Qty
				}
			}
		}
		stockMap[janCode] = baseStock + netChange
	}

	return stockMap, nil
}

/**
 * @brief 指定された製品の、特定の日付時点での理論在庫を計算します。
 */
func CalculateStockOnDate(dbtx DBTX, productCode string, targetDate string) (float64, error) {
	var latestInventoryDate sql.NullString
	// 1. 基準日以前の最新の棚卸日を取得
	err := dbtx.QueryRow(`
		SELECT MAX(transaction_date) FROM transaction_records
		WHERE jan_code = ? AND flag = 0 AND transaction_date <= ?`,
		productCode, targetDate).Scan(&latestInventoryDate)
	if err != nil && err != sql.ErrNoRows {
		return 0, fmt.Errorf("failed to get latest inventory date for %s on or before %s: %w", productCode, targetDate, err)
	}

	if latestInventoryDate.Valid && latestInventoryDate.String != "" {
		// --- 棚卸履歴がある場合の計算 ---
		var baseStock float64
		// 1a. 棚卸日の在庫合計を基点とする
		err := dbtx.QueryRow(`
			SELECT SUM(yj_quantity) FROM transaction_records
			WHERE jan_code = ? AND flag = 0 AND transaction_date = ?`,
			productCode, latestInventoryDate.String).Scan(&baseStock)
		if err != nil {
			return 0, fmt.Errorf("failed to sum inventory for %s on %s: %w", productCode, latestInventoryDate.String, err)
		}

		// 1b. もし基準日が棚卸日当日なら、棚卸数量のみを返す
		if latestInventoryDate.String == targetDate {
			return baseStock, nil
		}

		// 1c. 棚卸日の翌日から基準日までの変動を計算
		var netChangeAfterInvDate sql.NullFloat64
		err = dbtx.QueryRow(`
			SELECT SUM(CASE WHEN flag IN (1, 4, 11) THEN yj_quantity WHEN flag IN (2, 3, 5, 12) THEN -yj_quantity ELSE 0 END)
			FROM transaction_records
			WHERE jan_code = ? AND flag != 0 AND transaction_date > ? AND transaction_date <= ?`,
			productCode, latestInventoryDate.String, targetDate).Scan(&netChangeAfterInvDate)
		if err != nil && err != sql.ErrNoRows {
			return 0, fmt.Errorf("failed to calculate net change after inventory date for %s: %w", productCode, err)
		}

		return baseStock + netChangeAfterInvDate.Float64, nil

	} else {
		// --- 棚卸履歴がない場合の計算 ---
		var totalNetChange sql.NullFloat64
		err = dbtx.QueryRow(`
			SELECT SUM(CASE WHEN flag IN (1, 4, 11) THEN yj_quantity WHEN flag IN (2, 3, 5, 12) THEN -yj_quantity ELSE 0 END)
			FROM transaction_records
			WHERE jan_code = ? AND flag != 0 AND transaction_date <= ?`,
			productCode, targetDate).Scan(&totalNetChange)
		if err != nil && err != sql.ErrNoRows {
			return 0, fmt.Errorf("failed to calculate total net change for %s: %w", productCode, err)
		}
		return totalNetChange.Float64, nil
	}
}


----- C:\Users\wasab\OneDrive\デスクトップ\WASABI\db\transaction_records.go -----
// C:\Users\wasab\OneDrive\デスクトップ\WASABI\db\transaction_records.go
package db

import (
	"database/sql"
	"fmt"
	"log"
	"strings"
	"wasabi/mappers"
	"wasabi/model"
)

// ▼▼▼【ここを修正】▼▼▼
const TransactionColumns = `
    id, transaction_date, client_code, receipt_number, line_number, flag,
    jan_code, yj_code, product_name, kana_name, usage_classification, package_form, package_spec, maker_name,
    dat_quantity, jan_pack_inner_qty, jan_quantity, jan_pack_unit_qty, jan_unit_name, jan_unit_code,
    yj_quantity, yj_pack_unit_qty, yj_unit_name, unit_price, purchase_price, supplier_wholesale,
    subtotal, tax_amount, tax_rate, expiry_date, lot_number, flag_poison,
    flag_deleterious, flag_narcotic, flag_psychotropic, flag_stimulant,
    flag_stimulant_raw, process_flag_ma`

// ▲▲▲【修正ここまで】▲▲▲

func ScanTransactionRecord(row interface{ Scan(...interface{}) error }) (*model.TransactionRecord, error) {
	var r model.TransactionRecord
	err := row.Scan(
		&r.ID, &r.TransactionDate, &r.ClientCode, &r.ReceiptNumber, &r.LineNumber, &r.Flag,
		&r.JanCode, &r.YjCode, &r.ProductName, &r.KanaName, &r.UsageClassification, &r.PackageForm, &r.PackageSpec, &r.MakerName,
		&r.DatQuantity, &r.JanPackInnerQty, &r.JanQuantity, &r.JanPackUnitQty, &r.JanUnitName, &r.JanUnitCode,
		&r.YjQuantity, &r.YjPackUnitQty, &r.YjUnitName, &r.UnitPrice, &r.PurchasePrice, &r.SupplierWholesale,
		&r.Subtotal, &r.TaxAmount, &r.TaxRate, &r.ExpiryDate, &r.LotNumber, &r.FlagPoison,
		&r.FlagDeleterious, &r.FlagNarcotic, &r.FlagPsychotropic, &r.FlagStimulant,
		&r.FlagStimulantRaw, &r.ProcessFlagMA,
	)
	if err != nil {
		return nil, err
	}
	return &r, nil
}

func PersistTransactionRecordsInTx(tx *sql.Tx, records []model.TransactionRecord) error {
	const q = `
INSERT OR REPLACE INTO transaction_records (
    transaction_date, client_code, receipt_number, line_number, flag,
    jan_code, yj_code, product_name, kana_name, usage_classification, package_form, package_spec, maker_name,
    dat_quantity, jan_pack_inner_qty, jan_quantity, jan_pack_unit_qty, jan_unit_name, jan_unit_code,
    yj_quantity, yj_pack_unit_qty, yj_unit_name, unit_price, purchase_price, supplier_wholesale,
    subtotal, tax_amount, tax_rate, expiry_date, lot_number, flag_poison,
    flag_deleterious, flag_narcotic, flag_psychotropic, flag_stimulant,
    flag_stimulant_raw, process_flag_ma
) VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)`

	stmt, err := tx.Prepare(q)
	if err != nil {
		return fmt.Errorf("failed to prepare statement for transaction_records: %w", err)
	}
	defer stmt.Close()

	for _, rec := range records {
		_, err = stmt.Exec(
			rec.TransactionDate, rec.ClientCode, rec.ReceiptNumber, rec.LineNumber, rec.Flag,
			rec.JanCode, rec.YjCode, rec.ProductName, rec.KanaName, rec.UsageClassification, rec.PackageForm, rec.PackageSpec, rec.MakerName,
			rec.DatQuantity, rec.JanPackInnerQty, rec.JanQuantity,
			rec.JanPackUnitQty,
			rec.JanUnitName, rec.JanUnitCode,
			rec.YjQuantity, rec.YjPackUnitQty, rec.YjUnitName, rec.UnitPrice, rec.PurchasePrice, rec.SupplierWholesale,
			rec.Subtotal, rec.TaxAmount, rec.TaxRate, rec.ExpiryDate, rec.LotNumber, rec.FlagPoison,
			rec.FlagDeleterious, rec.FlagNarcotic, rec.FlagPsychotropic, rec.FlagStimulant,
			rec.FlagStimulantRaw, rec.ProcessFlagMA,
		)
		if err != nil {
			log.Printf("FAILED to insert into transaction_records: JAN=%s, Error: %v", rec.JanCode, err)
			return fmt.Errorf("failed to exec statement for transaction_records (JAN: %s): %w", rec.JanCode, err)
		}
	}
	return nil
}

func PersistTransactionRecordsWithMasterMappingInTx(tx *sql.Tx, records []model.TransactionRecord) error {
	var productCodes []string
	codeMap := make(map[string]struct{})
	for _, rec := range records {
		if _, exists := codeMap[rec.JanCode]; !exists {
			productCodes = append(productCodes, rec.JanCode)
			codeMap[rec.JanCode] = struct{}{}
		}
	}

	masters, err := GetProductMastersByCodesMap(tx, productCodes)
	if err != nil {
		return fmt.Errorf("failed to pre-fetch masters for persisting records: %w", err)
	}

	const q = `
INSERT OR REPLACE INTO transaction_records (
    transaction_date, client_code, receipt_number, line_number, flag,
    jan_code, yj_code, product_name, kana_name, usage_classification, package_form, package_spec, maker_name,
    dat_quantity, jan_pack_inner_qty, jan_quantity, jan_pack_unit_qty, jan_unit_name, jan_unit_code,
    yj_quantity, yj_pack_unit_qty, yj_unit_name, unit_price, purchase_price, supplier_wholesale,
    subtotal, tax_amount, tax_rate, expiry_date, lot_number, flag_poison,
    flag_deleterious, flag_narcotic, flag_psychotropic, flag_stimulant,
    flag_stimulant_raw, process_flag_ma
) VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)`

	stmt, err := tx.Prepare(q)
	if err != nil {
		return fmt.Errorf("failed to prepare statement for transaction_records: %w", err)
	}
	defer stmt.Close()

	for _, rec := range records {
		if master, ok := masters[rec.JanCode]; ok {
			mappers.MapProductMasterToTransaction(&rec, master)
		}

		_, err = stmt.Exec(
			rec.TransactionDate, rec.ClientCode, rec.ReceiptNumber, rec.LineNumber, rec.Flag,
			rec.JanCode, rec.YjCode, rec.ProductName, rec.KanaName, rec.UsageClassification, rec.PackageForm, rec.PackageSpec, rec.MakerName,
			rec.DatQuantity, rec.JanPackInnerQty, rec.JanQuantity,
			rec.JanPackUnitQty,
			rec.JanUnitName, rec.JanCode,
			rec.YjQuantity, rec.YjPackUnitQty, rec.YjUnitName, rec.UnitPrice, rec.PurchasePrice, rec.SupplierWholesale,
			rec.Subtotal, rec.TaxAmount, rec.TaxRate, rec.ExpiryDate, rec.LotNumber, rec.FlagPoison,
			rec.FlagDeleterious, rec.FlagNarcotic, rec.FlagPsychotropic, rec.FlagStimulant,
			rec.FlagStimulantRaw, rec.ProcessFlagMA,
		)
		if err != nil {
			log.Printf("FAILED to insert into transaction_records: JAN=%s, Error: %v", rec.JanCode, err)
			return fmt.Errorf("failed to exec statement for transaction_records (JAN: %s): %w", rec.JanCode, err)
		}
	}
	return nil
}

func GetReceiptNumbersByDate(conn *sql.DB, date string) ([]string, error) {
	const q = `SELECT DISTINCT receipt_number FROM transaction_records 
               WHERE transaction_date = ? AND receipt_number LIKE 'io%' 
               ORDER BY receipt_number`
	rows, err := conn.Query(q, date)
	if err != nil {
		return nil, fmt.Errorf("failed to get receipt numbers by date: %w", err)
	}
	defer rows.Close()

	var numbers []string
	for rows.Next() {
		var number string
		if err = rows.Scan(&number); err != nil {
			return nil, err
		}
		numbers = append(numbers, number)
	}
	return numbers, nil
}

func GetTransactionsByReceiptNumber(conn *sql.DB, receiptNumber string) ([]model.TransactionRecord, error) {
	q := `SELECT ` + TransactionColumns + ` FROM transaction_records WHERE receipt_number = ? ORDER BY line_number`
	rows, err := conn.Query(q, receiptNumber)
	if err != nil {
		return nil, fmt.Errorf("failed to get transactions by receipt number: %w", err)
	}
	defer rows.Close()

	var records []model.TransactionRecord
	for rows.Next() {
		r, err := ScanTransactionRecord(rows)
		if err != nil {
			return nil, err
		}
		records = append(records, *r)
	}
	return records, nil
}

func DeleteTransactionsByReceiptNumberInTx(tx *sql.Tx, receiptNumber string) error {
	const q = `DELETE FROM transaction_records WHERE receipt_number = ?`
	_, err := tx.Exec(q, receiptNumber)
	if err != nil {
		return fmt.Errorf("failed to delete transactions for receipt %s: %w", receiptNumber, err)
	}
	return nil
}

func DeleteTransactionsByFlagAndDateAndCodes(tx *sql.Tx, flag int, date string, productCodes []string) error {
	if len(productCodes) == 0 {
		return nil
	}

	placeholders := strings.Repeat("?,", len(productCodes)-1) + "?"
	q := fmt.Sprintf(`DELETE FROM transaction_records WHERE flag = ? AND transaction_date = ? AND jan_code IN (%s)`, placeholders)

	args := make([]interface{}, 0, len(productCodes)+2)
	args = append(args, flag, date)
	for _, code := range productCodes {
		args = append(args, code)
	}

	_, err := tx.Exec(q, args...)
	if err != nil {
		return fmt.Errorf("failed to delete transactions by flag, date, and codes: %w", err)
	}
	return nil
}

func GetInventoryTransactionsByDate(conn *sql.DB, date string) ([]model.TransactionRecord, error) {
	q := `SELECT ` + TransactionColumns + ` FROM transaction_records WHERE flag = 0 AND transaction_date = ? ORDER BY product_name`
	rows, err := conn.Query(q, date)
	if err != nil {
		return nil, fmt.Errorf("failed to get inventory transactions by date: %w", err)
	}
	defer rows.Close()

	var records []model.TransactionRecord
	for rows.Next() {
		r, err := ScanTransactionRecord(rows)
		if err != nil {
			return nil, err
		}
		records = append(records, *r)
	}
	return records, nil
}

func DeleteTransactionByIDInTx(tx *sql.Tx, id int) error {
	const q = `DELETE FROM transaction_records WHERE id = ?`
	res, err := tx.Exec(q, id)
	if err != nil {
		return fmt.Errorf("failed to delete transaction with id %d: %w", id, err)
	}
	rowsAffected, err := res.RowsAffected()
	if err != nil {
		return fmt.Errorf("failed to check rows affected for id %d: %w", id, err)
	}
	if rowsAffected == 0 {
		return fmt.Errorf("no transaction found to delete with id %d", id)
	}
	return nil
}

func GetAllTransactionsForProductAfterDate(conn *sql.DB, janCode string, date string) ([]model.TransactionRecord, error) {
	q := `SELECT ` + TransactionColumns + ` FROM transaction_records 
          WHERE jan_code = ? AND transaction_date > ? AND flag != 0
          ORDER BY transaction_date, id`

	rows, err := conn.Query(q, janCode, date)
	if err != nil {
		return nil, fmt.Errorf("failed to get transactions after date for %s: %w", janCode, err)
	}
	defer rows.Close()

	var records []model.TransactionRecord
	for rows.Next() {
		r, err := ScanTransactionRecord(rows)
		if err != nil {
			return nil, err
		}
		records = append(records, *r)
	}
	return records, nil
}

func GetTransactionsForProductInDateRange(conn *sql.DB, janCode string, startDate string, endDate string) ([]model.TransactionRecord, error) {
	q := `SELECT ` + TransactionColumns + ` FROM transaction_records 
          WHERE jan_code = ? AND transaction_date BETWEEN ? AND ?
          ORDER BY transaction_date DESC, id DESC`

	rows, err := conn.Query(q, janCode, startDate, endDate)
	if err != nil {
		return nil, fmt.Errorf("failed to get transactions in date range for %s: %w", janCode, err)
	}
	defer rows.Close()

	var records []model.TransactionRecord
	for rows.Next() {
		r, err := ScanTransactionRecord(rows)
		if err != nil {
			return nil, err
		}
		records = append(records, *r)
	}
	return records, nil
}

func DeleteTransactionsByFlagAndDate(tx *sql.Tx, flag int, date string) error {
	const q = `DELETE FROM transaction_records WHERE flag = ? AND transaction_date = ?`
	_, err := tx.Exec(q, flag, date)
	if err != nil {
		return fmt.Errorf("failed to delete transactions for flag %d, date %s: %w", flag, date, err)
	}
	return nil
}

func DeleteZeroFillInventoryTransactions(tx *sql.Tx, date string, janCodes []string) error {
	if len(janCodes) == 0 {
		return nil
	}

	placeholders := strings.Repeat("?,", len(janCodes)-1) + "?"
	q := fmt.Sprintf(`
        DELETE FROM transaction_records 
        WHERE flag = 0 
          AND transaction_date = ? 
          AND line_number LIKE 'Z%%' 
          AND jan_code IN (%s)`, placeholders)

	args := make([]interface{}, 0, len(janCodes)+1)
	args = append(args, date)
	for _, jan := range janCodes {
		args = append(args, jan)
	}

	_, err := tx.Exec(q, args...)
	if err != nil {
		return fmt.Errorf("failed to delete zero-fill inventory transactions for date %s: %w", date, err)
	}
	return nil
}

func GetLastInventoryDateMap(conn *sql.DB) (map[string]string, error) {
	rows, err := conn.Query(`
         SELECT jan_code, MAX(transaction_date) 
        FROM transaction_records 
        WHERE flag = 0 AND jan_code != ''
        GROUP BY jan_code
    `)
	if err != nil {
		return nil, fmt.Errorf("failed to get last inventory dates: %w", err)
	}
	defer rows.Close()

	dateMap := make(map[string]string)
	for rows.Next() {
		var janCode string
		var lastDate sql.NullString
		if err := rows.Scan(&janCode, &lastDate); err != nil {
			return nil, err
		}
		if lastDate.Valid {
			dateMap[janCode] = lastDate.String
		}
	}
	return dateMap, nil
}

func UpdateFullTransactionInTx(tx *sql.Tx, record *model.TransactionRecord) error {
	const q = `
        UPDATE transaction_records SET
            jan_code = ?, yj_code = ?, product_name = ?, kana_name = ?, usage_classification = ?, package_form = ?, 
            package_spec = ?, maker_name = ?, jan_pack_inner_qty = ?, jan_pack_unit_qty = ?, 
            jan_unit_name = ?, jan_unit_code = ?, yj_pack_unit_qty = ?, yj_unit_name = ?,
            unit_price = ?, purchase_price = ?, supplier_wholesale = ?,
            flag_poison = ?, flag_deleterious = ?, flag_narcotic = ?, flag_psychotropic = ?,
            flag_stimulant = ?, flag_stimulant_raw = ?,
            yj_quantity = ?, subtotal = ?,
            process_flag_ma = ?
        WHERE id = ?`

	_, err := tx.Exec(q,
		record.JanCode, record.YjCode, record.ProductName, record.KanaName, record.UsageClassification, record.PackageForm,
		record.PackageSpec, record.MakerName, record.JanPackInnerQty, record.JanPackUnitQty,
		record.JanUnitName, record.JanUnitCode, record.YjPackUnitQty, record.YjUnitName,
		record.UnitPrice, record.PurchasePrice, record.SupplierWholesale,
		record.FlagPoison, record.FlagDeleterious, record.FlagNarcotic, record.FlagPsychotropic,
		record.FlagStimulant, record.FlagStimulantRaw,
		record.YjQuantity, record.Subtotal,
		record.ProcessFlagMA,
		record.ID,
	)
	if err != nil {
		return fmt.Errorf("failed to update transaction ID %d: %w", record.ID, err)
	}
	return nil
}

func ClearAllTransactions(conn *sql.DB) error {
	tx, err := conn.Begin()
	if err != nil {
		return fmt.Errorf("failed to start transaction for clearing transactions: %w",
			err)
	}
	defer tx.Rollback()

	if _, err := tx.Exec(`DELETE FROM transaction_records`); err != nil {
		return fmt.Errorf("failed to execute delete from transaction_records: %w", err)
	}

	if _, err := tx.Exec(`UPDATE sqlite_sequence SET seq = 0 WHERE name = 'transaction_records'`); err != nil {
		log.Printf("Could not reset sequence for transaction_records (this is normal if table was empty): %v", err)
	}

	return tx.Commit()
}

func DeleteUsageTransactionsInDateRange(tx *sql.Tx, minDate, maxDate string) error {
	const q = `DELETE FROM transaction_records WHERE flag = 3 AND transaction_date BETWEEN ? AND ?`
	_, err := tx.Exec(q, minDate, maxDate)
	if err != nil {
		return fmt.Errorf("failed to delete usage transactions: %w", err)
	}
	return nil
}

func GetLastInventoryDate(tx *sql.Tx, janCode string) string {
	var lastDate sql.NullString
	tx.QueryRow("SELECT MAX(transaction_date) FROM transaction_records WHERE jan_code = ? AND flag = 0", janCode).Scan(&lastDate)
	if lastDate.Valid {
		return lastDate.String
	}
	return ""
}

func GetAllTransactionsByProductCodes(conn *sql.DB, productCodes []string) ([]*model.TransactionRecord, error) {
	if len(productCodes) == 0 {
		return []*model.TransactionRecord{}, nil
	}

	placeholders := strings.Repeat("?,", len(productCodes)-1) + "?"
	query := fmt.Sprintf(`SELECT `+TransactionColumns+` FROM transaction_records WHERE jan_code IN (%s) ORDER BY transaction_date, id`, placeholders)

	args := make([]interface{}, len(productCodes))
	for i, code := range productCodes {
		args[i] = code
	}

	rows, err := conn.Query(query, args...)
	if err != nil {
		return nil, fmt.Errorf("failed to get transactions by product codes: %w", err)
	}
	defer rows.Close()

	var records []*model.TransactionRecord
	for rows.Next() {
		r, err := ScanTransactionRecord(rows)
		if err != nil {
			return nil, err
		}
		records = append(records, r)
	}
	return records, nil
}


----- C:\Users\wasab\OneDrive\デスクトップ\WASABI\db\valuation.go -----
// C:\Users\wasab\OneDrive\デスクトップ\WASABI\db\valuation.go
package db

import (
	"database/sql"
	"fmt"
	"sort"
	"strings"
	"wasabi/model"
	"wasabi/units"
)

// ValuationGroup は剤型ごとの在庫評価額の集計結果を保持します。
type ValuationGroup struct {
	UsageClassification string                     `json:"usageClassification"`
	DetailRows          []model.ValuationDetailRow `json:"detailRows"`
	TotalNhiValue       float64                    `json:"totalNhiValue"`
	TotalPurchaseValue  float64                    `json:"totalPurchaseValue"`
}

func GetInventoryValuation(conn *sql.DB, filters model.ValuationFilters) ([]ValuationGroup, error) {
	masterQuery := `SELECT ` + SelectColumns + ` FROM product_master WHERE 1=1`
	var masterArgs []interface{}
	if filters.KanaName != "" {
		masterQuery += " AND (kana_name LIKE ? OR product_name LIKE ?)"
		masterArgs = append(masterArgs, "%"+filters.KanaName+"%", "%"+filters.KanaName+"%")
	}
	if filters.UsageClassification != "" && filters.UsageClassification != "all" {
		masterQuery += " AND usage_classification = ?"
		masterArgs = append(masterArgs, filters.UsageClassification)
	}

	allMasters, err := getAllProductMastersFiltered(conn, masterQuery, masterArgs...)
	if err != nil {
		return nil, fmt.Errorf("failed to get filtered product masters: %w", err)
	}
	if len(allMasters) == 0 {
		return []ValuationGroup{}, nil
	}

	yjHasJcshmsMaster := make(map[string]bool)
	mastersByJanCode := make(map[string]*model.ProductMaster)
	for _, master := range allMasters {
		if master.Origin == "JCSHMS" {
			yjHasJcshmsMaster[master.YjCode] = true
		}
		mastersByJanCode[master.ProductCode] = master
	}

	mastersByPackageKey := make(map[string][]*model.ProductMaster)
	for _, master := range allMasters {
		key := fmt.Sprintf("%s|%s|%g|%s", master.YjCode, master.PackageForm, master.JanPackInnerQty, master.YjUnitName)
		mastersByPackageKey[key] = append(mastersByPackageKey[key], master)
	}

	var detailRows []model.ValuationDetailRow

	for _, mastersInPackageGroup := range mastersByPackageKey {
		var totalStockForPackage float64
		for _, m := range mastersInPackageGroup {
			stock, err := CalculateStockOnDate(conn, m.ProductCode, filters.Date)
			if err != nil {
				return nil, fmt.Errorf("failed to calculate stock on date for product %s: %w", m.ProductCode, err)
			}
			totalStockForPackage += stock
		}

		if totalStockForPackage == 0 {
			continue
		}

		var repMaster *model.ProductMaster
		if len(mastersInPackageGroup) > 0 {
			repMaster = mastersInPackageGroup[0]
			for _, m := range mastersInPackageGroup {
				if m.Origin == "JCSHMS" {
					repMaster = m
					break
				}
			}
		} else {
			continue
		}

		showAlert := false
		if repMaster.Origin != "JCSHMS" && !yjHasJcshmsMaster[repMaster.YjCode] {
			showAlert = true
		}

		tempJcshms := model.JCShms{
			JC037: repMaster.PackageForm, JC039: repMaster.YjUnitName, JC044: repMaster.YjPackUnitQty,
			JA006: sql.NullFloat64{Float64: repMaster.JanPackInnerQty, Valid: true},
			JA008: sql.NullFloat64{Float64: repMaster.JanPackUnitQty, Valid: true},
			JA007: sql.NullString{String: fmt.Sprintf("%d", repMaster.JanUnitCode), Valid: true},
		}
		spec := units.FormatSimplePackageSpec(&tempJcshms)

		unitNhiPrice := repMaster.NhiPrice
		totalNhiValue := totalStockForPackage * unitNhiPrice
		packageNhiPrice := unitNhiPrice * repMaster.YjPackUnitQty

		var totalPurchaseValue float64
		if repMaster.YjPackUnitQty > 0 {
			unitPurchasePrice := repMaster.PurchasePrice / repMaster.YjPackUnitQty
			totalPurchaseValue = totalStockForPackage * unitPurchasePrice
		}

		detailRows = append(detailRows, model.ValuationDetailRow{
			YjCode:               repMaster.YjCode,
			ProductName:          repMaster.ProductName,
			ProductCode:          repMaster.ProductCode,
			PackageSpec:          spec,
			Stock:                totalStockForPackage,
			YjUnitName:           repMaster.YjUnitName,
			PackageNhiPrice:      packageNhiPrice,
			PackagePurchasePrice: repMaster.PurchasePrice,
			TotalNhiValue:        totalNhiValue,
			TotalPurchaseValue:   totalPurchaseValue,
			ShowAlert:            showAlert,
		})
	}

	resultGroups := make(map[string]*ValuationGroup)
	for _, row := range detailRows {
		master, ok := mastersByJanCode[row.ProductCode]
		if !ok {
			continue
		}
		uc := master.UsageClassification
		group, ok := resultGroups[uc]
		if !ok {
			group = &ValuationGroup{UsageClassification: uc}
			resultGroups[uc] = group
		}
		group.DetailRows = append(group.DetailRows, row)
		group.TotalNhiValue += row.TotalNhiValue
		group.TotalPurchaseValue += row.TotalPurchaseValue
	}

	order := map[string]int{"1": 1, "内": 1, "2": 2, "外": 2, "3": 3, "歯": 3, "4": 4, "注": 4, "5": 5, "機": 5, "6": 6, "他": 6}
	var finalResult []ValuationGroup
	for _, group := range resultGroups {
		sort.Slice(group.DetailRows, func(i, j int) bool {
			// 製品名でソートするためにマスター情報を参照
			masterI, okI := mastersByJanCode[group.DetailRows[i].ProductCode]
			masterJ, okJ := mastersByJanCode[group.DetailRows[j].ProductCode]
			if !okI || !okJ {
				return group.DetailRows[i].ProductCode < group.DetailRows[j].ProductCode
			}
			return masterI.KanaName < masterJ.KanaName
		})
		finalResult = append(finalResult, *group)
	}
	sort.Slice(finalResult, func(i, j int) bool {
		prioI, okI := order[strings.TrimSpace(finalResult[i].UsageClassification)]
		if !okI {
			prioI = 7
		}
		prioJ, okJ := order[strings.TrimSpace(finalResult[j].UsageClassification)]
		if !okJ {
			prioJ = 7
		}
		return prioI < prioJ
	})

	return finalResult, nil
}

// getAllProductMastersFiltered はフィルタ条件に基づいて製品マスターを取得するヘルパー関数です。
func getAllProductMastersFiltered(conn *sql.DB, query string, args ...interface{}) ([]*model.ProductMaster, error) {
	rows, err := conn.Query(query, args...)
	if err != nil {
		return nil, fmt.Errorf("GetAllProductMastersFiltered query failed: %w", err)
	}
	defer rows.Close()

	var masters []*model.ProductMaster
	for rows.Next() {
		m, err := ScanProductMaster(rows)
		if err != nil {
			return nil, err
		}
		masters = append(masters, m)
	}
	return masters, nil
}


----- C:\Users\wasab\OneDrive\デスクトップ\WASABI\db\wholesalers.go -----
// C:\Users\wasab\OneDrive\デスクトップ\WASABI\db\wholesalers.go

package db

import (
	"database/sql"
	"fmt"
	"wasabi/model"
)

/**
 * @brief 全ての卸業者を wholesaler_code 順で取得します。
 * @param conn データベース接続
 * @return []model.Wholesaler 卸業者のスライス
 * @return error 処理中にエラーが発生した場合
 */
func GetAllWholesalers(conn *sql.DB) ([]model.Wholesaler, error) {
	rows, err := conn.Query("SELECT wholesaler_code, wholesaler_name FROM wholesalers ORDER BY wholesaler_code")
	if err != nil {
		return nil, fmt.Errorf("failed to get all wholesalers: %w", err)
	}
	defer rows.Close()

	// 空のスライスで初期化することで、卸業者が0件の場合にJSONでnullではなく空配列[]を返す
	wholesalers := make([]model.Wholesaler, 0)
	for rows.Next() {
		var w model.Wholesaler
		if err := rows.Scan(&w.Code, &w.Name); err != nil {
			return nil, err
		}
		wholesalers = append(wholesalers, w)
	}
	return wholesalers, nil
}

/**
 * @brief 新しい卸業者を作成します。
 * @param conn データベース接続
 * @param code 卸業者コード
 * @param name 卸業者名
 * @return error 処理中にエラーが発生した場合
 */
func CreateWholesaler(conn *sql.DB, code, name string) error {
	const q = `INSERT INTO wholesalers (wholesaler_code, wholesaler_name) VALUES (?, ?)`
	_, err := conn.Exec(q, code, name)
	if err != nil {
		return fmt.Errorf("CreateWholesaler failed: %w", err)
	}
	return nil
}

/**
 * @brief 指定されたコードの卸業者を削除します。
 * @param conn データベース接続
 * @param code 削除する卸業者のコード
 * @return error 処理中にエラーが発生した場合
 */
func DeleteWholesaler(conn *sql.DB, code string) error {
	const q = `DELETE FROM wholesalers WHERE wholesaler_code = ?`
	_, err := conn.Exec(q, code)
	if err != nil {
		return fmt.Errorf("failed to delete wholesaler with code %s: %w", code, err)
	}
	return nil
}


----- C:\Users\wasab\OneDrive\デスクトップ\WASABI\deadstock\handler.go -----
// C:\Users\wasab\OneDrive\デスクトップ\WASABI\deadstock\handler.go
package deadstock

import (
	"database/sql"
	"encoding/csv"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"strconv"
	"strings"
	"time"
	"wasabi/config"
	"wasabi/db"
	"wasabi/model"

	"golang.org/x/text/encoding/japanese"
	"golang.org/x/text/transform"
)

func GetDeadStockHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		q := r.URL.Query()
		coefficient, err := strconv.ParseFloat(q.Get("coefficient"), 64)
		if err != nil {
			coefficient = 1.5
		}

		cfg, err := config.LoadConfig()
		if err != nil {
			http.Error(w, "設定ファイルの読み込みに失敗しました: "+err.Error(), http.StatusInternalServerError)
			return
		}

		now := time.Now()
		endDate := "99999999"
		startDate := now.AddDate(0, 0, -cfg.CalculationPeriodDays)

		// ▼▼▼【ここから修正】▼▼▼
		filters := model.DeadStockFilters{
			StartDate:        startDate.Format("20060102"),
			EndDate:          endDate,
			ExcludeZeroStock: q.Get("excludeZeroStock") == "true",
			Coefficient:      coefficient,
			KanaName:         q.Get("kanaName"),
			DosageForm:       q.Get("dosageForm"),
			ShelfNumber:      q.Get("shelfNumber"), // shelfNumber を追加
		}
		// ▲▲▲【修正ここまで】▲▲▲

		results, err := db.GetDeadStockList(conn, filters)
		if err != nil {
			http.Error(w, "Failed to get dead stock list: "+err.Error(), http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(results)
	}
}

func SaveDeadStockHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var payload []model.DeadStockRecord
		if err := json.NewDecoder(r.Body).Decode(&payload); err != nil {
			http.Error(w, "Invalid request body: "+err.Error(), http.StatusBadRequest)
			return
		}

		tx, err := conn.Begin()
		if err != nil {
			http.Error(w, "Failed to start transaction", http.StatusInternalServerError)
			return
		}
		defer tx.Rollback()

		productCodesMap := make(map[string]struct{})
		for _, rec := range payload {
			if rec.ProductCode != "" {
				productCodesMap[rec.ProductCode] = struct{}{}
			}
		}
		var productCodes []string
		for code := range productCodesMap {
			productCodes = append(productCodes, code)
		}

		if len(productCodes) > 0 {
			if err := db.DeleteDeadStockByProductCodesInTx(tx, productCodes); err != nil {
				http.Error(w, "Failed to delete old dead stock records: "+err.Error(), http.StatusInternalServerError)
				return
			}
		}

		if err := db.SaveDeadStockListInTx(tx, payload); err != nil {
			http.Error(w, "Failed to save dead stock records: "+err.Error(), http.StatusInternalServerError)
			return
		}

		if err := tx.Commit(); err != nil {
			http.Error(w, "Failed to commit transaction", http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]string{"message": "保存しました。"})
	}
}

func ImportDeadStockHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		file, _, err := r.FormFile("file")
		if err != nil {
			http.Error(w, "No file uploaded", http.StatusBadRequest)
			return
		}
		defer file.Close()

		reader := transform.NewReader(file, japanese.ShiftJIS.NewDecoder())
		csvReader := csv.NewReader(reader)
		csvReader.LazyQuotes = true
		rows, err := csvReader.ReadAll()
		if err != nil {
			http.Error(w, "Failed to parse CSV file: "+err.Error(), http.StatusBadRequest)
			return
		}

		var payload []model.DeadStockRecord
		productCodesMap := make(map[string]struct{})

		for i, row := range rows {
			if i == 0 || len(row) < 9 {
				continue
			}

			quantity, _ := strconv.ParseFloat(row[3], 64)
			if quantity <= 0 {
				continue
			}
			janPackInnerQty, _ := strconv.ParseFloat(row[8], 64)
			productCode := strings.Trim(strings.TrimSpace(row[1]), `="`)

			rec := model.DeadStockRecord{
				YjCode:           strings.Trim(strings.TrimSpace(row[0]), `="`),
				ProductCode:      productCode,
				StockQuantityJan: quantity,
				YjUnitName:       strings.TrimSpace(row[4]),
				ExpiryDate:       strings.TrimSpace(row[5]),
				LotNumber:        strings.TrimSpace(row[6]),
				PackageForm:      strings.TrimSpace(row[7]),
				JanPackInnerQty:  janPackInnerQty,
			}
			payload = append(payload, rec)
			if productCode != "" {
				productCodesMap[productCode] = struct{}{}
			}
		}

		if len(payload) == 0 {
			w.Header().Set("Content-Type", "application/json")
			json.NewEncoder(w).Encode(map[string]string{"message": "インポートする有効なデータがありませんでした。"})
			return
		}

		var productCodes []string
		for code := range productCodesMap {
			productCodes = append(productCodes, code)
		}

		tx, err := conn.Begin()
		if err != nil {
			http.Error(w, "Failed to start transaction", http.StatusInternalServerError)
			return
		}
		defer tx.Rollback()

		if len(productCodes) > 0 {
			if err := db.DeleteDeadStockByProductCodesInTx(tx, productCodes); err != nil {
				http.Error(w, "Failed to delete old dead stock records: "+err.Error(), http.StatusInternalServerError)
				return
			}
		}

		if err := db.SaveDeadStockListInTx(tx, payload); err != nil {
			http.Error(w, "Failed to save imported dead stock records: "+err.Error(), http.StatusInternalServerError)
			return
		}

		if err := tx.Commit(); err != nil {
			http.Error(w, "Failed to commit transaction", http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]string{
			"message": fmt.Sprintf("%d件のロット・期限情報をインポートしました。", len(payload)),
		})
	}
}

// ▼▼▼【ここから追加】▼▼▼
// ExportDeadStockHandler は画面のフィルタ条件に基づいて不動在庫リストをCSV形式でエクスポートします。
func ExportDeadStockHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		q := r.URL.Query()
		cfg, err := config.LoadConfig()
		if err != nil {
			http.Error(w, "設定ファイルの読み込みに失敗しました: "+err.Error(), http.StatusInternalServerError)
			return
		}

		now := time.Now()
		startDate := now.AddDate(0, 0, -cfg.CalculationPeriodDays)

		filters := model.DeadStockFilters{
			StartDate:        startDate.Format("20060102"),
			EndDate:          "99999999",
			ExcludeZeroStock: q.Get("excludeZeroStock") == "true",
			KanaName:         q.Get("kanaName"),
			DosageForm:       q.Get("dosageForm"),
			ShelfNumber:      q.Get("shelfNumber"), // shelfNumber を追加
		}

		results, err := db.GetDeadStockList(conn, filters)
		if err != nil {
			http.Error(w, "Failed to get dead stock list for export: "+err.Error(), http.StatusInternalServerError)
			return
		}

		fileName := fmt.Sprintf("不動在庫リスト_%s.csv", now.Format("20060102"))
		w.Header().Set("Content-Type", "text/csv")
		w.Header().Set("Content-Disposition", `attachment; filename="`+fileName+`"`)
		w.Write([]byte{0xEF, 0xBB, 0xBF}) // UTF-8 BOM

		csvWriter := csv.NewWriter(w)
		defer csvWriter.Flush()

		headers := []string{
			"yj_code", "product_code", "product_name", "stock_quantity",
			"yj_unit_name", "expiry_date", "lot_number", "package_form", "jan_pack_inner_qty",
		}
		if err := csvWriter.Write(headers); err != nil {
			http.Error(w, "Failed to write CSV header", http.StatusInternalServerError)
			return
		}

		for _, group := range results {
			for _, pkg := range group.PackageGroups {
				for _, prod := range pkg.Products {
					// 保存済みのロット・期限情報がある場合は、そのレコードごとに出力
					if len(prod.SavedRecords) > 0 {
						for _, rec := range prod.SavedRecords {
							record := []string{
								prod.YjCode,
								fmt.Sprintf("=%q", prod.ProductCode),
								prod.ProductName,
								strconv.FormatFloat(rec.StockQuantityJan, 'f', -1, 64),
								prod.YjUnitName,
								rec.ExpiryDate,
								rec.LotNumber,
								prod.PackageForm,
								strconv.FormatFloat(prod.JanPackInnerQty, 'f', -1, 64),
							}
							if err := csvWriter.Write(record); err != nil {
								log.Printf("Failed to write dead stock row to CSV (Code: %s): %v", prod.ProductCode, err)
							}
						}
					} else {
						// 保存済みのロット・期限情報がない場合は、製品情報と現在の理論在庫を出力
						record := []string{
							prod.YjCode,
							fmt.Sprintf("=%q", prod.ProductCode),
							prod.ProductName,
							strconv.FormatFloat(prod.CurrentStock, 'f', -1, 64),
							prod.YjUnitName,
							"", // expiry_date
							"", // lot_number
							prod.PackageForm,
							strconv.FormatFloat(prod.JanPackInnerQty, 'f', -1, 64),
						}
						if err := csvWriter.Write(record); err != nil {
							log.Printf("Failed to write dead stock row to CSV (Code: %s): %v", prod.ProductCode, err)
						}
					}
				}
			}
		}
	}
}

// ▲▲▲【追加ここまで】▲▲▲


----- C:\Users\wasab\OneDrive\デスクトップ\WASABI\edge\handler.go -----
package edge

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"os"
	"path/filepath"
	"strings"
	"time"

	"wasabi/config"
	"wasabi/dat"

	"context" // contextパッケージをインポート

	"github.com/chromedp/cdproto/browser"
	"github.com/chromedp/chromedp"
)

func writeJsonError(w http.ResponseWriter, message string, code int) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(code)
	json.NewEncoder(w).Encode(map[string]string{"message": message})
}

func DownloadHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// 1) 設定読み込み
		cfg, err := config.LoadConfig()
		if err != nil {
			writeJsonError(w, "設定ファイルの読み込みに失敗しました: "+err.Error(), http.StatusInternalServerError)
			return
		}
		if cfg.EdeUserID == "" || cfg.EdePassword == "" {
			writeJsonError(w, "IDまたはパスワードが設定されていません。", http.StatusBadRequest)
			return
		}
		// ▼▼▼【ここから修正】▼▼▼
		// Edgeパスのチェックを追加
		if cfg.EdgePath == "" {
			writeJsonError(w, "Edgeの実行パスが設定されていません。設定画面でパスを指定してください。", http.StatusBadRequest)
			return
		}
		// ▲▲▲【修正ここまで】▲▲▲
		// 2) 一時プロファイルディレクトリ作成
		tempDir, err := os.MkdirTemp("", "chromedp-edge-")
		if err != nil {
			writeJsonError(w, "一時プロファイルディレクトリの作成に失敗: "+err.Error(), http.StatusInternalServerError)
			return
		}
		defer os.RemoveAll(tempDir)

		// ▼▼▼【ここから修正】▼▼▼
		// 3) Edge実行ファイルのパス (ハードコードを削除し、設定値を使用)
		edgePath := cfg.EdgePath

		// 4) ExecAllocator を作成 (元のコードのまま)
		allocCtx, allocCancel := chromedp.NewExecAllocator(
			r.Context(),
			append(chromedp.DefaultExecAllocatorOptions[:],
				chromedp.ExecPath(edgePath), // ここで設定値が使われる
				chromedp.Flag("headless", false),
				chromedp.Flag("disable-gpu", true),
				chromedp.Flag("no-sandbox", true),
				chromedp.UserDataDir(tempDir),
			)...,
		)
		defer allocCancel()
		// ▲▲▲【修正ここまで】▲▲▲

		// 5) Context とロギング設定
		ctx, cancel := chromedp.NewContext(allocCtx, chromedp.WithLogf(log.Printf))
		defer cancel()

		// 6) ダウンロードフォルダ準備
		downloadDir, err := filepath.Abs(filepath.Join(".", "download", "DAT"))
		if err != nil {
			writeJsonError(w, "ダウンロードディレクトリの絶対パス取得に失敗: "+err.Error(), http.StatusInternalServerError)
			return
		}
		if err := os.MkdirAll(downloadDir, 0755); err != nil {
			writeJsonError(w, "ダウンロードディレクトリの作成に失敗: "+err.Error(), http.StatusInternalServerError)
			return
		}

		filesBefore, err := os.ReadDir(downloadDir)
		if err != nil {
			writeJsonError(w, "ダウンロードディレクトリの読み取りに失敗: "+err.Error(), http.StatusInternalServerError)
			return
		}
		filesBeforeMap := make(map[string]bool)
		for _, f := range filesBefore {
			filesBeforeMap[f.Name()] = true
		}

		// 7) ログインしてボタンをクリック
		var initialTS string
		err = chromedp.Run(ctx,
			browser.SetDownloadBehavior(browser.SetDownloadBehaviorBehaviorAllow).WithDownloadPath(downloadDir),
			chromedp.Navigate(`https://www.e-mednet.jp/`),
			chromedp.WaitVisible(`input[name="userid"]`),
			chromedp.SendKeys(`input[name="userid"]`, cfg.EdeUserID),
			chromedp.SendKeys(`input[name="userpsw"]`, cfg.EdePassword),
			chromedp.Click(`input[type="submit"][value="ログイン"]`),
			chromedp.WaitVisible(`//a[contains(@href, "busi_id=11")]`),
			chromedp.Click(`//a[contains(@href, "busi_id=11")]`),
			chromedp.WaitVisible(`//a[contains(text(), "納品受信(JAN)")]`),
			chromedp.Click(`//a[contains(text(), "納品受信(JAN)")]`),
			chromedp.WaitReady(`input[name="unreceive_button"]`),
			chromedp.Text(`table.result-list-table tbody tr:first-child td.col-transceiving-date`, &initialTS, chromedp.AtLeast(0)),
			chromedp.Click(`input[name="unreceive_button"]`),
		)
		if err != nil {
			writeJsonError(w, "自動操作に失敗しました: "+err.Error(), http.StatusInternalServerError)
			return
		}

		// 8) 結果待ちのロジック (medrecの方式)
		var newFilePath string
		var downloadSuccess, noDataFound bool
		timeout := time.After(30 * time.Second)
	CheckLoop:
		for {
			select {
			case <-timeout:
				writeJsonError(w, "30秒以内にサイトの反応が確認できませんでした。", http.StatusRequestTimeout)
				return
			case <-time.After(1 * time.Second):
				var newLatestTimestamp, resultText string

				checkCtx, cancelCheck := context.WithTimeout(ctx, 4*time.Second)
				_ = chromedp.Run(checkCtx,
					chromedp.Text(`table.result-list-table tbody tr:first-child td.col-transceiving-date`, &newLatestTimestamp, chromedp.AtLeast(0)),
				)
				cancelCheck()

				if strings.TrimSpace(newLatestTimestamp) != strings.TrimSpace(initialTS) {
					checkCtx, cancelCheck = context.WithTimeout(ctx, 4*time.Second)
					_ = chromedp.Run(checkCtx,
						chromedp.Text(`table.result-list-table tbody tr:first-child td.col-result`, &resultText, chromedp.AtLeast(0)),
					)
					cancelCheck()

					if strings.TrimSpace(resultText) == "正常完了" {
						downloadSuccess = true
						break CheckLoop
					}
					if strings.TrimSpace(resultText) == "受信データなし" {
						noDataFound = true
						break CheckLoop
					}
				}
			}
		}

		// 9) 「受信データなし」の場合のハンドリング
		if noDataFound {
			writeJsonError(w, "未受信の納品データはありませんでした。", http.StatusOK)
			return
		}

		// 10) ファイルダウンロード待機処理
		if downloadSuccess {
			timeoutFile := time.After(10 * time.Second)
		FileLoop:
			for {
				select {
				case <-timeoutFile:
					writeJsonError(w, "サイトの反応はありましたが、10秒以内にファイルが見つかりませんでした。", http.StatusInternalServerError)
					return
				case <-time.After(500 * time.Millisecond):
					filesAfter, _ := os.ReadDir(downloadDir)
					for _, f := range filesAfter {
						if !filesBeforeMap[f.Name()] && !strings.HasSuffix(f.Name(), ".crdownload") {
							newFilePath = filepath.Join(downloadDir, f.Name())
							break FileLoop
						}
					}
				}
			}
		} else {
			writeJsonError(w, "ダウンロードされたファイルの検知に失敗しました。", http.StatusInternalServerError)
			return
		}

		// 11) DAT ファイル処理
		processedRecords, err := dat.ProcessDatFile(conn, newFilePath)
		if err != nil {
			writeJsonError(w, "ダウンロードしたDATファイルの処理に失敗: "+err.Error(), http.StatusInternalServerError)
			return
		}

		// 12) レスポンス
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]string{
			"message": fmt.Sprintf("%d件の納品データをダウンロードし登録しました。", len(processedRecords)),
		})
	}
}


----- C:\Users\wasab\OneDrive\デスクトップ\WASABI\guidedinventory\handler.go -----
package guidedinventory

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"time"
	"wasabi/db"
	"wasabi/model"
	"wasabi/units"
)

type StockLedgerYJGroupView struct {
	model.StockLedgerYJGroup
	PackageLedgers []StockLedgerPackageGroupView `json:"packageLedgers"`
}
type StockLedgerPackageGroupView struct {
	model.StockLedgerPackageGroup
	Masters []model.ProductMasterView `json:"masters"`
}
type ResponseDataView struct {
	TransactionLedger []StockLedgerYJGroupView  `json:"transactionLedger"`
	YesterdaysStock   *StockLedgerYJGroupView   `json:"yesterdaysStock"`
	PrecompDetails    []model.TransactionRecord `json:"precompDetails"`
	DeadStockDetails  []model.DeadStockRecord   `json:"deadStockDetails"`
}

// ▼▼▼【ここから修正】▼▼▼
// データベースから取得したモデルを、画面表示用のビューモデルに変換する
func convertToView(yjGroups []model.StockLedgerYJGroup) []StockLedgerYJGroupView {
	if yjGroups == nil {
		return nil
	}

	viewGroups := make([]StockLedgerYJGroupView, 0, len(yjGroups))

	for _, group := range yjGroups {
		newYjGroup := StockLedgerYJGroupView{
			StockLedgerYJGroup: group,
			PackageLedgers:     make([]StockLedgerPackageGroupView, 0, len(group.PackageLedgers)),
		}

		for _, pkg := range group.PackageLedgers {
			newPkgGroup := StockLedgerPackageGroupView{
				StockLedgerPackageGroup: pkg,
				Masters:                 make([]model.ProductMasterView, 0, len(pkg.Masters)),
			}

			for _, master := range pkg.Masters {
				// 包装仕様の文字列を生成するために一時的な構造体にデータを詰め替える
				tempJcshms := model.JCShms{
					JC037: master.PackageForm,
					JC039: master.YjUnitName,
					JC044: master.YjPackUnitQty,
					JA006: sql.NullFloat64{Float64: master.JanPackInnerQty, Valid: true},
					JA008: sql.NullFloat64{Float64: master.JanPackUnitQty, Valid: true},
					JA007: sql.NullString{String: fmt.Sprintf("%d", master.JanUnitCode), Valid: true},
				}

				// JAN単位名を解決する
				var janUnitName string
				if master.JanUnitCode == 0 {
					janUnitName = master.YjUnitName
				} else {
					janUnitName = units.ResolveName(fmt.Sprintf("%d", master.JanUnitCode))
				}

				newMasterView := model.ProductMasterView{
					ProductMaster:        *master,
					FormattedPackageSpec: units.FormatPackageSpec(&tempJcshms),
					JanUnitName:          janUnitName,
				}
				newPkgGroup.Masters = append(newPkgGroup.Masters, newMasterView)
			}
			newYjGroup.PackageLedgers = append(newYjGroup.PackageLedgers, newPkgGroup)
		}
		viewGroups = append(viewGroups, newYjGroup)
	}
	return viewGroups
}

// ▲▲▲【修正ここまで】▲▲▲

func GetInventoryDataHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		q := r.URL.Query()
		yjCode := q.Get("yjCode")
		if yjCode == "" {
			http.Error(w, "yjCode is a required parameter", http.StatusBadRequest)
			return
		}
		now := time.Now()
		endDate := now
		startDate := now.AddDate(0, 0, -30)
		yesterdayDate := now.AddDate(0, 0, -1)
		filtersToday := model.AggregationFilters{
			StartDate: startDate.Format("20060102"),
			EndDate:   endDate.Format("20060102"),
			YjCode:    yjCode,
		}
		ledgerToday, err := db.GetStockLedger(conn, filtersToday)
		if err != nil {
			http.Error(w, "Failed to get today's stock ledger: "+err.Error(), http.StatusInternalServerError)
			return
		}
		filtersYesterday := model.AggregationFilters{
			StartDate: startDate.Format("20060102"),
			EndDate:   yesterdayDate.Format("20060102"),
			YjCode:    yjCode,
		}
		ledgerYesterday, err := db.GetStockLedger(conn, filtersYesterday)
		if err != nil {
			http.Error(w, "Failed to get yesterday's stock ledger: "+err.Error(), http.StatusInternalServerError)
			return
		}
		transactionLedgerView := convertToView(ledgerToday)
		var yesterdaysStockView *StockLedgerYJGroupView
		if len(ledgerYesterday) > 0 {
			view := convertToView(ledgerYesterday)
			if len(view) > 0 {
				yesterdaysStockView = &view[0]
			}
		}
		var productCodes []string
		if len(ledgerToday) > 0 {
			for _, pkg := range ledgerToday[0].PackageLedgers {
				for _, master := range pkg.Masters {
					productCodes = append(productCodes, master.ProductCode)
				}
			}
		}
		precompDetails, err := db.GetPreCompoundingDetailsByProductCodes(conn, productCodes)
		if err != nil {
			http.Error(w, "Failed to get pre-compounding details: "+err.Error(), http.StatusInternalServerError)
			return
		}
		tx, err := conn.Begin()
		if err != nil {
			http.Error(w, "Failed to start transaction for dead stock details", http.StatusInternalServerError)
			return
		}
		defer tx.Rollback()
		deadStockDetails, err := db.GetDeadStockByYjCode(tx, yjCode)
		if err != nil {
			log.Printf("WARN: Failed to get dead stock details for inventory adjustment: %v", err)
		}
		response := ResponseDataView{
			TransactionLedger: transactionLedgerView,
			YesterdaysStock:   yesterdaysStockView,
			PrecompDetails:    precompDetails,
			DeadStockDetails:  deadStockDetails,
		}
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(response)
	}
}

type SavePayload struct {
	Date          string                  `json:"date"`
	YjCode        string                  `json:"yjCode"`
	InventoryData map[string]float64      `json:"inventoryData"`
	DeadStockData []model.DeadStockRecord `json:"deadStockData"`
}

func SaveInventoryDataHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var payload SavePayload
		if err := json.NewDecoder(r.Body).Decode(&payload); err != nil {
			http.Error(w, "Invalid request body: "+err.Error(), http.StatusBadRequest)
			return
		}
		tx, err := conn.Begin()
		if err != nil {
			http.Error(w, "Failed to start transaction", http.StatusInternalServerError)
			return
		}
		defer tx.Rollback()
		masters, err := db.GetProductMastersByYjCode(tx, payload.YjCode)
		if err != nil {
			http.Error(w, "Failed to get product masters for yj: "+err.Error(), http.StatusInternalServerError)
			return
		}
		var allPackagings []model.ProductMaster
		for _, m := range masters {
			allPackagings = append(allPackagings, *m)
		}
		if err := db.SaveGuidedInventoryData(tx, payload.Date, payload.YjCode, allPackagings, payload.InventoryData, payload.DeadStockData); err != nil {
			http.Error(w, "Failed to save inventory data: "+err.Error(), http.StatusInternalServerError)
			return
		}
		if err := tx.Commit(); err != nil {
			http.Error(w, "Failed to commit transaction", http.StatusInternalServerError)
			return
		}
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]string{"message": "棚卸データを保存しました。"})
	}
}


----- C:\Users\wasab\OneDrive\デスクトップ\WASABI\inout\handler.go -----
package inout

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"time"
	"wasabi/db"
	"wasabi/mappers"
	"wasabi/mastermanager"
	"wasabi/model"
)

// SaveRecordInput defines the minimal structure for a line item from the frontend.
type SaveRecordInput struct {
	ProductCode string  `json:"productCode"`
	ProductName string  `json:"productName"` // Used as a fallback for mastermanager
	JanQuantity float64 `json:"janQuantity"`
	DatQuantity float64 `json:"datQuantity"` // 「個数」フィールド
	ExpiryDate  string  `json:"expiryDate"`
	LotNumber   string  `json:"lotNumber"`
}

// SavePayload defines the structure for the entire JSON payload from the frontend.
type SavePayload struct {
	IsNewClient           bool              `json:"isNewClient"`
	ClientCode            string            `json:"clientCode"`
	ClientName            string            `json:"clientName"`
	TransactionDate       string            `json:"transactionDate"`
	TransactionType       string            `json:"transactionType"`
	Records               []SaveRecordInput `json:"records"`
	OriginalReceiptNumber string            `json:"originalReceiptNumber"`
}

// SaveInOutHandler processes the saving of an in/out transaction.
func SaveInOutHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var payload SavePayload
		if err := json.NewDecoder(r.Body).Decode(&payload); err != nil {
			http.Error(w, "Invalid request body", http.StatusBadRequest)
			return
		}

		tx, err := conn.Begin()
		if err != nil {
			http.Error(w, "Failed to start transaction", http.StatusInternalServerError)
			return
		}
		defer tx.Rollback()

		clientCode := payload.ClientCode
		if payload.IsNewClient {
			exists, err := db.CheckClientExistsByName(tx, payload.ClientName)
			if err != nil {
				http.Error(w, "Failed to check client existence", http.StatusInternalServerError)
				return
			}
			if exists {
				http.Error(w, fmt.Sprintf("Client name '%s' already exists.", payload.ClientName), http.StatusConflict)
				return
			}
			newCode, err := db.NextSequenceInTx(tx, "CL", "CL", 4)
			if err != nil {
				http.Error(w, "Failed to generate new client code", http.StatusInternalServerError)
				return
			}
			if err := db.CreateClientInTx(tx, newCode, payload.ClientName); err != nil {
				http.Error(w, "Failed to create new client", http.StatusInternalServerError)
				return
			}
			clientCode = newCode
		}

		var receiptNumber string
		dateStr := payload.TransactionDate
		if dateStr == "" {
			dateStr = time.Now().Format("20060102")
		}

		// ▼▼▼【ここから修正】▼▼▼
		if payload.OriginalReceiptNumber != "" {
			receiptNumber = payload.OriginalReceiptNumber
			// 既存の伝票を編集する場合、まず古い明細をすべて削除する
			if err := db.DeleteTransactionsByReceiptNumberInTx(tx, receiptNumber); err != nil {
				http.Error(w, "Failed to delete old items from slip", http.StatusInternalServerError)
				return
			}
		} else {
			// 新規伝票の場合、新しい伝票番号を採番する
			var lastSeq int
			q := `SELECT CAST(SUBSTR(receipt_number, 11) AS INTEGER) FROM transaction_records 
				  WHERE receipt_number LIKE ? ORDER BY 1 DESC LIMIT 1`
			err = tx.QueryRow(q, "io"+dateStr+"%").Scan(&lastSeq)
			if err != nil && err != sql.ErrNoRows {
				http.Error(w, "Failed to get last receipt number sequence", http.StatusInternalServerError)
				return
			}
			newSeq := lastSeq + 1
			receiptNumber = fmt.Sprintf("io%s%03d", dateStr, newSeq)
		}
		// ▲▲▲【修正ここまで】▲▲▲

		var finalRecords []model.TransactionRecord
		flagMap := map[string]int{"入庫": 11, "出庫": 12}
		flag := flagMap[payload.TransactionType]

		var keyList, janList []string
		keySet, janSet := make(map[string]struct{}), make(map[string]struct{})
		for _, rec := range payload.Records {
			if rec.ProductCode != "" && rec.ProductCode != "0000000000000" {
				if _, seen := janSet[rec.ProductCode]; !seen {
					janSet[rec.ProductCode] = struct{}{}
					janList = append(janList, rec.ProductCode)
				}
			}
			key := rec.ProductCode
			if key == "" || key == "0000000000000" {
				key = fmt.Sprintf("9999999999999%s", rec.ProductName)
			}
			if _, seen := keySet[key]; !seen {
				keySet[key] = struct{}{}
				keyList = append(keyList, key)
			}
		}

		mastersMap, err := db.GetProductMastersByCodesMap(tx, keyList)
		if err != nil {
			http.Error(w, "Failed to pre-fetch product masters", http.StatusInternalServerError)
			return
		}
		jcshmsMap, err := db.GetJcshmsByCodesMap(tx, janList)
		if err != nil {
			http.Error(w, "Failed to pre-fetch JCSHMS data", http.StatusInternalServerError)
			return
		}

		for i, rec := range payload.Records {
			if rec.ProductCode == "" {
				continue
			}
			master, err := mastermanager.FindOrCreate(tx, rec.ProductCode, rec.ProductName, mastersMap, jcshmsMap)
			if err != nil {
				http.Error(w, fmt.Sprintf("Failed to resolve master for %s: %v", rec.ProductName, err), http.StatusInternalServerError)
				return
			}

			yjQuantity := rec.JanQuantity * master.JanPackInnerQty
			unitPrice := master.NhiPrice
			subtotal := yjQuantity * unitPrice

			tr := model.TransactionRecord{
				TransactionDate: dateStr,
				ClientCode:      clientCode,
				ReceiptNumber:   receiptNumber,
				LineNumber:      fmt.Sprintf("%d", i+1),
				Flag:            flag,
				JanCode:         master.ProductCode,
				JanQuantity:     rec.JanQuantity,
				DatQuantity:     rec.DatQuantity,
				YjQuantity:      yjQuantity,
				Subtotal:        subtotal,
				ExpiryDate:      rec.ExpiryDate,
				LotNumber:       rec.LotNumber,
			}

			if master.Origin == "JCSHMS" {
				tr.ProcessFlagMA = "COMPLETE"
			} else {
				tr.ProcessFlagMA = "PROVISIONAL"
			}

			mappers.MapProductMasterToTransaction(&tr, master)
			finalRecords = append(finalRecords, tr)
		}

		if len(finalRecords) > 0 {
			if err := db.PersistTransactionRecordsInTx(tx, finalRecords); err != nil {
				log.Printf("Failed to persist records: %v", err)
				http.Error(w, "Failed to save records to database.", http.StatusInternalServerError)
				return
			}
		}

		if err := tx.Commit(); err != nil {
			http.Error(w, "Failed to commit transaction", http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		response := map[string]interface{}{
			"message":       "Saved successfully",
			"receiptNumber": receiptNumber,
		}
		if payload.IsNewClient {
			response["newClient"] = map[string]string{
				"code": clientCode,
				"name": payload.ClientName,
			}
		}
		json.NewEncoder(w).Encode(response)
	}
}


----- C:\Users\wasab\OneDrive\デスクトップ\WASABI\inventory\handler.go -----
package inventory

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"wasabi/db"
	"wasabi/mappers"
	"wasabi/mastermanager"
	"wasabi/model"
	"wasabi/parsers"
)

const insertTransactionQuery = `
INSERT OR REPLACE INTO transaction_records (
    transaction_date, client_code, receipt_number, line_number, flag,
    jan_code, yj_code, product_name, kana_name, usage_classification, package_form, package_spec, maker_name,
    dat_quantity, jan_pack_inner_qty, jan_quantity, jan_pack_unit_qty, jan_unit_name, jan_unit_code,
    yj_quantity, yj_pack_unit_qty, yj_unit_name, unit_price, purchase_price, supplier_wholesale,
    subtotal, tax_amount, tax_rate, expiry_date, lot_number, flag_poison,
    flag_deleterious, flag_narcotic, flag_psychotropic, flag_stimulant,
    flag_stimulant_raw, process_flag_ma
) VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)`

// UploadInventoryHandler handles the inventory file upload process.
func UploadInventoryHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var originalJournalMode string
		conn.QueryRow("PRAGMA journal_mode").Scan(&originalJournalMode)

		conn.Exec("PRAGMA journal_mode = MEMORY;")
		conn.Exec("PRAGMA synchronous = OFF;")

		defer func() {
			conn.Exec("PRAGMA synchronous = FULL;")
			conn.Exec(fmt.Sprintf("PRAGMA journal_mode = %s;", originalJournalMode))
			log.Println("Database settings restored for Inventory handler.")
		}()

		file, _, err := r.FormFile("file")
		if err != nil {
			http.Error(w, "File upload error", http.StatusBadRequest)
			return
		}
		defer file.Close()

		parsedData, err := parsers.ParseInventoryFile(file)
		if err != nil {
			http.Error(w, fmt.Sprintf("Failed to parse file: %v", err), http.StatusBadRequest)
			return
		}
		date := parsedData.Date
		if date == "" {
			http.Error(w, "Inventory date not found in file's H record", http.StatusBadRequest)
			return
		}

		tx, err := conn.Begin()
		if err != nil {
			http.Error(w, "Failed to start transaction", http.StatusInternalServerError)
			return
		}
		defer tx.Rollback()

		recordsToProcess := parsedData.Records

		janCodesFromFile := make([]string, 0, len(recordsToProcess))
		for _, rec := range recordsToProcess {
			if rec.JanCode != "" {
				janCodesFromFile = append(janCodesFromFile, rec.JanCode)
			}
		}

		if len(janCodesFromFile) > 0 {
			if err := db.DeleteTransactionsByFlagAndDateAndCodes(tx, 0, date, janCodesFromFile); err != nil {
				http.Error(w, "Failed to clear old inventory data for specified products: "+err.Error(), http.StatusInternalServerError)
				return
			}
		}

		if len(recordsToProcess) == 0 {
			if err := tx.Commit(); err != nil {
				http.Error(w, "Failed to commit transaction: "+err.Error(), http.StatusInternalServerError)
				return
			}
			w.Header().Set("Content-Type", "application/json")
			json.NewEncoder(w).Encode(map[string]interface{}{
				"message": "棚卸ファイルにデータがありませんでした。",
				"details": []model.TransactionRecord{},
			})
			return
		}

		for i := range recordsToProcess {
			recordsToProcess[i].YjQuantity = recordsToProcess[i].JanQuantity * recordsToProcess[i].JanPackInnerQty
		}

		var keyList, janList []string
		keySet, janSet := make(map[string]struct{}), make(map[string]struct{})
		for _, rec := range recordsToProcess {
			if rec.JanCode != "" && rec.JanCode != "0000000000000" {
				if _, seen := janSet[rec.JanCode]; !seen {
					janSet[rec.JanCode] = struct{}{}
					janList = append(janList, rec.JanCode)
				}
			}
			key := rec.JanCode
			if key == "" || key == "0000000000000" {
				key = fmt.Sprintf("9999999999999%s", rec.ProductName)
			}
			if _, seen := keySet[key]; !seen {
				keySet[key] = struct{}{}
				keyList = append(keyList, key)
			}
		}

		mastersMap, err := db.GetProductMastersByCodesMap(tx, keyList)
		if err != nil {
			tx.Rollback()
			http.Error(w, "Failed to pre-fetch product masters", http.StatusInternalServerError)
			return
		}
		jcshmsMap, err := db.GetJcshmsByCodesMap(tx, janList)
		if err != nil {
			tx.Rollback()
			http.Error(w, "Failed to pre-fetch JCSHMS data", http.StatusInternalServerError)
			return
		}

		stmt, err := tx.Prepare(insertTransactionQuery)
		if err != nil {
			tx.Rollback()
			http.Error(w, "Failed to prepare statement", http.StatusInternalServerError)
			return
		}
		defer stmt.Close()

		const batchSize = 500
		var finalRecords []model.TransactionRecord
		receiptNumber := fmt.Sprintf("INV%s", date)

		for i, rec := range recordsToProcess {
			tr := model.TransactionRecord{
				Flag: 0, JanCode: rec.JanCode, ProductName: rec.ProductName, YjQuantity: rec.YjQuantity,
				TransactionDate: date, ReceiptNumber: receiptNumber, LineNumber: fmt.Sprintf("%d", i+1),
			}

			master, err := mastermanager.FindOrCreate(tx, rec.JanCode, rec.ProductName, mastersMap, jcshmsMap)
			if err != nil {
				tx.Rollback()
				http.Error(w, fmt.Sprintf("mastermanager failed for jan %s: %v", rec.JanCode, err), http.StatusInternalServerError)
				return
			}

			if master.JanPackInnerQty > 0 {
				tr.JanQuantity = tr.YjQuantity / master.JanPackInnerQty
			}
			mappers.MapProductMasterToTransaction(&tr, master)

			// ▼▼▼【修正】Subtotalを計算する処理を追加 ▼▼▼
			tr.Subtotal = tr.YjQuantity * tr.UnitPrice
			// ▲▲▲【修正ここまで】▲▲▲

			if master.Origin == "JCSHMS" {
				tr.ProcessFlagMA = "COMPLETE"
			} else {
				tr.ProcessFlagMA = "PROVISIONAL"
			}

			_, err = stmt.Exec(
				tr.TransactionDate, tr.ClientCode, tr.ReceiptNumber, tr.LineNumber, tr.Flag,
				tr.JanCode, tr.YjCode, tr.ProductName, tr.KanaName, tr.UsageClassification, tr.PackageForm, tr.PackageSpec, tr.MakerName,
				tr.DatQuantity, tr.JanPackInnerQty, tr.JanQuantity, tr.JanPackUnitQty, tr.JanUnitName, tr.JanUnitCode,
				tr.YjQuantity, tr.YjPackUnitQty, tr.YjUnitName, tr.UnitPrice, tr.PurchasePrice, tr.SupplierWholesale,
				tr.Subtotal, tr.TaxAmount, tr.TaxRate, tr.ExpiryDate, tr.LotNumber, tr.FlagPoison,
				tr.FlagDeleterious, tr.FlagNarcotic, tr.FlagPsychotropic, tr.FlagStimulant,
				tr.FlagStimulantRaw, tr.ProcessFlagMA,
			)
			if err != nil {
				tx.Rollback()
				http.Error(w, fmt.Sprintf("Failed to insert record for JAN %s: %v", tr.JanCode, err), http.StatusInternalServerError)
				return
			}

			finalRecords = append(finalRecords, tr)

			if (i+1)%batchSize == 0 && i < len(recordsToProcess)-1 {
				if err := tx.Commit(); err != nil {
					log.Printf("transaction commit error (batch): %v", err)
					http.Error(w, "internal server error", http.StatusInternalServerError)
					return
				}
				tx, err = conn.Begin()
				if err != nil {
					http.Error(w, "Failed to begin next transaction", http.StatusInternalServerError)
					return
				}
				stmt, err = tx.Prepare(insertTransactionQuery)
				if err != nil {
					tx.Rollback()
					http.Error(w, "Failed to re-prepare statement", http.StatusInternalServerError)
					return
				}
			}
		}

		if err := tx.Commit(); err != nil {
			log.Printf("transaction commit error (final): %v", err)
			http.Error(w, "internal server error", http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]interface{}{
			"message": fmt.Sprintf("%d件の棚卸データをファイルから登録しました。", len(finalRecords)),
			"details": finalRecords,
		})
	}
}


----- C:\Users\wasab\OneDrive\デスクトップ\WASABI\inventory\manual_handler.go -----
package inventory

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"net/http"
	"wasabi/db"
	"wasabi/mappers"
	"wasabi/model"
)

// ListInventoryProductsHandler returns all product masters with their last inventory date.
func ListInventoryProductsHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		products, err := db.GetAllProductMasters(conn)
		if err != nil {
			http.Error(w, "Failed to get product list: "+err.Error(), http.StatusInternalServerError)
			return
		}

		dateMap, err := db.GetLastInventoryDateMap(conn)
		if err != nil {
			http.Error(w, "Failed to get last inventory dates: "+err.Error(), http.StatusInternalServerError)
			return
		}

		var result []model.InventoryProductView
		for _, p := range products {
			result = append(result, model.InventoryProductView{
				ProductMaster:     *p,
				LastInventoryDate: dateMap[p.ProductCode],
			})
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(result)
	}
}

type ManualInventoryRecord struct {
	ProductCode string  `json:"productCode"`
	YjQuantity  float64 `json:"yjQuantity"`
}

type ManualInventoryPayload struct {
	Date    string                  `json:"date"`
	Records []ManualInventoryRecord `json:"records"`
}

// SaveManualInventoryHandler saves the manually entered inventory counts.
func SaveManualInventoryHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var payload ManualInventoryPayload
		if err := json.NewDecoder(r.Body).Decode(&payload); err != nil {
			http.Error(w, "Invalid request body", http.StatusBadRequest)
			return
		}

		if payload.Date == "" {
			http.Error(w, "Date is required", http.StatusBadRequest)
			return
		}

		tx, err := conn.Begin()
		if err != nil {
			http.Error(w, "Failed to start transaction", http.StatusInternalServerError)
			return
		}
		defer tx.Rollback()

		var productCodes []string
		recordsMap := make(map[string]float64)
		for _, rec := range payload.Records {
			productCodes = append(productCodes, rec.ProductCode)
			recordsMap[rec.ProductCode] = rec.YjQuantity
		}

		if len(productCodes) > 0 {
			if err := db.DeleteTransactionsByFlagAndDateAndCodes(tx, 0, payload.Date, productCodes); err != nil {
				http.Error(w, "Failed to clear old inventory data for specified products", http.StatusInternalServerError)
				return
			}
		}

		if len(productCodes) == 0 {
			w.Header().Set("Content-Type", "application/json")
			json.NewEncoder(w).Encode(map[string]string{"message": "保存するデータがありませんでした。"})
			return
		}

		mastersMap, err := db.GetProductMastersByCodesMap(tx, productCodes)
		if err != nil {
			http.Error(w, "Failed to get product masters", http.StatusInternalServerError)
			return
		}

		var finalRecords []model.TransactionRecord
		receiptNumber := fmt.Sprintf("INV%s", payload.Date)

		for i, code := range productCodes {
			master, ok := mastersMap[code]
			if !ok {
				continue
			}

			tr := model.TransactionRecord{
				TransactionDate: payload.Date,
				Flag:            0, // 0 = Inventory
				JanCode:         master.ProductCode,
				YjQuantity:      recordsMap[code],
				ReceiptNumber:   receiptNumber,
				LineNumber:      fmt.Sprintf("%d", i+1),
			}

			if master.Origin == "JCSHMS" {
				tr.ProcessFlagMA = "COMPLETE"
			} else {
				tr.ProcessFlagMA = "PROVISIONAL"
			}

			if master.JanPackInnerQty > 0 {
				tr.JanQuantity = tr.YjQuantity / master.JanPackInnerQty
			}

			mappers.MapProductMasterToTransaction(&tr, master)

			// ▼▼▼【修正】Subtotalを計算する処理を追加 ▼▼▼
			tr.Subtotal = tr.YjQuantity * tr.UnitPrice
			// ▲▲▲【修正ここまで】▲▲▲

			finalRecords = append(finalRecords, tr)
		}

		if err := db.PersistTransactionRecordsInTx(tx, finalRecords); err != nil {
			http.Error(w, "Failed to save inventory records", http.StatusInternalServerError)
			return
		}

		if err := tx.Commit(); err != nil {
			http.Error(w, "Failed to commit transaction", http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]string{"message": fmt.Sprintf("%d件の棚卸データを保存しました。", len(finalRecords))})
	}
}


----- C:\Users\wasab\OneDrive\デスクトップ\WASABI\inventory\migrate_handler.go -----
package inventory

import (
	"bufio"
	"database/sql"
	"encoding/csv"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"strconv"
	"strings"
	"wasabi/db"
	"wasabi/mappers"
	"wasabi/model"
)

// MigrationResultRow は移行処理の各行の結果を格納します
type MigrationResultRow struct {
	OriginalRow   []string                 `json:"originalRow"`
	ParsedRecord  model.UnifiedInputRecord `json:"parsedRecord"`
	MasterCreated string                   `json:"masterCreated"` // "JCSHMS", "PROVISIONAL", "EXISTED"
	ResultRecord  *model.TransactionRecord `json:"resultRecord"`
	Error         string                   `json:"error"`
	IsZeroFill    bool                     `json:"isZeroFill,omitempty"`
}

// MigrateInventoryHandler は在庫移行用のCSVアップロードを処理します
func MigrateInventoryHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		file, _, err := r.FormFile("file")
		if err != nil {
			http.Error(w, "ファイルのアップロードエラー: "+err.Error(), http.StatusBadRequest)
			return
		}
		defer file.Close()

		br := bufio.NewReader(file)
		bom, err := br.Peek(3)
		if err == nil && bom[0] == 0xef && bom[1] == 0xbb && bom[2] == 0xbf {
			br.Discard(3)
		}

		csvReader := csv.NewReader(br)
		csvReader.LazyQuotes = true
		allRows, err := csvReader.ReadAll()
		if err != nil {
			http.Error(w, "CSVファイルの解析に失敗: "+err.Error(), http.StatusBadRequest)
			return
		}

		if len(allRows) < 2 {
			http.Error(w, "CSVにヘッダー行またはデータ行がありません。", http.StatusBadRequest)
			return
		}

		headerMap := make(map[string]int)
		for i, header := range allRows[0] {
			headerMap[header] = i
		}

		dateIdx, okDate := headerMap["inventory_date"]
		codeIdx, okCode := headerMap["product_code"]
		qtyIdx, okQty := headerMap["quantity"]

		if !okDate || !okCode || !okQty {
			http.Error(w, "CSVヘッダーに 'inventory_date', 'product_code', 'quantity' が見つかりません。", http.StatusBadRequest)
			return
		}

		recordsByDate := make(map[string][]model.UnifiedInputRecord)
		originalRowsByDate := make(map[string][][]string)

		for i, row := range allRows {
			if i == 0 {
				continue
			}
			date := row[dateIdx]
			code := strings.Trim(strings.TrimSpace(row[codeIdx]), `="`)
			qty, _ := strconv.ParseFloat(row[qtyIdx], 64)

			if date != "" && code != "" {
				recordsByDate[date] = append(recordsByDate[date], model.UnifiedInputRecord{
					Date:       date,
					JanCode:    code,
					YjQuantity: qty,
				})
				originalRowsByDate[date] = append(originalRowsByDate[date], row)
			}
		}

		var finalResults []MigrationResultRow
		var totalImported int

		for date, recs := range recordsByDate {
			var dateResults []MigrationResultRow
			for i := range recs {
				dateResults = append(dateResults, MigrationResultRow{
					OriginalRow:  originalRowsByDate[date][i],
					ParsedRecord: recs[i],
				})
			}

			tx, err := conn.Begin()
			if err != nil {
				for i := range dateResults {
					dateResults[i].Error = "トランザクション開始エラー: " + err.Error()
				}
				finalResults = append(finalResults, dateResults...)
				continue
			}

			var productCodes []string
			csvProductCodesMap := make(map[string]struct{})
			for _, rec := range recs {
				if _, exists := csvProductCodesMap[rec.JanCode]; !exists {
					productCodes = append(productCodes, rec.JanCode)
					csvProductCodesMap[rec.JanCode] = struct{}{}
				}
			}

			mastersMap, err := db.GetProductMastersByCodesMap(tx, productCodes)
			if err != nil {
				tx.Rollback()
				for i := range dateResults {
					dateResults[i].Error = "既存マスターの検索中にエラーが発生: " + err.Error()
				}
				finalResults = append(finalResults, dateResults...)
				continue
			}

			for i, rec := range recs {
				if _, exists := mastersMap[rec.JanCode]; !exists {
					masterStatus := ""
					jcshms, errJcshms := db.GetJcshmsRecordByJan(tx, rec.JanCode)
					if errJcshms == nil && jcshms != nil {
						newMasterInput := mappers.JcshmsToProductMasterInput(jcshms, rec.JanCode)
						if errUpsert := db.UpsertProductMasterInTx(tx, newMasterInput); errUpsert == nil {
							masterStatus = "JCSHMS"
						}
					} else {
						newYjCode, errSeq := db.NextSequenceInTx(tx, "MA2Y", "MA2Y", 8)
						if errSeq == nil {
							provisionalMaster := model.ProductMasterInput{
								ProductCode: rec.JanCode, YjCode: newYjCode,
								ProductName: fmt.Sprintf("（JCSHMS未登録 JAN: %s）", rec.JanCode), Origin: "PROVISIONAL",
							}
							if errUpsert := db.UpsertProductMasterInTx(tx, provisionalMaster); errUpsert == nil {
								masterStatus = "PROVISIONAL"
							}
						}
					}
					dateResults[i].MasterCreated = masterStatus
				} else {
					dateResults[i].MasterCreated = "EXISTED"
				}
			}

			mastersMap, err = db.GetProductMastersByCodesMap(tx, productCodes)
			if err != nil {
				tx.Rollback()
				for i := range dateResults {
					dateResults[i].Error = "マスターの再検索中にエラーが発生: " + err.Error()
				}
				finalResults = append(finalResults, dateResults...)
				continue
			}

			if err := db.DeleteTransactionsByFlagAndDate(tx, 0, date); err != nil {
				tx.Rollback()
				for i := range dateResults {
					dateResults[i].Error = "古い棚卸データの削除に失敗: " + err.Error()
				}
				finalResults = append(finalResults, dateResults...)
				continue
			}

			for i, rec := range recs {
				master, ok := mastersMap[rec.JanCode]
				if !ok {
					dateResults[i].Error = "マスターデータの解決に失敗しました。"
					continue
				}

				tr := model.TransactionRecord{
					TransactionDate: rec.Date, Flag: 0, JanCode: rec.JanCode, YjQuantity: rec.YjQuantity,
					ReceiptNumber: fmt.Sprintf("MIGRATE-%s", date), LineNumber: strconv.Itoa(i + 1),
				}
				if master.JanPackInnerQty > 0 {
					tr.JanQuantity = tr.YjQuantity / master.JanPackInnerQty
				}
				mappers.MapProductMasterToTransaction(&tr, master)
				tr.ProcessFlagMA = "COMPLETE"

				// ▼▼▼【修正】Subtotalを計算する処理を追加 ▼▼▼
				tr.Subtotal = tr.YjQuantity * tr.UnitPrice
				// ▲▲▲【修正ここまで】▲▲▲

				if err := db.PersistTransactionRecordsInTx(tx, []model.TransactionRecord{tr}); err != nil {
					dateResults[i].Error = "レコード登録に失敗: " + err.Error()
					continue
				}
				dateResults[i].ResultRecord = &tr
				totalImported++
			}

			allMasters, err := db.GetAllProductMasters(tx)
			if err != nil {
				tx.Rollback()
				errorMsg := "ゼロフィル対象の全マスター取得に失敗: " + err.Error()
				for j := range dateResults {
					if dateResults[j].Error == "" {
						dateResults[j].Error = errorMsg
					}
				}
				finalResults = append(finalResults, dateResults...)
				continue
			}

			var zeroFillRecords []model.TransactionRecord
			var zeroFillResults []MigrationResultRow
			receiptNumber := fmt.Sprintf("MIGRATE-%s", date)
			zeroFillCounter := 0

			for _, master := range allMasters {
				if _, existsInCsv := csvProductCodesMap[master.ProductCode]; !existsInCsv {
					zeroFillCounter++
					tr := model.TransactionRecord{
						TransactionDate: date,
						Flag:            0,
						JanCode:         master.ProductCode,
						YjQuantity:      0,
						JanQuantity:     0,
						ReceiptNumber:   receiptNumber,
						LineNumber:      fmt.Sprintf("Z%d", zeroFillCounter),
						ProcessFlagMA:   "COMPLETE",
						UnitPrice:       0, // 金額も0なので単価も0
						Subtotal:        0,
					}
					mappers.MapProductMasterToTransaction(&tr, master)
					tr.UnitPrice = master.NhiPrice // ただし単価は記録しておく
					zeroFillRecords = append(zeroFillRecords, tr)

					zeroFillResults = append(zeroFillResults, MigrationResultRow{
						OriginalRow:   []string{"- (ゼロフィル対象) -"},
						ParsedRecord:  model.UnifiedInputRecord{JanCode: master.ProductCode, YjQuantity: 0},
						MasterCreated: "EXISTED",
						ResultRecord:  &tr,
						IsZeroFill:    true,
					})
				}
			}

			if len(zeroFillRecords) > 0 {
				if err := db.PersistTransactionRecordsInTx(tx, zeroFillRecords); err != nil {
					tx.Rollback()
					errorMsg := "ゼロフィルレコードのDB保存に失敗: " + err.Error()
					for j := range dateResults {
						if dateResults[j].Error == "" {
							dateResults[j].Error = errorMsg
						}
					}
					finalResults = append(finalResults, dateResults...)
					continue
				}
				totalImported += len(zeroFillRecords)
			}

			finalResults = append(finalResults, dateResults...)
			finalResults = append(finalResults, zeroFillResults...)

			if err := tx.Commit(); err != nil {
				log.Printf("Failed to commit transaction for date %s: %v", date, err)
			}
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]interface{}{
			"message": fmt.Sprintf("計%d件の在庫データを処理しました。", totalImported),
			"details": finalResults,
		})
	}
}


----- C:\Users\wasab\OneDrive\デスクトップ\WASABI\loader\handler.go -----
// C:\Users\wasab\OneDrive\デスクトップ\WASABI\loader\handler.go
package loader

import (
	"database/sql"
	"encoding/csv"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"strconv"
	"strings"
	"wasabi/db"
	"wasabi/model"

	"golang.org/x/text/encoding/japanese"
	"golang.org/x/text/transform"
)

type UpdatedProductView struct {
	ProductCode string `json:"productCode"`
	ProductName string `json:"productName"`
	Status      string `json:"status"` // "UPDATED", "ORPHANED", "NEW"
}

func CreateMasterUpdateHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		log.Println("新しい要件に基づくJCSHMSマスター更新処理を開始します...")

		// === ステップ1: 必要なデータを全てメモリにロード ===
		newJcshmsData, err := loadCSVToMap("SOU/JCSHMS.CSV", false, 0)
		if err != nil {
			http.Error(w, "JCSHMS.CSVの読み込みに失敗しました: "+err.Error(), http.StatusInternalServerError)
			return
		}
		newJancodeData, err := loadCSVToMap("SOU/JANCODE.CSV", true, 1)
		if err != nil {
			http.Error(w, "JANCODE.CSVの読み込みに失敗しました: "+err.Error(), http.StatusInternalServerError)
			return
		}
		existingMasters, err := db.GetAllProductMasters(conn)
		if err != nil {
			http.Error(w, "既存の製品マスターの取得に失敗しました: "+err.Error(), http.StatusInternalServerError)
			return
		}

		tx, err := conn.Begin()
		if err != nil {
			http.Error(w, "トランザクションの開始に失敗しました", http.StatusInternalServerError)
			return
		}
		defer tx.Rollback()

		var updatedProducts, orphanedProducts, newlyAddedProducts []UpdatedProductView

		existingMastersMap := make(map[string]*model.ProductMaster)
		for _, m := range existingMasters {
			existingMastersMap[m.ProductCode] = m
		}

		// --- 既存マスターの更新と孤立化処理 ---
		for _, master := range existingMasters {
			jcshmsRow, matchFound := newJcshmsData[master.ProductCode]
			if matchFound {
				jancodeRow := newJancodeData[master.ProductCode]
				// ProductMasterInputへの変換ロジックを createInputFromCSV に集約
				input := createInputFromCSV(jcshmsRow, jancodeRow)

				// ▼▼▼【ここから修正】▼▼▼
				if input.YjCode == "" {
					// JCSHMSにYJコードがない場合
					if master.YjCode != "" {
						// DBに既にYJコードがあれば（手入力されたものなど）、それを維持する
						input.YjCode = master.YjCode
					} else {
						// DBにもYJコードがなければ、新規に採番する
						newYjCode, err := db.NextSequenceInTx(tx, "MA2Y", "MA2Y", 8)
						if err != nil {
							http.Error(w, fmt.Sprintf("YJコードの採番に失敗 (JAN: %s): %v", master.ProductCode, err), http.StatusInternalServerError)
							return
						}
						input.YjCode = newYjCode
					}
				}
				// ▲▲▲【修正ここまで】▲▲▲

				// 既存のユーザー設定項目を維持する
				input.PurchasePrice = master.PurchasePrice
				input.SupplierWholesale = master.SupplierWholesale
				input.GroupCode = master.GroupCode
				input.ShelfNumber = master.ShelfNumber
				input.Category = master.Category
				input.UserNotes = master.UserNotes
				input.IsOrderStopped = master.IsOrderStopped // 発注可否設定を引き継ぐ

				if err := db.UpsertProductMasterInTx(tx, input); err != nil {
					http.Error(w, fmt.Sprintf("マスターの上書き更新に失敗 (JAN: %s): %v", master.ProductCode, err), http.StatusInternalServerError)
					return
				}
				updatedProducts = append(updatedProducts, UpdatedProductView{ProductCode: master.ProductCode, ProductName: input.ProductName, Status: "UPDATED"})
			} else if master.Origin == "JCSHMS" {
				// JCSHMS由来のマスターがCSVから消えた場合、PROVISIONAL化する
				newProductName := master.ProductName
				if !strings.HasPrefix(master.ProductName, "◆") {
					newProductName = "◆" + newProductName
				}
				master.Origin = "PROVISIONAL"
				master.ProductName = newProductName
				// 更新用のInputを作成
				input := model.ProductMasterInput{
					ProductCode:         master.ProductCode,
					YjCode:              master.YjCode,
					Gs1Code:             master.Gs1Code,
					ProductName:         master.ProductName,
					KanaName:            master.KanaName,
					MakerName:           master.MakerName,
					Specification:       master.Specification,
					UsageClassification: master.UsageClassification,
					PackageForm:         master.PackageForm,
					YjUnitName:          master.YjUnitName,
					YjPackUnitQty:       master.YjPackUnitQty,
					JanPackInnerQty:     master.JanPackInnerQty,
					JanUnitCode:         master.JanUnitCode,
					JanPackUnitQty:      master.JanPackUnitQty,
					Origin:              master.Origin,
					NhiPrice:            master.NhiPrice,
					PurchasePrice:       master.PurchasePrice,
					FlagPoison:          master.FlagPoison,
					FlagDeleterious:     master.FlagDeleterious,
					FlagNarcotic:        master.FlagNarcotic,
					FlagPsychotropic:    master.FlagPsychotropic,
					FlagStimulant:       master.FlagStimulant,
					FlagStimulantRaw:    master.FlagStimulantRaw,
					IsOrderStopped:      master.IsOrderStopped,
					SupplierWholesale:   master.SupplierWholesale,
					GroupCode:           master.GroupCode,
					ShelfNumber:         master.ShelfNumber,
					Category:            master.Category,
					UserNotes:           master.UserNotes,
				}
				if err := db.UpsertProductMasterInTx(tx, input); err != nil {
					http.Error(w, fmt.Sprintf("マスターのPROVISIONAL化に失敗 (JAN: %s): %v", master.ProductCode, err), http.StatusInternalServerError)
					return
				}
				orphanedProducts = append(orphanedProducts, UpdatedProductView{ProductCode: master.ProductCode, ProductName: newProductName, Status: "ORPHANED"})
			}
		}

		// --- 新規マスターの追加処理 ---
		// ▼▼▼【ご指示により、JCSHMSマスターにしか存在しない新規品目を自動で追加する機能を削除】▼▼▼
		/*
			for productCode, jcshmsRow := range newJcshmsData {
				if _, exists := existingMastersMap[productCode]; !exists {
					jancodeRow := newJancodeData[productCode]
					input := createInputFromCSV(jcshmsRow, jancodeRow)
					if err := db.UpsertProductMasterInTx(tx, input); err != nil {
						http.Error(w, fmt.Sprintf("新規マスターの追加に失敗 (JAN: %s): %v", productCode, err), http.StatusInternalServerError)
						return
					}
					newlyAddedProducts = append(newlyAddedProducts, UpdatedProductView{ProductCode: productCode, ProductName: input.ProductName, Status: "NEW"})
				}
			}
		*/
		// ▲▲▲【削除ここまで】▲▲▲

		if err := tx.Commit(); err != nil {
			http.Error(w, "トランザクションのコミットに失敗しました", http.StatusInternalServerError)
			return
		}

		log.Println("新しい要件に基づくJCSHMSマスター更新処理が正常に完了しました。")
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]interface{}{
			"message":            "指定の要件で製品マスターの更新が完了しました。",
			"updatedProducts":    updatedProducts,
			"orphanedProducts":   orphanedProducts,
			"newlyAddedProducts": newlyAddedProducts,
		})
	}
}

func loadCSVToMap(filepath string, skipHeader bool, keyIndex int) (map[string][]string, error) {
	f, err := os.Open(filepath)
	if err != nil {
		return nil, err
	}
	defer f.Close()

	r := csv.NewReader(transform.NewReader(f, japanese.ShiftJIS.NewDecoder()))
	r.LazyQuotes = true
	r.FieldsPerRecord = -1
	if skipHeader {
		if _, err := r.Read(); err != nil && err != io.EOF {
			return nil, err
		}
	}

	dataMap := make(map[string][]string)
	for {
		row, err := r.Read()
		if err != nil {
			if err == io.EOF {
				break
			}
			return nil, err
		}
		if len(row) > keyIndex {
			dataMap[row[keyIndex]] = row
		}
	}
	return dataMap, nil
}

func createInputFromCSV(jcshmsRow, jancodeRow []string) model.ProductMasterInput {
	var input model.ProductMasterInput
	if len(jcshmsRow) < 123 {
		return input
	}

	yjPackUnitQty, _ := strconv.ParseFloat(jcshmsRow[44], 64)
	packagePrice, _ := strconv.ParseFloat(jcshmsRow[50], 64)

	var unitNhiPrice float64
	if yjPackUnitQty > 0 {
		unitNhiPrice = packagePrice / yjPackUnitQty
	}

	input.ProductCode = jcshmsRow[0]
	input.YjCode = jcshmsRow[9]
	input.Gs1Code = jcshmsRow[122]
	input.ProductName = strings.TrimSpace(jcshmsRow[18])
	input.Specification = strings.TrimSpace(jcshmsRow[20])
	input.Origin = "JCSHMS"
	input.KanaName = jcshmsRow[22]
	input.MakerName = jcshmsRow[30]
	input.UsageClassification = jcshmsRow[13]
	input.PackageForm = jcshmsRow[37]
	input.YjUnitName = jcshmsRow[39]
	input.YjPackUnitQty = yjPackUnitQty
	input.NhiPrice = unitNhiPrice
	input.FlagPoison, _ = strconv.Atoi(jcshmsRow[61])
	input.FlagDeleterious, _ = strconv.Atoi(jcshmsRow[62])
	input.FlagNarcotic, _ = strconv.Atoi(jcshmsRow[63])
	input.FlagPsychotropic, _ = strconv.Atoi(jcshmsRow[64])
	input.FlagStimulant, _ = strconv.Atoi(jcshmsRow[65])
	input.FlagStimulantRaw, _ = strconv.Atoi(jcshmsRow[66])

	if input.YjCode == "" {
		input.UsageClassification = "他"
	}

	if len(jancodeRow) > 6 {
		input.JanPackInnerQty, _ = strconv.ParseFloat(jancodeRow[6], 64)
	}
	if len(jancodeRow) > 7 {
		input.JanUnitCode, _ = strconv.Atoi(jancodeRow[7])
	}
	if len(jancodeRow) > 8 {
		input.JanPackUnitQty, _ = strconv.ParseFloat(jancodeRow[8], 64)
	}
	return input
}


----- C:\Users\wasab\OneDrive\デスクトップ\WASABI\loader\loader.go -----
// C:\Users\wasab\OneDrive\デスクトップ\WASABI\loader\loader.go
package loader

import (
	"database/sql"
	"encoding/csv"
	"fmt"
	"io"
	"os"
	"strconv"
	"strings"

	"golang.org/x/text/encoding/japanese"
	"golang.org/x/text/transform"
)

// ▼▼▼【ここから修正】▼▼▼
var tableSchemas = map[string]map[int]string{
	"jcshms": {
		45:  "real", // JC044
		50:  "real", // JC049
		51:  "real", // JC050
		62:  "int",  // JC061
		63:  "int",  // JC062
		64:  "int",  // JC063
		65:  "int",  // JC064
		66:  "int",  // JC065
		67:  "int",  // JC066
		125: "real", // JC124
	},
	"jancode": {
		7: "real",
		9: "real",
	},
}

// ▲▲▲【修正ここまで】▲▲▲

// InitDatabase creates the schema and loads master data from CSV files.
func InitDatabase(db *sql.DB) error {
	if err := applySchema(db); err != nil {
		return fmt.Errorf("failed to apply schema.sql: %w", err)
	}
	if err := LoadCSV(db, "SOU/JCSHMS.CSV", "jcshms", 125, false); err != nil {
		return fmt.Errorf("failed to load JCSHMS.CSV: %w", err)
	}
	if err := LoadCSV(db, "SOU/JANCODE.CSV", "jancode", 30, true); err != nil {
		return fmt.Errorf("failed to load JANCODE.CSV: %w", err)
	}
	return nil
}

func applySchema(db *sql.DB) error {
	schema, err := os.ReadFile("schema.sql")
	if err != nil {
		return err
	}
	_, err = db.Exec(string(schema))
	return err
}

func LoadCSV(db *sql.DB, filepath, tablename string, columns int, skipHeader bool) error {
	f, err := os.Open(filepath)
	if err != nil {
		return err
	}
	defer f.Close()

	r := csv.NewReader(transform.NewReader(f, japanese.ShiftJIS.NewDecoder()))
	r.LazyQuotes = true
	r.FieldsPerRecord = -1

	if skipHeader {
		if _, err := r.Read(); err != nil && err != io.EOF {
			return err
		}
	}

	tx, err := db.Begin()
	if err != nil {
		return err
	}
	defer tx.Rollback()

	placeholders := strings.Repeat("?,", columns-1) + "?"
	stmt, err := tx.Prepare(fmt.Sprintf("INSERT OR REPLACE INTO %s VALUES (%s)", tablename, placeholders))
	if err != nil {
		return err
	}
	defer stmt.Close()

	schema := tableSchemas[tablename]

	for {
		row, err := r.Read()
		if err == io.EOF {
			break
		}
		if err != nil || len(row) < columns {
			continue
		}

		args := make([]interface{}, columns)
		for i := 0; i < columns; i++ {
			val := row[i]
			// CSVの列番号は0から始まるので、スキーマのキー(1から始まる)に合わせるために+1する
			if colType, ok := schema[i+1]; ok {
				trimmedVal := strings.TrimSpace(val)
				switch colType {
				case "real":
					num, _ := strconv.ParseFloat(trimmedVal, 64)
					args[i] = num
				case "int":
					num, _ := strconv.ParseInt(trimmedVal, 10, 64)
					args[i] = num
				}
			} else {
				args[i] = val
			}
		}

		if _, err := stmt.Exec(args...); err != nil {
			continue
		}
	}
	return tx.Commit()
}


----- C:\Users\wasab\OneDrive\デスクトップ\WASABI\mappers\jcshms_to_master.go -----
// C:\Users\wasab\OneDrive\デスクトップ\WASABI\mappers\jcshms_to_master.go
package mappers

import (
	"strconv"
	"strings"
	"wasabi/model"
)

// JcshmsToProductMasterInput はJCSHMSのレコードをProductMasterInputに変換します。
func JcshmsToProductMasterInput(jcshms *model.JCShms, janCode string) model.ProductMasterInput {
	// ▼▼▼【ここから修正】薬価を単価に変換するロジックを修正 ▼▼▼
	// 「現単位薬価(JC049) * 最小薬価換算係数(JC124)」でYJ単位あたりの単価を算出
	var unitNhiPrice float64
	// 係数が0より大きい場合は乗算する
	if jcshms.JC124 > 0 {
		unitNhiPrice = jcshms.JC049 * jcshms.JC124
	} else {
		// 係数が0または未設定の場合は、現単位薬価をそのまま使用する
		unitNhiPrice = jcshms.JC049
	}
	// ▲▲▲【修正ここまで】▲▲▲

	return model.ProductMasterInput{
		ProductCode:         janCode,
		YjCode:              jcshms.JC009,
		Gs1Code:             jcshms.JC122,
		ProductName:         strings.TrimSpace(jcshms.JC018),
		KanaName:            strings.TrimSpace(jcshms.JC022),
		MakerName:           strings.TrimSpace(jcshms.JC030),
		Specification:       strings.TrimSpace(jcshms.JC020),
		UsageClassification: strings.TrimSpace(jcshms.JC013),
		PackageForm:         strings.TrimSpace(jcshms.JC037),
		YjUnitName:          strings.TrimSpace(jcshms.JC039),
		YjPackUnitQty:       jcshms.JC044,
		JanPackInnerQty:     jcshms.JA006.Float64,
		JanUnitCode:         parseInt(jcshms.JA007.String),
		JanPackUnitQty:      jcshms.JA008.Float64,
		Origin:              "JCSHMS",
		NhiPrice:            unitNhiPrice, // 修正した単価をセット
		FlagPoison:          jcshms.JC061,
		FlagDeleterious:     jcshms.JC062,
		FlagNarcotic:        jcshms.JC063,
		FlagPsychotropic:    jcshms.JC064,
		FlagStimulant:       jcshms.JC065,
		FlagStimulantRaw:    jcshms.JC066,
		IsOrderStopped:      0,
	}
}

func parseInt(s string) int {
	i, _ := strconv.Atoi(strings.TrimSpace(s))
	return i
}


----- C:\Users\wasab\OneDrive\デスクトップ\WASABI\mappers\mappers.go -----
package mappers

import (
	"database/sql"
	"strconv"
	"wasabi/model"
	"wasabi/units"
)

// MapProductMasterToTransaction は、ProductMaster構造体の情報からTransactionRecord構造体へ必要なデータをコピーします。
func MapProductMasterToTransaction(ar *model.TransactionRecord, master *model.ProductMaster) {
	// 取引記録に単価が設定されていない場合、マスターの薬価をデフォルト値として使用します。
	if ar.UnitPrice == 0 {
		ar.UnitPrice = master.NhiPrice
	}

	// product_master から transaction_records へ共通して存在する情報をコピーします。
	ar.JanCode = master.ProductCode
	ar.YjCode = master.YjCode
	// WASABIではproduct_nameに規格が含まれることが期待されるため、tkrのロジックを応用します。
	if master.Specification != "" {
		ar.ProductName = master.ProductName + " " + master.Specification
	} else {
		ar.ProductName = master.ProductName
	}
	ar.KanaName = master.KanaName
	ar.UsageClassification = master.UsageClassification
	ar.PackageForm = master.PackageForm
	ar.MakerName = master.MakerName
	ar.JanPackInnerQty = master.JanPackInnerQty
	ar.JanPackUnitQty = master.JanPackUnitQty
	ar.YjPackUnitQty = master.YjPackUnitQty
	ar.PurchasePrice = master.PurchasePrice
	ar.SupplierWholesale = master.SupplierWholesale
	ar.FlagPoison = master.FlagPoison
	ar.FlagDeleterious = master.FlagDeleterious
	ar.FlagNarcotic = master.FlagNarcotic
	ar.FlagPsychotropic = master.FlagPsychotropic
	ar.FlagStimulant = master.FlagStimulant
	ar.FlagStimulantRaw = master.FlagStimulantRaw

	// 単位名の解決ロジック (tkrのロジックを流用)
	ar.YjUnitName = units.ResolveName(master.YjUnitName)
	ar.JanUnitCode = strconv.Itoa(master.JanUnitCode)
	if master.JanUnitCode == 0 {
		ar.JanUnitName = ar.YjUnitName
	} else {
		ar.JanUnitName = units.ResolveName(ar.JanUnitCode)
	}

	// 包装仕様文字列の生成ロジック (tkrのロジックを流用)
	// この処理のために、一時的にJCShms構造体の形式にデータを当てはめます。
	tempJcshms := model.JCShms{
		JC037: master.PackageForm,
		JC039: master.YjUnitName,
		JC044: master.YjPackUnitQty,
		JA006: sql.NullFloat64{Float64: master.JanPackInnerQty, Valid: true},
		JA008: sql.NullFloat64{Float64: master.JanPackUnitQty, Valid: true},
		JA007: sql.NullString{String: strconv.Itoa(master.JanUnitCode), Valid: true},
	}
	ar.PackageSpec = units.FormatPackageSpec(&tempJcshms)
}


----- C:\Users\wasab\OneDrive\デスクトップ\WASABI\mappers\view.go -----
// C:\Users\wasab\OneDrive\デスクトップ\WASABI\mappers\view.go

package mappers

import (
	"database/sql"
	"fmt"
	"wasabi/model"
	"wasabi/units"
)

// ToProductMasterView は、*model.ProductMaster を画面表示用の model.ProductMasterView に変換します。
// 包装仕様文字列の生成など、表示に必要な計算処理を集約します。
func ToProductMasterView(master *model.ProductMaster) model.ProductMasterView {
	if master == nil {
		return model.ProductMasterView{}
	}

	// 包装仕様の文字列を生成するために一時的な構造体にデータを詰め替える
	tempJcshms := model.JCShms{
		JC037: master.PackageForm,
		JC039: master.YjUnitName,
		JC044: master.YjPackUnitQty,
		JA006: sql.NullFloat64{Float64: master.JanPackInnerQty, Valid: true},
		JA008: sql.NullFloat64{Float64: master.JanPackUnitQty, Valid: true},
		JA007: sql.NullString{String: fmt.Sprintf("%d", master.JanUnitCode), Valid: true},
	}

	// JAN単位名を解決する
	var janUnitName string
	if master.JanUnitCode == 0 {
		janUnitName = master.YjUnitName
	} else {
		janUnitName = units.ResolveName(fmt.Sprintf("%d", master.JanUnitCode))
	}

	return model.ProductMasterView{
		ProductMaster:        *master,
		FormattedPackageSpec: units.FormatPackageSpec(&tempJcshms),
		JanUnitName:          janUnitName,
	}
}


----- C:\Users\wasab\OneDrive\デスクトップ\WASABI\masteredit\handler.go -----
// C:\Users\wasab\OneDrive\デスクトップ\WASABI\masteredit\handler.go (全体)
package masteredit

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"strings"
	"wasabi/db"
	"wasabi/mappers"
	"wasabi/model"
)

func GetEditableMastersHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		masters, err := db.GetAllProductMasters(conn)
		if err != nil {
			http.Error(w, "Failed to get editable masters", http.StatusInternalServerError)
			return
		}
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(masters)
	}
}
func UpdateMasterHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		if r.Method != http.MethodPost {
			http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
			return
		}
		var input model.ProductMasterInput
		if err := json.NewDecoder(r.Body).Decode(&input); err != nil {
			http.Error(w, "Invalid request body", http.StatusBadRequest)
			return
		}
		if input.ProductCode == "" {
			http.Error(w, "Product Code (JAN) cannot be empty.", http.StatusBadRequest)
			return
		}
		tx, err := conn.Begin()
		if err != nil {
			http.Error(w, "Failed to start transaction", http.StatusInternalServerError)
			return
		}
		defer tx.Rollback()
		if err := db.UpsertProductMasterInTx(tx, input); err != nil {
			http.Error(w, "Failed to upsert product master", http.StatusInternalServerError)
			return
		}
		if err := tx.Commit(); err != nil {
			http.Error(w, "Failed to commit transaction", http.StatusInternalServerError)
			return
		}
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]string{"message": "Saved successfully."})
	}
}

type CreateProvisionalMasterRequest struct {
	Gs1Code     string `json:"gs1Code"`
	ProductCode string `json:"productCode"` // 13-digit JAN
}

func CreateProvisionalMasterHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var req CreateProvisionalMasterRequest
		if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
			http.Error(w, "Invalid request body", http.StatusBadRequest)
			return
		}
		if req.Gs1Code == "" || req.ProductCode == "" {
			http.Error(w, "gs1Code and productCode are required", http.StatusBadRequest)
			return
		}
		tx, err := conn.Begin()
		if err != nil {
			http.Error(w, "Failed to start transaction", http.StatusInternalServerError)
			return
		}
		defer tx.Rollback()
		var jcshmsRecord *model.JCShms
		var foundJanCode string
		jcshmsRecord, foundJanCode, err = db.GetJcshmsRecordByGS1(tx, req.Gs1Code)
		if err != nil && err != sql.ErrNoRows {
			http.Error(w, "Failed to search JCSHMS master by GS1: "+err.Error(), http.StatusInternalServerError)
			return
		}
		if jcshmsRecord == nil {
			jcshmsRecord, err = db.GetJcshmsRecordByJan(tx, req.ProductCode)
			if err != nil && err != sql.ErrNoRows {
				http.Error(w, "Failed to search JCSHMS master by JAN: "+err.Error(), http.StatusInternalServerError)
				return
			}
			if jcshmsRecord != nil {
				foundJanCode = req.ProductCode
			}
		}
		var yjCodeToReturn string
		if jcshmsRecord != nil {
			input := mappers.JcshmsToProductMasterInput(jcshmsRecord, foundJanCode)
			input.Gs1Code = req.Gs1Code
			if err := db.UpsertProductMasterInTx(tx, input); err != nil {
				http.Error(w, "Failed to create master from JCSHMS: "+err.Error(), http.StatusInternalServerError)
				return
			}
			yjCodeToReturn = input.YjCode
		} else {
			newYjCode, err := db.NextSequenceInTx(tx, "MA2Y", "MA2Y", 8)
			if err != nil {
				http.Error(w, "Failed to generate new YJ code", http.StatusInternalServerError)
				return
			}
			provisionalInput := model.ProductMasterInput{
				ProductCode: req.ProductCode,
				Gs1Code:     req.Gs1Code,
				YjCode:      newYjCode,
				ProductName: fmt.Sprintf("(JCSHMS未登録 %s)", req.Gs1Code),
				Origin:      "PROVISIONAL",
			}
			if err := db.UpsertProductMasterInTx(tx, provisionalInput); err != nil {
				http.Error(w, "Failed to create provisional master", http.StatusInternalServerError)
				return
			}
			yjCodeToReturn = newYjCode
		}
		if err := tx.Commit(); err != nil {
			http.Error(w, "Failed to commit transaction", http.StatusInternalServerError)
			return
		}
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]string{"yjCode": yjCodeToReturn})
	}
}

type SetOrderStoppedRequest struct {
	ProductCode string `json:"productCode"`
	Status      int    `json:"status"` // 0: 発注可, 1: 発注不可
}

func SetOrderStoppedHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var req SetOrderStoppedRequest
		if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
			http.Error(w, "Invalid request body", http.StatusBadRequest)
			return
		}
		if req.ProductCode == "" {
			http.Error(w, "productCode is required", http.StatusBadRequest)
			return
		}
		tx, err := conn.Begin()
		if err != nil {
			http.Error(w, "Failed to start transaction", http.StatusInternalServerError)
			return
		}
		defer tx.Rollback()
		master, err := db.GetProductMasterByCode(tx, req.ProductCode)
		if err != nil {
			http.Error(w, "Failed to get product master: "+err.Error(), http.StatusInternalServerError)
			return
		}
		if master == nil {
			http.Error(w, "Product not found", http.StatusNotFound)
			return
		}
		master.IsOrderStopped = req.Status
		input := model.ProductMasterInput{
			ProductCode:         master.ProductCode,
			YjCode:              master.YjCode,
			Gs1Code:             master.Gs1Code,
			ProductName:         master.ProductName,
			Specification:       master.Specification,
			KanaName:            master.KanaName,
			MakerName:           master.MakerName,
			UsageClassification: master.UsageClassification,
			PackageForm:         master.PackageForm,
			YjUnitName:          master.YjUnitName,
			YjPackUnitQty:       master.YjPackUnitQty,
			JanPackInnerQty:     master.JanPackInnerQty,
			JanUnitCode:         master.JanUnitCode,
			JanPackUnitQty:      master.JanPackUnitQty,
			Origin:              master.Origin,
			NhiPrice:            master.NhiPrice,
			PurchasePrice:       master.PurchasePrice,
			FlagPoison:          master.FlagPoison,
			FlagDeleterious:     master.FlagDeleterious,
			FlagNarcotic:        master.FlagNarcotic,
			FlagPsychotropic:    master.FlagPsychotropic,
			FlagStimulant:       master.FlagStimulant,
			FlagStimulantRaw:    master.FlagStimulantRaw,
			IsOrderStopped:      master.IsOrderStopped,
			SupplierWholesale:   master.SupplierWholesale,
			GroupCode:           master.GroupCode,
			ShelfNumber:         master.ShelfNumber,
			Category:            master.Category,
			UserNotes:           master.UserNotes,
		}
		if err := db.UpsertProductMasterInTx(tx, input); err != nil {
			http.Error(w, "Failed to update product master", http.StatusInternalServerError)
			return
		}
		if err := tx.Commit(); err != nil {
			http.Error(w, "Failed to commit transaction", http.StatusInternalServerError)
			return
		}
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]string{"message": "更新しました。"})
	}
}

type BulkUpdateShelfNumbersRequest struct {
	ShelfNumber string   `json:"shelfNumber"`
	Gs1Codes    []string `json:"gs1Codes"`
}

func BulkUpdateShelfNumbersHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var req BulkUpdateShelfNumbersRequest
		if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
			http.Error(w, "Invalid request body: "+err.Error(), http.StatusBadRequest)
			return
		}

		if req.ShelfNumber == "" || len(req.Gs1Codes) == 0 {
			http.Error(w, "shelfNumber and gs1Codes are required", http.StatusBadRequest)
			return
		}

		tx, err := conn.Begin()
		if err != nil {
			http.Error(w, "Failed to start transaction: "+err.Error(), http.StatusInternalServerError)
			return
		}
		defer tx.Rollback()

		stmt, err := tx.Prepare("UPDATE product_master SET shelf_number = ? WHERE gs1_code = ?")
		if err != nil {
			http.Error(w, "Failed to prepare update statement: "+err.Error(), http.StatusInternalServerError)
			return
		}
		defer stmt.Close()

		var updatedCount int
		var notFoundCodes []string

		for _, gs1Code := range req.Gs1Codes {
			cleanGs1 := strings.TrimSpace(strings.TrimPrefix(gs1Code, "(01)"))

			res, err := stmt.Exec(req.ShelfNumber, cleanGs1)
			if err != nil {
				log.Printf("Failed to update shelf number for gs1_code %s: %v", cleanGs1, err)
				continue
			}

			rowsAffected, err := res.RowsAffected()
			if err != nil {
				log.Printf("Failed to get affected rows for gs1_code %s: %v", cleanGs1, err)
				continue
			}

			if rowsAffected > 0 {
				updatedCount++
			} else {
				notFoundCodes = append(notFoundCodes, gs1Code)
			}
		}

		if err := tx.Commit(); err != nil {
			http.Error(w, "Failed to commit transaction: "+err.Error(), http.StatusInternalServerError)
			return
		}

		message := fmt.Sprintf("%d件の棚番を更新しました。", updatedCount)
		if len(notFoundCodes) > 0 {
			message += fmt.Sprintf(" %d件は見つかりませんでした: %s", len(notFoundCodes), strings.Join(notFoundCodes, ", "))
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]string{"message": message})
	}
}

// ▼▼▼【ここから修正】▼▼▼
type CreateFromJcshmsRequest struct {
	ProductCode string `json:"productCode"` // JANコード
}

// CreateFromJcshmsHandler はJANコードを元にJCSHMSからマスターを作成します。
func CreateFromJcshmsHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var req CreateFromJcshmsRequest
		if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
			http.Error(w, "Invalid request body", http.StatusBadRequest)
			return
		}
		if req.ProductCode == "" {
			http.Error(w, "productCode is required", http.StatusBadRequest)
			return
		}

		tx, err := conn.Begin()
		if err != nil {
			http.Error(w, "Failed to start transaction", http.StatusInternalServerError)
			return
		}
		defer tx.Rollback()

		// JCSHMSマスターを検索
		jcshmsRecord, err := db.GetJcshmsRecordByJan(tx, req.ProductCode)
		if err != nil {
			if err == sql.ErrNoRows {
				http.Error(w, "JCSHMS master not found for this product code", http.StatusNotFound)
			} else {
				http.Error(w, "Failed to search JCSHMS master: "+err.Error(), http.StatusInternalServerError)
			}
			return
		}

		// JCSHMSレコードを製品マスターの入力形式に変換
		input := mappers.JcshmsToProductMasterInput(jcshmsRecord, req.ProductCode)

		// YJコードが存在しない場合は自動採番
		if input.YjCode == "" {
			newYj, err := db.NextSequenceInTx(tx, "MA2Y", "MA2Y", 8)
			if err != nil {
				http.Error(w, "Failed to get next sequence for YJ code: "+err.Error(), http.StatusInternalServerError)
				return
			}
			input.YjCode = newYj
		}

		// データベースにUPSERT
		if err := db.UpsertProductMasterInTx(tx, input); err != nil {
			http.Error(w, "Failed to create master from JCSHMS: "+err.Error(), http.StatusInternalServerError)
			return
		}

		// 登録したマスター情報を取得
		newMaster, err := db.GetProductMasterByCode(tx, req.ProductCode)
		if err != nil || newMaster == nil {
			http.Error(w, "Failed to retrieve newly created master: "+err.Error(), http.StatusInternalServerError)
			return
		}

		if err := tx.Commit(); err != nil {
			http.Error(w, "Failed to commit transaction", http.StatusInternalServerError)
			return
		}

		// 共通関数を使って画面表示用のViewモデルに変換して返す
		masterView := mappers.ToProductMasterView(newMaster)

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(masterView)
	}
}

// ▲▲▲【修正ここまで】▲▲▲


----- C:\Users\wasab\OneDrive\デスクトップ\WASABI\mastermanager\mastermanager.go -----
// C:\Users\wasab\OneDrive\デスクトップ\WASABI\mastermanager\mastermanager.go

package mastermanager

import (
	"database/sql"
	"fmt"
	"strconv"
	"strings"
	"wasabi/db"
	"wasabi/model"
)

// FindOrCreate は、マスターの特定と作成に関する全てのロジックを集約した関数です。
func FindOrCreate(
	tx *sql.Tx,
	janCode string,
	productName string,
	mastersMap map[string]*model.ProductMaster,
	jcshmsMap map[string]*model.JCShms,
) (*model.ProductMaster, error) {

	key := janCode
	isSyntheticKey := false
	if key == "" || key == "0000000000000" {
		key = fmt.Sprintf("9999999999999%s", productName)
		isSyntheticKey = true
	}

	// 1. まずメモリ上のキャッシュ（マップ）を確認
	if master, ok := mastersMap[key]; ok {
		return master, nil
	}

	// 2. 次にデータベースを検索 (tkrのロジック)
	existingMaster, err := db.GetProductMasterByCode(tx, key)
	if err != nil {
		return nil, fmt.Errorf("failed to check for existing master %s: %w", key, err)
	}
	// もしDBに存在すれば、それを使用する
	if existingMaster != nil {
		mastersMap[key] = existingMaster // メモリマップにも追加して次回以降の検索を高速化
		return existingMaster, nil
	}

	// 3. JCSHMSマスターから作成を試みる
	if !isSyntheticKey {
		if jcshms, ok := jcshmsMap[janCode]; ok && jcshms.JC018 != "" {
			// ヘルパー関数を呼び出して、新しいDB構造に基づいたデータを作成
			input := createMasterInputFromJcshms(janCode, jcshms)

			// ▼▼▼【ここから修正】YJコードがない場合に自動採番するロジックを追加 ▼▼▼
			if input.YjCode == "" {
				newYj, err := db.NextSequenceInTx(tx, "MA2Y", "MA2Y", 8)
				if err != nil {
					return nil, fmt.Errorf("failed to get next sequence for JCSHMS master with no YJ code: %w", err)
				}
				input.YjCode = newYj
			}
			// ▲▲▲【修正ここまで】▲▲▲

			if err := db.UpsertProductMasterInTx(tx, input); err != nil {
				return nil, fmt.Errorf("failed to create master from jcshms: %w", err)
			}
			newMaster := createMasterModelFromInput(input)
			mastersMap[key] = &newMaster
			return &newMaster, nil
		}
	}

	// 4. メモリにもDBにもJCSHMSにも存在しない場合、新しい仮マスターを作成
	newYj, err := db.NextSequenceInTx(tx, "MA2Y", "MA2Y", 8)
	if err != nil {
		return nil, fmt.Errorf("failed to get next sequence for provisional master: %w", err)
	}

	provisionalInput := model.ProductMasterInput{
		ProductCode: key,
		YjCode:      newYj,
		ProductName: productName, // DATファイルから読み取った名前を基本製品名として設定
		Origin:      "PROVISIONAL",
	}

	if err := db.UpsertProductMasterInTx(tx, provisionalInput); err != nil {
		return nil, fmt.Errorf("failed to create provisional master: %w", err)
	}

	newMaster := createMasterModelFromInput(provisionalInput)
	mastersMap[key] = &newMaster
	return &newMaster, nil
}

// createMasterInputFromJcshms はJCSHMSのデータからDB登録用のProductMasterInputを作成します。
func createMasterInputFromJcshms(jan string, jcshms *model.JCShms) model.ProductMasterInput {
	var nhiPrice float64
	if jcshms.JC044 > 0 {
		nhiPrice = jcshms.JC050 / jcshms.JC044
	}
	janUnitCodeVal, _ := strconv.Atoi(jcshms.JA007.String)

	input := model.ProductMasterInput{
		ProductCode:   jan,
		YjCode:        jcshms.JC009,
		ProductName:   strings.TrimSpace(jcshms.JC018), // 基本製品名 (JC018)
		Specification: strings.TrimSpace(jcshms.JC020), // 規格 (JC020)
		// ▼▼▼【ここが修正箇所】▼▼▼
		Gs1Code: jcshms.JC122, // GS1コード (JC122)
		// ▲▲▲【修正ここまで】▲▲▲
		Origin:              "JCSHMS",
		KanaName:            jcshms.JC022,
		MakerName:           jcshms.JC030,
		UsageClassification: jcshms.JC013,
		PackageForm:         jcshms.JC037,
		YjUnitName:          jcshms.JC039,
		YjPackUnitQty:       jcshms.JC044,
		NhiPrice:            nhiPrice,
		FlagPoison:          jcshms.JC061,
		FlagDeleterious:     jcshms.JC062,
		FlagNarcotic:        jcshms.JC063,
		FlagPsychotropic:    jcshms.JC064,
		FlagStimulant:       jcshms.JC065,
		FlagStimulantRaw:    jcshms.JC066,
		JanPackInnerQty:     jcshms.JA006.Float64,
		JanUnitCode:         janUnitCodeVal,
		JanPackUnitQty:      jcshms.JA008.Float64,
	}
	return input
}

// createMasterModelFromInput はDB登録用のInputからメモリマップ格納用のProductMasterを作成します。
func createMasterModelFromInput(input model.ProductMasterInput) model.ProductMaster {
	// ▼▼▼【ここから修正】S1016警告に対応 (struct literal -> type conversion) ▼▼▼
	return model.ProductMaster(input)
	// ▲▲▲【修正ここまで】▲▲▲
}


----- C:\Users\wasab\OneDrive\デスクトップ\WASABI\medrec\handler.go -----
package medrec

import (
	"context"
	"database/sql"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"os"
	"path/filepath"
	"strings"
	"time"
	"wasabi/config"
	"wasabi/dat"

	"github.com/chromedp/cdproto/browser"
	"github.com/chromedp/chromedp"
)

func writeJsonError(w http.ResponseWriter, message string, code int) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(code)
	json.NewEncoder(w).Encode(map[string]string{"message": message})
}

func findChromePath() string {
	paths := []string{
		filepath.Join(os.Getenv("ProgramFiles"), "Google", "Chrome", "Application", "chrome.exe"),
		filepath.Join(os.Getenv("ProgramFiles(x86)"), "Google", "Chrome", "Application", "chrome.exe"),
	}
	for _, path := range paths {
		if _, err := os.Stat(path); err == nil {
			return path
		}
	}
	return ""
}

func DownloadHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		cfg, err := config.LoadConfig()
		if err != nil {
			writeJsonError(w, "設定ファイルの読み込みに失敗しました: "+err.Error(), http.StatusInternalServerError)
			return
		}

		if cfg.EmednetUserID == "" || cfg.EmednetPassword == "" {
			writeJsonError(w, "IDまたはパスワードが設定されていません。", http.StatusBadRequest)
			return
		}

		tempDir, err := os.MkdirTemp("", "chromedp-medrec-")
		if err != nil {
			writeJsonError(w, "一時プロファイルディレクトリの作成に失敗: "+err.Error(), http.StatusInternalServerError)
			return
		}
		defer os.RemoveAll(tempDir)

		opts := append(chromedp.DefaultExecAllocatorOptions[:],
			chromedp.Flag("headless", false),
			chromedp.Flag("disable-gpu", true),
			chromedp.UserDataDir(tempDir),
		)

		if execPath := findChromePath(); execPath != "" {
			opts = append(opts, chromedp.ExecPath(execPath))
		}

		allocCtx, cancel := chromedp.NewExecAllocator(context.Background(), opts...)
		defer cancel()

		ctx, cancel := chromedp.NewContext(allocCtx, chromedp.WithLogf(log.Printf))
		defer cancel()

		downloadDir, err := filepath.Abs(filepath.Join(".", "download", "DAT"))
		if err != nil {
			writeJsonError(w, "ダウンロードディレクトリの絶対パス取得に失敗: "+err.Error(), http.StatusInternalServerError)
			return
		}
		if err := os.MkdirAll(downloadDir, 0755); err != nil {
			writeJsonError(w, "ダウンロードディレクトリの作成に失敗: "+err.Error(), http.StatusInternalServerError)
			return
		}

		filesBefore, err := os.ReadDir(downloadDir)
		if err != nil {
			writeJsonError(w, "ダウンロードディレクトリの読み取りに失敗: "+err.Error(), http.StatusInternalServerError)
			return
		}
		filesBeforeMap := make(map[string]bool)
		for _, f := range filesBefore {
			filesBeforeMap[f.Name()] = true
		}

		var initialLatestTimestamp string
		err = chromedp.Run(ctx,
			// ▼▼▼【ここを修正】 page. -> browser. に変更 ▼▼▼
			browser.SetDownloadBehavior(browser.SetDownloadBehaviorBehaviorAllow).WithDownloadPath(downloadDir),
			// ▲▲▲【修正ここまで】▲▲▲
			chromedp.Navigate(`https://www.e-mednet.jp/`),
			chromedp.WaitVisible(`input[name="userid"]`),
			chromedp.SendKeys(`input[name="userid"]`, cfg.EmednetUserID),
			chromedp.SendKeys(`input[name="userpsw"]`, cfg.EmednetPassword),
			chromedp.Click(`input[type="submit"][value="ログイン"]`),
			chromedp.WaitVisible(`//a[contains(@href, "busi_id=11")]`),
			chromedp.Click(`//a[contains(@href, "busi_id=11")]`),
			chromedp.WaitVisible(`//a[contains(text(), "納品受信(JAN)")]`),
			chromedp.Click(`//a[contains(text(), "納品受信(JAN)")]`),
			chromedp.WaitReady(`input[name="unreceive_button"]`),
			chromedp.Text(`table.result-list-table tbody tr:first-child td.col-transceiving-date`, &initialLatestTimestamp, chromedp.AtLeast(0)),
			chromedp.Click(`input[name="unreceive_button"]`),
		)
		if err != nil {
			writeJsonError(w, "自動操作に失敗しました: "+err.Error(), http.StatusInternalServerError)
			return
		}

		var newFilePath string
		var downloadSuccess, noDataFound bool
		timeout := time.After(30 * time.Second)
	CheckLoop:
		for {
			select {
			case <-timeout:
				writeJsonError(w, "30秒以内にサイトの反応が確認できませんでした。", http.StatusRequestTimeout)
				return
			case <-time.After(1 * time.Second):
				var newLatestTimestamp, resultText string

				checkCtx, cancelCheck := context.WithTimeout(ctx, 4*time.Second)
				_ = chromedp.Run(checkCtx,
					chromedp.Text(`table.result-list-table tbody tr:first-child td.col-transceiving-date`, &newLatestTimestamp, chromedp.AtLeast(0)),
				)
				cancelCheck()

				if strings.TrimSpace(newLatestTimestamp) != strings.TrimSpace(initialLatestTimestamp) {
					checkCtx, cancelCheck = context.WithTimeout(ctx, 4*time.Second)
					_ = chromedp.Run(checkCtx,
						chromedp.Text(`table.result-list-table tbody tr:first-child td.col-result`, &resultText, chromedp.AtLeast(0)),
					)
					cancelCheck()

					if strings.TrimSpace(resultText) == "正常完了" {
						downloadSuccess = true
						break CheckLoop
					}
					if strings.TrimSpace(resultText) == "受信データなし" {
						noDataFound = true
						break CheckLoop
					}
				}
			}
		}

		if noDataFound {
			writeJsonError(w, "未受信の納品データはありませんでした。", http.StatusOK)
			return
		}

		if downloadSuccess {
			timeoutFile := time.After(10 * time.Second)
		FileLoop:
			for {
				select {
				case <-timeoutFile:
					writeJsonError(w, "サイトの反応はありましたが、10秒以内にファイルが見つかりませんでした。", http.StatusInternalServerError)
					return
				case <-time.After(500 * time.Millisecond):
					filesAfter, _ := os.ReadDir(downloadDir)
					for _, f := range filesAfter {
						if !filesBeforeMap[f.Name()] && !strings.HasSuffix(f.Name(), ".crdownload") {
							newFilePath = filepath.Join(downloadDir, f.Name())
							break FileLoop
						}
					}
				}
			}
		} else {
			writeJsonError(w, "ダウンロードされたファイルの検知に失敗しました。", http.StatusInternalServerError)
			return
		}

		processedRecords, err := dat.ProcessDatFile(conn, newFilePath)
		if err != nil {
			writeJsonError(w, "ダウンロードしたDATファイルの処理に失敗: "+err.Error(), http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]string{
			"message": fmt.Sprintf("%d件の納品データをダウンロードし登録しました。", len(processedRecords)),
		})
	}
}


----- C:\Users\wasab\OneDrive\デスクトップ\WASABI\model\types.go -----
// C:\Users\wasab\OneDrive\デスクトップ\WASABI\model\types.go
package model

import "database/sql"

// ProductMaster は製品マスターの完全なデータ構造です。(tkrから移植)
type ProductMaster struct {
	ProductCode         string  `json:"productCode"`
	YjCode              string  `json:"yjCode"`
	ProductName         string  `json:"productName"`
	KanaName            string  `json:"kanaName"`
	MakerName           string  `json:"makerName"`
	Gs1Code             string  `json:"gs1Code"`
	PackageForm         string  `json:"packageForm"`
	Specification       string  `json:"specification"`
	UsageClassification string  `json:"usageClassification"`
	YjUnitName          string  `json:"yjUnitName"`
	YjPackUnitQty       float64 `json:"yjPackUnitQty"`
	JanPackInnerQty     float64 `json:"janPackInnerQty"`
	JanUnitCode         int     `json:"janUnitCode"`
	JanPackUnitQty      float64 `json:"janPackUnitQty"`
	Origin              string  `json:"origin"`
	NhiPrice            float64 `json:"nhiPrice"`
	PurchasePrice       float64 `json:"purchasePrice"`
	FlagPoison          int     `json:"flagPoison"`
	FlagDeleterious     int     `json:"flagDeleterious"`
	FlagNarcotic        int     `json:"flagNarcotic"`
	FlagPsychotropic    int     `json:"flagPsychotropic"`
	FlagStimulant       int     `json:"flagStimulant"`
	FlagStimulantRaw    int     `json:"flagStimulantRaw"`
	IsOrderStopped      int     `json:"isOrderStopped"`
	SupplierWholesale   string  `json:"supplierWholesale"`
	GroupCode           string  `json:"groupCode"`
	ShelfNumber         string  `json:"shelfNumber"`
	Category            string  `json:"category"`
	UserNotes           string  `json:"userNotes"`
}

// ProductMasterInput は製品マスターを登録・更新する際の入力データ構造です。(tkrから移植)
type ProductMasterInput struct {
	ProductCode         string  `json:"productCode"`
	YjCode              string  `json:"yjCode"`
	ProductName         string  `json:"productName"`
	KanaName            string  `json:"kanaName"`
	MakerName           string  `json:"makerName"`
	Gs1Code             string  `json:"gs1Code"`
	PackageForm         string  `json:"packageForm"`
	Specification       string  `json:"specification"`
	UsageClassification string  `json:"usageClassification"`
	YjUnitName          string  `json:"yjUnitName"`
	YjPackUnitQty       float64 `json:"yjPackUnitQty"`
	JanPackInnerQty     float64 `json:"janPackInnerQty"`
	JanUnitCode         int     `json:"janUnitCode"`
	JanPackUnitQty      float64 `json:"janPackUnitQty"`
	Origin              string  `json:"origin"`
	NhiPrice            float64 `json:"nhiPrice"`
	PurchasePrice       float64 `json:"purchasePrice"`
	FlagPoison          int     `json:"flagPoison"`
	FlagDeleterious     int     `json:"flagDeleterious"`
	FlagNarcotic        int     `json:"flagNarcotic"`
	FlagPsychotropic    int     `json:"flagPsychotropic"`
	FlagStimulant       int     `json:"flagStimulant"`
	FlagStimulantRaw    int     `json:"flagStimulantRaw"`
	IsOrderStopped      int     `json:"isOrderStopped"`
	SupplierWholesale   string  `json:"supplierWholesale"`
	GroupCode           string  `json:"groupCode"`
	ShelfNumber         string  `json:"shelfNumber"`
	Category            string  `json:"category"`
	UserNotes           string  `json:"userNotes"`
}

// (以下はWASABIに元々あった型定義)
// ▼▼▼【ここから修正】▼▼▼
type JCShms struct {
	JC009 string  // YJコード
	JC013 string  // 使用区分
	JC018 string  // 商品名
	JC020 string  // 規格容量
	JC022 string  // 商品名カナ
	JC030 string  // 販売元名
	JC037 string  // 包装形態
	JC039 string  // 包装単位(単位)
	JC044 float64 // 包装薬価係数 (YJ包装単位薬価数量)
	JC049 float64 // 現単位薬価
	JC050 float64 // 現包装薬価
	JC061 int     // 毒
	JC062 int     // 劇
	JC063 int     // 麻
	JC064 int     // 向
	JC065 int     // 覚
	JC066 int     // 覚原
	JC122 string  // 調剤包装単位コード(GS1)
	JC124 float64 // 最小薬価換算係数
	JA006 sql.NullFloat64
	JA007 sql.NullString
	JA008 sql.NullFloat64
}

// ▲▲▲【修正ここまで】▲▲▲

type ValuationPackageDetail struct {
	ProductCode   string  `json:"productCode"`
	PackageSpec   string  `json:"packageSpec"`
	Stock         float64 `json:"stock"`
	NhiPrice      float64 `json:"nhiPrice"`
	PurchasePrice float64 `json:"purchasePrice"`
}

type TransactionRecord struct {
	ID                  int     `json:"id"`
	TransactionDate     string  `json:"transactionDate"`
	ClientCode          string  `json:"clientCode"`
	ReceiptNumber       string  `json:"receiptNumber"`
	LineNumber          string  `json:"lineNumber"`
	Flag                int     `json:"flag"`
	JanCode             string  `json:"janCode"`
	YjCode              string  `json:"yjCode"`
	ProductName         string  `json:"productName"`
	KanaName            string  `json:"kanaName"`
	UsageClassification string  `json:"usageClassification"`
	PackageForm         string  `json:"packageForm"`
	PackageSpec         string  `json:"packageSpec"`
	MakerName           string  `json:"makerName"`
	DatQuantity         float64 `json:"datQuantity"`
	JanPackInnerQty     float64 `json:"janPackInnerQty"`
	JanQuantity         float64 `json:"janQuantity"`
	JanPackUnitQty      float64 `json:"janPackUnitQty"`
	JanUnitName         string  `json:"janUnitName"`
	JanUnitCode         string  `json:"janUnitCode"`
	YjQuantity          float64 `json:"yjQuantity"`
	YjPackUnitQty       float64 `json:"yjPackUnitQty"`
	YjUnitName          string  `json:"yjUnitName"`
	UnitPrice           float64 `json:"unitPrice"`
	PurchasePrice       float64 `json:"purchasePrice"`
	SupplierWholesale   string  `json:"supplierWholesale"`
	Subtotal            float64 `json:"subtotal"`
	TaxAmount           float64 `json:"taxAmount"`
	TaxRate             float64 `json:"taxRate"`
	ExpiryDate          string  `json:"expiryDate"`
	LotNumber           string  `json:"lotNumber"`
	FlagPoison          int     `json:"flagPoison"`
	FlagDeleterious     int     `json:"flagDeleterious"`
	FlagNarcotic        int     `json:"flagNarcotic"`
	FlagPsychotropic    int     `json:"flagPsychotropic"`
	FlagStimulant       int     `json:"flagStimulant"`
	FlagStimulantRaw    int     `json:"flagStimulantRaw"`
	ProcessFlagMA       string  `json:"processFlagMA"`
}

func (t *TransactionRecord) SignedYjQty() float64 {
	switch t.Flag {
	case 1, 4, 11:
		return t.YjQuantity
	case 2, 3, 5, 12:
		return -t.YjQuantity
	default:
		return 0
	}
}

func (t *TransactionRecord) ToProductMaster() *ProductMaster {
	return &ProductMaster{
		ProductCode:         t.JanCode,
		YjCode:              t.YjCode,
		ProductName:         t.ProductName,
		KanaName:            t.KanaName,
		UsageClassification: t.UsageClassification,
		PackageForm:         t.PackageForm,
		JanPackInnerQty:     t.JanPackInnerQty,
		YjUnitName:          t.YjUnitName,
	}
}

type ProductMasterView struct {
	ProductMaster
	FormattedPackageSpec string `json:"formattedPackageSpec"`
	JanUnitName          string `json:"janUnitName"`
	IsAdopted            bool   `json:"isAdopted,omitempty"`
}

type InventoryProductView struct {
	ProductMaster
	LastInventoryDate string `json:"lastInventoryDate"`
}

type Client struct {
	Code string `json:"code"`
	Name string `json:"name"`
}

type AggregationFilters struct {
	StartDate    string
	EndDate      string
	KanaName     string
	DrugTypes    []string
	DosageForm   string
	Coefficient  float64
	YjCode       string
	MovementOnly bool
	ShelfNumber  string
}

type ValuationFilters struct {
	Date                string
	KanaName            string
	UsageClassification string
}

type StockLedgerYJGroup struct {
	YjCode                string                    `json:"yjCode"`
	ProductName           string                    `json:"productName"`
	YjUnitName            string                    `json:"yjUnitName"`
	PackageLedgers        []StockLedgerPackageGroup `json:"packageLedgers"`
	StartingBalance       interface{}               `json:"startingBalance"`
	NetChange             float64                   `json:"netChange"`
	EndingBalance         interface{}               `json:"endingBalance"`
	TotalReorderPoint     float64                   `json:"totalReorderPoint"`
	IsReorderNeeded       bool                      `json:"isReorderNeeded"`
	TotalBaseReorderPoint float64                   `json:"totalBaseReorderPoint"`
	TotalPrecompounded    float64                   `json:"totalPrecompounded"`
}

type StockLedgerPackageGroup struct {
	PackageKey             string              `json:"packageKey"`
	JanUnitName            string              `json:"janUnitName"`
	StartingBalance        interface{}         `json:"startingBalance"`
	Transactions           []LedgerTransaction `json:"transactions"`
	NetChange              float64             `json:"netChange"`
	EndingBalance          interface{}         `json:"endingBalance"`
	EffectiveEndingBalance float64             `json:"effectiveEndingBalance"`
	MaxUsage               float64             `json:"maxUsage"`
	ReorderPoint           float64             `json:"reorderPoint"`
	IsReorderNeeded        bool                `json:"isReorderNeeded"`
	Masters                []*ProductMaster    `json:"masters"`
	BaseReorderPoint       float64             `json:"baseReorderPoint"`
	PrecompoundedTotal     float64             `json:"precompoundedTotal"`
	DeliveryHistory        []TransactionRecord `json:"deliveryHistory,omitempty"`
}

type LedgerTransaction struct {
	TransactionRecord
	RunningBalance float64 `json:"runningBalance"`
}

type UnifiedInputRecord struct {
	Date            string  `json:"date"`
	JanCode         string  `json:"janCode"`
	YjCode          string  `json:"yjCode"`
	ProductName     string  `json:"productName"`
	DatQuantity     float64 `json:"datQuantity"`
	JanPackInnerQty float64 `json:"janPackInnerQty"`
	JanQuantity     float64 `json:"janQuantity"`
	YjQuantity      float64 `json:"yjQuantity"`
	YjUnitName      string  `json:"yjUnitName"`
	ClientCode      string  `json:"clientCode"`
	ReceiptNumber   string  `json:"receiptNumber"`
	LineNumber      string  `json:"lineNumber"`
	Flag            int     `json:"flag"`
	UnitPrice       float64 `json:"unitPrice"`
	Subtotal        float64 `json:"subtotal"`
	ExpiryDate      string  `json:"expiryDate"`
	LotNumber       string  `json:"lotNumber"`
}

type DeadStockGroup struct {
	YjCode        string                  `json:"yjCode"`
	ProductName   string                  `json:"productName"`
	TotalStock    float64                 `json:"totalStock"`
	PackageGroups []DeadStockPackageGroup `json:"packageGroups"`
}

type DeadStockPackageGroup struct {
	PackageKey         string              `json:"packageKey"`
	TotalStock         float64             `json:"totalStock"`
	Products           []DeadStockProduct  `json:"products"`
	RecentTransactions []TransactionRecord `json:"recentTransactions,omitempty"`
}

type DeadStockProduct struct {
	ProductMaster
	CurrentStock  float64           `json:"currentStock"`
	SavedRecords  []DeadStockRecord `json:"savedRecords"`
	LastUsageDate string            `json:"lastUsageDate"`
}

type DeadStockRecord struct {
	ID               int     `json:"id"`
	ProductCode      string  `json:"productCode"`
	YjCode           string  `json:"yjCode"`
	PackageForm      string  `json:"packageForm"`
	JanPackInnerQty  float64 `json:"janPackInnerQty"`
	YjUnitName       string  `json:"yjUnitName"`
	StockQuantityJan float64 `json:"stockQuantityJan"`
	ExpiryDate       string  `json:"expiryDate"`
	LotNumber        string  `json:"lotNumber"`
}

type DeadStockFilters struct {
	StartDate        string
	EndDate          string
	ExcludeZeroStock bool
	Coefficient      float64
	KanaName         string
	DosageForm       string
	ShelfNumber      string
}

type PreCompoundingRecord struct {
	ID            int     `json:"id"`
	PatientNumber string  `json:"patientNumber"`
	ProductCode   string  `json:"productCode"`
	Quantity      float64 `json:"quantity"`
	CreatedAt     string  `json:"createdAt"`
}

type Wholesaler struct {
	Code string `json:"code"`
	Name string `json:"name"`
}

type Backorder struct {
	ID                int            `json:"id"`
	OrderDate         string         `json:"orderDate"`
	YjCode            string         `json:"yjCode"`
	ProductName       string         `json:"productName"`
	PackageForm       string         `json:"packageForm"`
	JanPackInnerQty   float64        `json:"janPackInnerQty"`
	YjUnitName        string         `json:"yjUnitName"`
	OrderQuantity     float64        `json:"orderQuantity"`
	RemainingQuantity float64        `json:"remainingQuantity"`
	WholesalerCode    sql.NullString `json:"wholesalerCode,omitempty"`
	YjPackUnitQty     float64        `json:"yjPackUnitQty"`
	JanPackUnitQty    float64        `json:"janPackUnitQty"`
	JanUnitCode       int            `json:"janUnitCode"`
	// フロントエンドからの発注データ受け取り用フィールド
	YjQuantity float64 `json:"yjQuantity,omitempty"`
}

type PriceUpdate struct {
	ProductCode      string  `json:"productCode"`
	NewPurchasePrice float64 `json:"newPrice"`
	NewSupplier      string  `json:"newWholesaler"`
}

type QuoteData struct {
	ProductMaster
	Quotes map[string]float64 `json:"quotes"`
}

type ValuationDetailRow struct {
	YjCode               string  `json:"yjCode"`
	ProductName          string  `json:"productName"`
	ProductCode          string  `json:"productCode"`
	PackageSpec          string  `json:"packageSpec"`
	Stock                float64 `json:"stock"`
	YjUnitName           string  `json:"yjUnitName"`
	PackageNhiPrice      float64 `json:"packageNhiPrice"`
	PackagePurchasePrice float64 `json:"packagePurchasePrice"`
	TotalNhiValue        float64 `json:"totalNhiValue"`
	TotalPurchaseValue   float64 `json:"totalPurchaseValue"`
	ShowAlert            bool    `json:"showAlert"`
}


----- C:\Users\wasab\OneDrive\デスクトップ\WASABI\orders\handlee.go -----
// C:\Users\wasab\OneDrive\デスクトップ\WASABI\orders\handlee.go
package orders

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"net/http"
	"strconv"
	"time"
	"wasabi/config"
	"wasabi/db"
	"wasabi/model"
	"wasabi/units"
)

type OrderCandidatesResponse struct {
	Candidates  []OrderCandidateYJGroup `json:"candidates"`
	Wholesalers []model.Wholesaler      `json:"wholesalers"`
}

type OrderCandidateYJGroup struct {
	model.StockLedgerYJGroup
	PackageLedgers []OrderCandidatePackageGroup `json:"packageLedgers"`
}

type OrderCandidatePackageGroup struct {
	model.StockLedgerPackageGroup
	Masters            []model.ProductMasterView `json:"masters"`
	ExistingBackorders []model.Backorder         `json:"existingBackorders"`
}

func GenerateOrderCandidatesHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		kanaName := r.URL.Query().Get("kanaName")
		dosageForm := r.URL.Query().Get("dosageForm")
		shelfNumber := r.URL.Query().Get("shelfNumber")
		coefficientStr := r.URL.Query().Get("coefficient")
		coefficient, err := strconv.ParseFloat(coefficientStr, 64)
		if err != nil {
			coefficient = 1.3
		}

		cfg, err := config.LoadConfig()
		if err != nil {
			http.Error(w, "設定ファイルの読み込みに失敗しました: "+err.Error(), http.StatusInternalServerError)
			return
		}

		now := time.Now()
		endDate := "99991231"
		startDate := now.AddDate(0, 0, -cfg.CalculationPeriodDays)

		filters := model.AggregationFilters{
			StartDate:   startDate.Format("20060102"),
			EndDate:     endDate,
			KanaName:    kanaName,
			DosageForm:  dosageForm,
			ShelfNumber: shelfNumber,
			Coefficient: coefficient,
		}

		yjGroups, err := db.GetStockLedger(conn, filters)
		if err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}

		allBackorders, err := db.GetAllBackordersList(conn)
		if err != nil {
			http.Error(w, "Failed to get backorder list for candidates", http.StatusInternalServerError)
			return
		}
		backordersByPackageKey := make(map[string][]model.Backorder)
		for _, bo := range allBackorders {
			key := fmt.Sprintf("%s|%s|%g|%s", bo.YjCode, bo.PackageForm, bo.JanPackInnerQty, bo.YjUnitName)
			backordersByPackageKey[key] = append(backordersByPackageKey[key], bo)
		}

		var candidates []OrderCandidateYJGroup
		for _, group := range yjGroups {
			if group.IsReorderNeeded {
				newYjGroup := OrderCandidateYJGroup{
					StockLedgerYJGroup: group,
					PackageLedgers:     []OrderCandidatePackageGroup{},
				}

				for _, pkg := range group.PackageLedgers {
					newPkgGroup := OrderCandidatePackageGroup{
						StockLedgerPackageGroup: pkg,
						Masters:                 []model.ProductMasterView{},
						ExistingBackorders:      backordersByPackageKey[pkg.PackageKey],
					}
					for _, master := range pkg.Masters {
						tempJcshms := model.JCShms{
							JC037: master.PackageForm,
							JC039: master.YjUnitName,
							JC044: master.YjPackUnitQty,
							JA006: sql.NullFloat64{Float64: master.JanPackInnerQty, Valid: true},
							JA008: sql.NullFloat64{Float64: master.JanPackUnitQty, Valid: true},
							JA007: sql.NullString{String: fmt.Sprintf("%d", master.JanUnitCode), Valid: true},
						}
						formattedSpec := units.FormatPackageSpec(&tempJcshms)

						newPkgGroup.Masters = append(newPkgGroup.Masters, model.ProductMasterView{
							ProductMaster:        *master,
							FormattedPackageSpec: formattedSpec,
						})
					}
					newYjGroup.PackageLedgers = append(newYjGroup.PackageLedgers, newPkgGroup)
				}
				candidates = append(candidates, newYjGroup)
			}
		}

		wholesalers, err := db.GetAllWholesalers(conn)
		if err != nil {
			http.Error(w, "Failed to get wholesalers", http.StatusInternalServerError)
			return
		}

		response := OrderCandidatesResponse{
			Candidates:  candidates,
			Wholesalers: wholesalers,
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(response)
	}
}

func PlaceOrderHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var payload []model.Backorder
		if err := json.NewDecoder(r.Body).Decode(&payload); err != nil {
			http.Error(w, "Invalid request body", http.StatusBadRequest)
			return
		}

		tx, err := conn.Begin()
		if err != nil {
			http.Error(w, "Failed to start transaction", http.StatusInternalServerError)
			return
		}
		defer tx.Rollback()

		today := time.Now().Format("20060102")
		for i := range payload {
			if payload[i].OrderDate == "" {
				payload[i].OrderDate = today
			}
			// ▼▼▼【ここから修正】▼▼▼
			payload[i].OrderQuantity = payload[i].YjQuantity
			payload[i].RemainingQuantity = payload[i].YjQuantity
			// ▲▲▲【修正ここまで】▲▲▲
		}

		if err := db.InsertBackordersInTx(tx, payload); err != nil {
			http.Error(w, "Failed to save backorders", http.StatusInternalServerError)
			return
		}

		if err := tx.Commit(); err != nil {
			http.Error(w, "Failed to commit transaction", http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]string{"message": "発注内容を発注残として登録しました。"})
	}
}


----- C:\Users\wasab\OneDrive\デスクトップ\WASABI\parsers\dat_parser.go -----
// C:\Dev\WASABI\parsers\dat_parser.go
package parsers

import (
	"bufio"
	"io"
	"strconv"
	"strings"
	"wasabi/model"

	"golang.org/x/text/encoding/japanese"
	"golang.org/x/text/transform"
)

// ParseDatは、固定長のDATファイルからレコードを抽出し、UnifiedInputRecordのスライスを返します。
func ParseDat(r io.Reader) ([]model.UnifiedInputRecord, error) {
	scanner := bufio.NewScanner(r)
	var records []model.UnifiedInputRecord
	var currentWholesale string

	for scanner.Scan() {
		line := scanner.Text()
		if len(line) == 0 {
			continue
		}

		switch line[0:1] {
		case "S":
			if len(line) >= 13 {
				currentWholesale = strings.TrimSpace(line[3:13])
			}
		case "D":
			if len(line) < 121 {
				line += strings.Repeat(" ", 121-len(line))
			}

			// 型変換をここで行う
			productNameSJIS := line[38:78]
			utf8Bytes, _, _ := transform.Bytes(japanese.ShiftJIS.NewDecoder(), []byte(productNameSJIS))

			flag, _ := strconv.Atoi(strings.TrimSpace(line[3:4]))
			datqty, _ := strconv.ParseFloat(strings.TrimSpace(line[78:83]), 64)
			unitprice, _ := strconv.ParseFloat(strings.TrimSpace(line[83:92]), 64)
			subtotal, _ := strconv.ParseFloat(strings.TrimSpace(line[92:101]), 64)

			// UnifiedInputRecordを直接構築
			rec := model.UnifiedInputRecord{
				ClientCode:    currentWholesale,
				Flag:          flag,
				Date:          strings.TrimSpace(line[4:12]),
				ReceiptNumber: strings.TrimSpace(line[12:22]),
				LineNumber:    strings.TrimSpace(line[22:24]),
				JanCode:       strings.TrimSpace(line[25:38]),
				ProductName:   strings.TrimSpace(string(utf8Bytes)),
				DatQuantity:   datqty,
				UnitPrice:     unitprice,
				Subtotal:      subtotal,
				ExpiryDate:    strings.TrimSpace(line[109:115]), // 文字列として直接格納
				LotNumber:     strings.TrimSpace(line[115:121]),
			}
			records = append(records, rec)
		}
	}
	return records, scanner.Err()
}


----- C:\Users\wasab\OneDrive\デスクトップ\WASABI\parsers\inventory_parser.go -----
package parsers

import (
	"encoding/csv"
	"fmt"
	"io"
	"strconv"
	"strings"
	"wasabi/model"

	"golang.org/x/text/encoding/japanese"
	"golang.org/x/text/transform"
)

// ParsedInventoryDataはファイル全体の構造体です
type ParsedInventoryData struct {
	Date    string
	Records []model.UnifiedInputRecord
}

// trimQuotesは文字列から空白とシングルクォートを除去します
func trimQuotes(s string) string {
	return strings.Trim(strings.TrimSpace(s), "'")
}

// ParseInventoryFileは棚卸ファイルを解析し、UnifiedInputRecordのスライスを返します
func ParseInventoryFile(r io.Reader) (*ParsedInventoryData, error) {
	decoder := japanese.ShiftJIS.NewDecoder()
	reader := csv.NewReader(transform.NewReader(r, decoder))
	reader.FieldsPerRecord = -1

	var result ParsedInventoryData

	// ▼▼▼ [修正点] 重複するJANコードの数量を合算するためのマップを準備 ▼▼▼
	recordMap := make(map[string]*model.UnifiedInputRecord)
	// ▲▲▲ 修正ここまで ▲▲▲

	records, err := reader.ReadAll()
	if err != nil {
		return nil, fmt.Errorf("csv read all error: %w", err)
	}

	for _, row := range records {
		if len(row) == 0 {
			continue
		}

		rowType := strings.TrimSpace(row[0])
		switch rowType {
		case "H":
			if len(row) > 4 {
				result.Date = trimQuotes(row[4])
			}
		case "R1":
			if len(row) > 45 {
				janCode := trimQuotes(row[45])
				if janCode == "" {
					continue // JANコードがないレコードは集計できないためスキップ
				}

				physicalJanQty, _ := strconv.ParseFloat(strings.TrimSpace(row[21]), 64)

				// ▼▼▼ [修正点] 重複チェックと数量の合算ロジック ▼▼▼
				if existing, ok := recordMap[janCode]; ok {
					// 既にマップに存在する場合、数量を加算
					existing.JanQuantity += physicalJanQty
				} else {
					// マップに存在しない場合、新しいレコードとして追加
					innerPackQty, _ := strconv.ParseFloat(strings.TrimSpace(row[17]), 64)
					recordMap[janCode] = &model.UnifiedInputRecord{
						ProductName:     trimQuotes(row[12]),
						YjUnitName:      trimQuotes(row[16]),
						JanPackInnerQty: innerPackQty,
						JanQuantity:     physicalJanQty,
						YjCode:          trimQuotes(row[42]),
						JanCode:         janCode,
					}
				}
				// ▲▲▲ 修正ここまで ▲▲▲
			}
		}
	}

	// ▼▼▼ [修正点] 合算後のマップから最終的なスライスを作成 ▼▼▼
	finalRecords := make([]model.UnifiedInputRecord, 0, len(recordMap))
	for _, rec := range recordMap {
		finalRecords = append(finalRecords, *rec)
	}
	result.Records = finalRecords
	// ▲▲▲ 修正ここまで ▲▲▲

	return &result, nil
}

----- C:\Users\wasab\OneDrive\デスクトップ\WASABI\parsers\usage_parser.go -----
package parsers

import (
	"encoding/csv"
	"fmt"
	"io"
	"strconv"
	"wasabi/model"

	"golang.org/x/text/encoding/japanese"
	"golang.org/x/text/transform"
)

// ParseUsageはUSAGE CSVを解析し、UnifiedInputRecordのスライスを返します。
func ParseUsage(r io.Reader) ([]model.UnifiedInputRecord, error) {
	reader := csv.NewReader(transform.NewReader(r, japanese.ShiftJIS.NewDecoder()))
	reader.FieldsPerRecord = -1

	var records []model.UnifiedInputRecord
	for {
		rec, err := reader.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			return nil, fmt.Errorf("csv read error: %w", err)
		}

		if len(rec) < 6 {
			continue // skip incomplete rows
		}

		yjQty, _ := strconv.ParseFloat(rec[4], 64)

		unifiedRec := model.UnifiedInputRecord{
			Date:        rec[0],
			YjCode:      rec[1],
			JanCode:     rec[2],
			ProductName: rec[3],
			YjQuantity:  yjQty,
			YjUnitName:  rec[5],
		}
		records = append(records, unifiedRec)
	}
	return records, nil
}

----- C:\Users\wasab\OneDrive\デスクトップ\WASABI\precomp\handler.go -----
package precomp

import (
	"database/sql"
	"encoding/csv"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"os"
	"path/filepath"
	"strconv"
	"wasabi/db"
	"wasabi/model"

	"golang.org/x/text/encoding/japanese"
	"golang.org/x/text/transform"
)

// PrecompPayload は保存・更新時にフロントエンドから受け取るデータ構造です
type PrecompPayload struct {
	PatientNumber string                  `json:"patientNumber"`
	Records       []db.PrecompRecordInput `json:"records"`
}

// LoadResponse は呼び出し時にフロントエンドへ返すデータ構造です
type LoadResponse struct {
	Status  string                    `json:"status"`
	Records []model.TransactionRecord `json:"records"`
}

// SavePrecompHandler は予製データを保存・更新します
func SavePrecompHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var payload PrecompPayload
		if err := json.NewDecoder(r.Body).Decode(&payload); err != nil {
			http.Error(w, "Invalid request body", http.StatusBadRequest)
			return
		}

		if payload.PatientNumber == "" {
			http.Error(w, "Patient number is required", http.StatusBadRequest)
			return
		}

		tx, err := conn.Begin()
		if err != nil {
			http.Error(w, "Failed to start transaction", http.StatusInternalServerError)
			return
		}
		defer tx.Rollback()

		if err := db.UpsertPreCompoundingRecordsInTx(tx, payload.PatientNumber, payload.Records); err != nil {
			log.Printf("ERROR: Failed to save pre-compounding records for patient %s: %v", payload.PatientNumber, err)
			http.Error(w, "Failed to save pre-compounding records: "+err.Error(), http.StatusInternalServerError)
			return
		}

		if err := tx.Commit(); err != nil {
			http.Error(w, "Failed to commit transaction", http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]string{"message": "予製データを保存しました。"})
	}
}

// LoadPrecompHandler は患者の予製データと現在のステータスを返します
func LoadPrecompHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		patientNumber := r.URL.Query().Get("patientNumber")
		if patientNumber == "" {
			http.Error(w, "Patient number is required", http.StatusBadRequest)
			return
		}

		status, err := db.GetPreCompoundingStatusByPatient(conn, patientNumber)
		if err != nil {
			http.Error(w, "Failed to get pre-compounding status: "+err.Error(), http.StatusInternalServerError)
			return
		}
		records, err := db.GetPreCompoundingRecordsByPatient(conn, patientNumber)
		if err != nil {
			http.Error(w, "Failed to load pre-compounding records: "+err.Error(), http.StatusInternalServerError)
			return
		}

		response := LoadResponse{
			Status:  status,
			Records: records,
		}
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(response)
	}
}

// ClearPrecompHandler は予製データを完全に削除します
func ClearPrecompHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		patientNumber := r.URL.Query().Get("patientNumber")
		if patientNumber == "" {
			http.Error(w, "Patient number is required", http.StatusBadRequest)
			return
		}

		if err := db.DeletePreCompoundingRecordsByPatient(conn, patientNumber); err != nil {
			http.Error(w, "Failed to clear pre-compounding records: "+err.Error(), http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]string{"message": "予製データを完全に削除しました。"})
	}
}

// SuspendPrecompHandler は予製を中断状態にします
func SuspendPrecompHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var payload struct {
			PatientNumber string `json:"patientNumber"`
		}
		if err := json.NewDecoder(r.Body).Decode(&payload); err != nil {
			http.Error(w, "Invalid request body", http.StatusBadRequest)
			return
		}
		if payload.PatientNumber == "" {
			http.Error(w, "Patient number is required", http.StatusBadRequest)
			return
		}
		tx, err := conn.Begin()
		if err != nil {
			http.Error(w, "Failed to start transaction", http.StatusInternalServerError)
			return
		}
		defer tx.Rollback()
		if err := db.SuspendPreCompoundingRecordsByPatient(tx, payload.PatientNumber); err != nil {
			http.Error(w, "Failed to suspend pre-compounding records: "+err.Error(), http.StatusInternalServerError)
			return
		}
		if err := tx.Commit(); err != nil {
			http.Error(w, "Failed to commit transaction", http.StatusInternalServerError)
			return
		}
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]string{"message": "予製を中断しました。"})
	}
}

// ResumePrecompHandler は予製を再開状態にします
func ResumePrecompHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var payload struct {
			PatientNumber string `json:"patientNumber"`
		}
		if err := json.NewDecoder(r.Body).Decode(&payload); err != nil {
			http.Error(w, "Invalid request body", http.StatusBadRequest)
			return
		}
		if payload.PatientNumber == "" {
			http.Error(w, "Patient number is required", http.StatusBadRequest)
			return
		}
		tx, err := conn.Begin()
		if err != nil {
			http.Error(w, "Failed to start transaction", http.StatusInternalServerError)
			return
		}
		defer tx.Rollback()
		if err := db.ResumePreCompoundingRecordsByPatient(tx, payload.PatientNumber); err != nil {
			http.Error(w, "Failed to resume pre-compounding records: "+err.Error(), http.StatusInternalServerError)
			return
		}
		if err := tx.Commit(); err != nil {
			http.Error(w, "Failed to commit transaction", http.StatusInternalServerError)
			return
		}
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]string{"message": "予製を再開しました。"})
	}
}

// GetStatusPrecompHandler は予製の現在の状態を返します
func GetStatusPrecompHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		patientNumber := r.URL.Query().Get("patientNumber")
		if patientNumber == "" {
			http.Error(w, "Patient number is required", http.StatusBadRequest)
			return
		}
		status, err := db.GetPreCompoundingStatusByPatient(conn, patientNumber)
		if err != nil {
			http.Error(w, "Failed to get status: "+err.Error(), http.StatusInternalServerError)
			return
		}
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]string{"status": status})
	}
}

func ExportPrecompHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		patientNumber := r.URL.Query().Get("patientNumber")
		if patientNumber == "" {
			http.Error(w, "Patient number is required", http.StatusBadRequest)
			return
		}

		records, err := db.GetPreCompoundingRecordsByPatient(conn, patientNumber)
		if err != nil {
			http.Error(w, "Failed to load pre-compounding records: "+err.Error(), http.StatusInternalServerError)
			return
		}

		dirPath := filepath.Join("download", "exports")
		if err := os.MkdirAll(dirPath, 0755); err != nil {
			http.Error(w, "Failed to create directory", http.StatusInternalServerError)
			return
		}
		fileName := fmt.Sprintf("precomp_%s.csv", patientNumber)
		filePath := filepath.Join(dirPath, fileName)

		file, err := os.Create(filePath)
		if err != nil {
			http.Error(w, "Failed to create file", http.StatusInternalServerError)
			return
		}
		defer file.Close()

		file.Write([]byte{0xEF, 0xBB, 0xBF}) // UTF-8 BOM
		csvWriter := csv.NewWriter(file)

		header := []string{"product_code", "product_name", "quantity_jan", "unit_name"}
		csvWriter.Write(header)

		for _, rec := range records {
			row := []string{
				fmt.Sprintf(`="%s"`, rec.JanCode), // Excel対応
				rec.ProductName,
				fmt.Sprintf("%f", rec.JanQuantity),
				rec.JanUnitName,
			}
			csvWriter.Write(row)
		}
		csvWriter.Flush()

		http.ServeFile(w, r, filePath)
	}
}

func ImportPrecompHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		if err := r.ParseMultipartForm(10 << 20); err != nil { // 10MB limit
			http.Error(w, "File upload error", http.StatusBadRequest)
			return
		}

		patientNumber := r.FormValue("patientNumber")
		if patientNumber == "" {
			http.Error(w, "Patient number is required", http.StatusBadRequest)
			return
		}

		file, _, err := r.FormFile("file")
		if err != nil {
			http.Error(w, "No file uploaded", http.StatusBadRequest)
			return
		}
		defer file.Close()

		reader := transform.NewReader(file, japanese.ShiftJIS.NewDecoder())
		csvReader := csv.NewReader(reader)
		csvReader.LazyQuotes = true

		records, err := csvReader.ReadAll()
		if err != nil {
			http.Error(w, "Failed to parse CSV file", http.StatusBadRequest)
			return
		}

		var precompRecords []db.PrecompRecordInput
		for i, row := range records {
			if i == 0 || len(row) < 3 {
				continue
			}
			productCode := row[0]
			quantity, err := strconv.ParseFloat(row[2], 64)
			if err != nil || productCode == "" {
				continue
			}
			precompRecords = append(precompRecords, db.PrecompRecordInput{
				ProductCode: productCode,
				JanQuantity: quantity,
			})
		}

		tx, err := conn.Begin()
		if err != nil {
			http.Error(w, "Failed to start transaction", http.StatusInternalServerError)
			return
		}
		defer tx.Rollback()

		if err := db.UpsertPreCompoundingRecordsInTx(tx, patientNumber, precompRecords); err != nil {
			http.Error(w, "Failed to save pre-compounding records: "+err.Error(), http.StatusInternalServerError)
			return
		}

		if err := tx.Commit(); err != nil {
			http.Error(w, "Failed to commit transaction", http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]string{
			"message": fmt.Sprintf("%d件の予製データをインポートしました。", len(precompRecords)),
		})
	}
}

func ExportAllPrecompHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		records, err := db.GetAllPreCompoundingRecords(conn)
		if err != nil {
			http.Error(w, "Failed to load all pre-compounding records: "+err.Error(), http.StatusInternalServerError)
			return
		}

		fileName := "precomp_all.csv"
		w.Header().Set("Content-Type", "text/csv")
		w.Header().Set("Content-Disposition", "attachment; filename="+fileName)
		w.Write([]byte{0xEF, 0xBB, 0xBF}) // UTF-8 BOM

		csvWriter := csv.NewWriter(w)
		defer csvWriter.Flush()

		header := []string{"patient_number", "product_code", "product_name", "quantity_jan", "unit_name"}
		if err := csvWriter.Write(header); err != nil {
			log.Printf("Failed to write CSV header for all precomp export: %v", err)
			return
		}

		for _, rec := range records {
			row := []string{
				rec.ClientCode,
				rec.JanCode,
				rec.ProductName,
				fmt.Sprintf("%f", rec.JanQuantity),
				rec.JanUnitName,
			}
			if err := csvWriter.Write(row); err != nil {
				log.Printf("Failed to write CSV row for all precomp export: %v", err)
				continue
			}
		}
	}
}

func BulkImportPrecompHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		file, _, err := r.FormFile("file")
		if err != nil {
			http.Error(w, "No file uploaded", http.StatusBadRequest)
			return
		}
		defer file.Close()

		reader := transform.NewReader(file, japanese.ShiftJIS.NewDecoder())
		csvReader := csv.NewReader(reader)
		csvReader.LazyQuotes = true

		records, err := csvReader.ReadAll()
		if err != nil {
			http.Error(w, "Failed to parse CSV file", http.StatusBadRequest)
			return
		}

		recordsByPatient := make(map[string][]db.PrecompRecordInput)
		var importedCount int
		for i, row := range records {
			if i == 0 || len(row) < 4 {
				continue
			}
			patientNumber := row[0]
			productCode := row[1]
			quantity, err := strconv.ParseFloat(row[3], 64)
			if err != nil || productCode == "" || patientNumber == "" {
				continue
			}
			recordsByPatient[patientNumber] = append(recordsByPatient[patientNumber], db.PrecompRecordInput{
				ProductCode: productCode,
				JanQuantity: quantity,
			})
			importedCount++
		}

		if len(recordsByPatient) == 0 {
			http.Error(w, "No valid data found in CSV file.", http.StatusBadRequest)
			return
		}

		tx, err := conn.Begin()
		if err != nil {
			http.Error(w, "Failed to start transaction", http.StatusInternalServerError)
			return
		}
		defer tx.Rollback()

		for patientNumber, precompRecords := range recordsByPatient {
			if err := db.UpsertPreCompoundingRecordsInTx(tx, patientNumber, precompRecords); err != nil {
				http.Error(w, fmt.Sprintf("Failed to save records for patient %s: %s", patientNumber, err.Error()), http.StatusInternalServerError)
				return
			}
		}

		if err := tx.Commit(); err != nil {
			http.Error(w, "Failed to commit transaction", http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]string{
			"message": fmt.Sprintf("%d名の患者の予製データ（計%d件）をインポートしました。", len(recordsByPatient), importedCount),
		})
	}
}


----- C:\Users\wasab\OneDrive\デスクトップ\WASABI\pricing\handler.go -----
// C:\Users\wasab\OneDrive\デスクトップ\WASABI\pricing\handler.go

package pricing

import (
	"bufio"
	"database/sql"
	"encoding/csv"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"strconv"
	"strings"
	"time"
	"wasabi/db"
	"wasabi/model"
	"wasabi/units"
)

func GetExportDataHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		wholesalerName := r.URL.Query().Get("wholesalerName")
		unregisteredOnlyStr := r.URL.Query().Get("unregisteredOnly")
		unregisteredOnly := unregisteredOnlyStr == "true"

		if wholesalerName == "" {
			http.Error(w, "Wholesaler name is required", http.StatusBadRequest)
			return
		}

		allMasters, err := db.GetAllProductMasters(conn)
		if err != nil {
			http.Error(w, "Failed to get products for export", http.StatusInternalServerError)
			return
		}

		var mastersToProcess []*model.ProductMaster
		for _, p := range allMasters {
			if strings.HasPrefix(p.ProductCode, "99999") && len(p.ProductCode) > 13 {
				continue
			}
			mastersToProcess = append(mastersToProcess, p)
		}

		var dataToExport []*model.ProductMaster
		if unregisteredOnly {
			for _, p := range mastersToProcess {
				if p.SupplierWholesale == "" {
					uc := p.UsageClassification
					if uc == "機" || uc == "他" || ((uc == "内" || uc == "外" || uc == "歯" || uc == "注") && p.Origin == "JCSHMS") {
						dataToExport = append(dataToExport, p)
					}
				}
			}
			if len(dataToExport) == 0 {
				http.Error(w, "Export target not found", http.StatusNotFound)
				return
			}
		} else {
			dataToExport = mastersToProcess
		}

		dateStr := r.URL.Query().Get("date")
		fileType := "ALL"
		if unregisteredOnly {
			fileType = "UNREGISTERED"
		}
		fileName := fmt.Sprintf("価格見積依頼_%s_%s_%s.csv", wholesalerName, fileType, dateStr)

		w.Header().Set("Content-Type", "text/csv")
		w.Header().Set("Content-Disposition", "attachment; filename="+fileName)

		// ▼▼▼【ここを修正】BOMを書き込む行を削除 ▼▼▼
		// w.Write([]byte{0xEF, 0xBB, 0xBF}) // UTF-8 BOM
		// ▲▲▲【修正ここまで】▲▲▲

		csvWriter := csv.NewWriter(w)
		defer csvWriter.Flush()

		headers := []string{"product_code", "product_name", "maker_name", "package_spec", "purchase_price"}
		csvWriter.Write(headers)

		for _, m := range dataToExport {
			tempJcshms := model.JCShms{
				JC037: m.PackageForm,
				JC039: m.YjUnitName,
				JC044: m.YjPackUnitQty,
				JA006: sql.NullFloat64{Float64: m.JanPackInnerQty, Valid: true},
				JA008: sql.NullFloat64{Float64: m.JanPackUnitQty, Valid: true},
				JA007: sql.NullString{String: fmt.Sprintf("%d", m.JanUnitCode), Valid: true},
			}
			formattedSpec := units.FormatPackageSpec(&tempJcshms)

			record := []string{
				fmt.Sprintf("=%q", m.ProductCode),
				m.ProductName,
				m.MakerName,
				formattedSpec,
				"", // purchase_price is left empty
			}
			csvWriter.Write(record)
		}
	}
}

type QuoteDataWithSpec struct {
	model.ProductMaster
	FormattedPackageSpec string             `json:"formattedPackageSpec"`
	Quotes               map[string]float64 `json:"quotes"`
}

type UploadResponse struct {
	ProductData     []QuoteDataWithSpec `json:"productData"`
	WholesalerOrder []string            `json:"wholesalerOrder"`
}

func UploadQuotesHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		if err := r.ParseMultipartForm(32 << 20); err != nil {
			http.Error(w, "File upload error", http.StatusBadRequest)
			return
		}

		allMasters, err := db.GetAllProductMasters(conn)
		if err != nil {
			http.Error(w, "Failed to get all product masters", http.StatusInternalServerError)
			return
		}

		quotesByProduct := make(map[string]map[string]float64)
		wholesalerFiles := r.MultipartForm.File["files"]
		wholesalerNames := r.MultipartForm.Value["wholesalerNames"]

		if len(wholesalerFiles) != len(wholesalerNames) {
			http.Error(w, "File and wholesaler name mismatch", http.StatusBadRequest)
			return
		}

		for i, fileHeader := range wholesalerFiles {
			wholesalerName := wholesalerNames[i]
			file, err := fileHeader.Open()
			if err != nil {
				log.Printf("WARN: could not open uploaded file for %s: %v", wholesalerName, err)
				continue
			}
			defer file.Close()

			// ▼▼▼【ここから修正】BOMを自動的にスキップする処理を追加 ▼▼▼
			br := bufio.NewReader(file)
			bom, err := br.Peek(3)
			if err == nil && bom[0] == 0xef && bom[1] == 0xbb && bom[2] == 0xbf {
				br.Read(make([]byte, 3)) // BOMを読み飛ばす
			}
			csvReader := csv.NewReader(br)
			// ▲▲▲【修正ここまで】▲▲▲

			csvReader.LazyQuotes = true
			rows, err := csvReader.ReadAll()
			if err != nil || len(rows) < 1 {
				log.Printf("WARN: could not parse CSV for %s: %v", wholesalerName, err)
				continue
			}

			header := rows[0]
			codeIndex, priceIndex := -1, -1
			for i, h := range header {
				if h == "product_code" {
					codeIndex = i
				}
				if h == "purchase_price" {
					priceIndex = i
				}
			}

			if codeIndex == -1 || priceIndex == -1 {
				log.Printf("WARN: required columns not found in file from %s", wholesalerName)
				continue
			}

			for _, row := range rows[1:] {
				if len(row) <= codeIndex || len(row) <= priceIndex {
					continue
				}

				productCode := strings.Trim(strings.TrimSpace(row[codeIndex]), `="`)
				priceStr := row[priceIndex]

				if productCode == "" || priceStr == "" {
					continue
				}

				price, err := strconv.ParseFloat(priceStr, 64)
				if err != nil {
					continue
				}

				if _, ok := quotesByProduct[productCode]; !ok {
					quotesByProduct[productCode] = make(map[string]float64)
				}
				quotesByProduct[productCode][wholesalerName] = price
			}
		}

		var responseData []QuoteDataWithSpec
		for _, master := range allMasters {
			tempJcshms := model.JCShms{
				JC037: master.PackageForm,
				JC039: master.YjUnitName,
				JC044: master.YjPackUnitQty,
				JA006: sql.NullFloat64{Float64: master.JanPackInnerQty, Valid: true},
				JA008: sql.NullFloat64{Float64: master.JanPackUnitQty, Valid: true},
				JA007: sql.NullString{String: fmt.Sprintf("%d", master.JanUnitCode), Valid: true},
			}
			formattedSpec := units.FormatPackageSpec(&tempJcshms)

			responseData = append(responseData, QuoteDataWithSpec{
				ProductMaster:        *master,
				FormattedPackageSpec: formattedSpec,
				Quotes:               quotesByProduct[master.ProductCode],
			})
		}

		finalResponse := UploadResponse{
			ProductData:     responseData,
			WholesalerOrder: wholesalerNames,
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(finalResponse)
	}
}

func BulkUpdateHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var payload []model.PriceUpdate
		if err := json.NewDecoder(r.Body).Decode(&payload); err != nil {
			http.Error(w, "Invalid request body: "+err.Error(), http.StatusBadRequest)
			return
		}

		tx, err := conn.Begin()
		if err != nil {
			http.Error(w, "Failed to start transaction", http.StatusInternalServerError)
			return
		}
		defer tx.Rollback()

		if err := db.UpdatePricesAndSuppliersInTx(tx, payload); err != nil {
			http.Error(w, "Failed to update prices: "+err.Error(), http.StatusInternalServerError)
			return
		}

		if err := tx.Commit(); err != nil {
			http.Error(w, "Failed to commit transaction", http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]string{
			"message": fmt.Sprintf("%d件の医薬品マスターを更新しました。", len(payload)),
		})
	}
}

func GetAllMastersForPricingHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		allMasters, err := db.GetAllProductMasters(conn)
		if err != nil {
			http.Error(w, "Failed to get all product masters for pricing", http.StatusInternalServerError)
			return
		}

		responseData := make([]QuoteDataWithSpec, 0, len(allMasters))
		for _, master := range allMasters {
			tempJcshms := model.JCShms{
				JC037: master.PackageForm,
				JC039: master.YjUnitName,
				JC044: master.YjPackUnitQty,
				JA006: sql.NullFloat64{Float64: master.JanPackInnerQty, Valid: true},
				JA008: sql.NullFloat64{Float64: master.JanPackUnitQty, Valid: true},
				JA007: sql.NullString{String: fmt.Sprintf("%d", master.JanUnitCode), Valid: true},
			}
			formattedSpec := units.FormatPackageSpec(&tempJcshms)

			responseData = append(responseData, QuoteDataWithSpec{
				ProductMaster:        *master,
				FormattedPackageSpec: formattedSpec,
				Quotes:               make(map[string]float64),
			})
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(responseData)
	}
}

func DirectImportHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		file, _, err := r.FormFile("file")
		if err != nil {
			http.Error(w, "No file uploaded", http.StatusBadRequest)
			return
		}
		defer file.Close()

		// ▼▼▼【ここから修正】BOMを自動的にスキップする処理を追加 ▼▼▼
		br := bufio.NewReader(file)
		bom, err := br.Peek(3)
		if err == nil && bom[0] == 0xef && bom[1] == 0xbb && bom[2] == 0xbf {
			br.Read(make([]byte, 3)) // BOMを読み飛ばす
		}
		csvReader := csv.NewReader(br)
		// ▲▲▲【修正ここまで】▲▲▲

		csvReader.LazyQuotes = true
		rows, err := csvReader.ReadAll()
		if err != nil {
			http.Error(w, "Failed to parse CSV file: "+err.Error(), http.StatusBadRequest)
			return
		}

		var updates []model.PriceUpdate
		for i, row := range rows {
			if i == 0 {
				continue
			}
			if len(row) < 6 {
				continue
			}

			productCode := strings.Trim(strings.TrimSpace(row[0]), `="`)
			priceStr := strings.TrimSpace(row[4])
			supplierCode := strings.TrimSpace(row[5])

			if productCode == "" || priceStr == "" || supplierCode == "" {
				continue
			}

			price, err := strconv.ParseFloat(priceStr, 64)
			if err != nil {
				continue
			}

			updates = append(updates, model.PriceUpdate{
				ProductCode:      productCode,
				NewPurchasePrice: price,
				NewSupplier:      supplierCode,
			})
		}

		if len(updates) == 0 {
			http.Error(w, "No valid data to import found in the file.", http.StatusBadRequest)
			return
		}

		tx, err := conn.Begin()
		if err != nil {
			http.Error(w, "Failed to start transaction", http.StatusInternalServerError)
			return
		}
		defer tx.Rollback()

		if err := db.UpdatePricesAndSuppliersInTx(tx, updates); err != nil {
			http.Error(w, "Failed to update prices: "+err.Error(), http.StatusInternalServerError)
			return
		}

		if err := tx.Commit(); err != nil {
			http.Error(w, "Failed to commit transaction", http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]string{
			"message": fmt.Sprintf("%d件の納入価と卸情報を更新しました。", len(updates)),
		})
	}
}

func BackupExportHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		allMasters, err := db.GetAllProductMasters(conn)
		if err != nil {
			http.Error(w, "Failed to get products for backup export", http.StatusInternalServerError)
			return
		}

		now := time.Now()
		fileName := fmt.Sprintf("納入価・卸バックアップ_%s.csv", now.Format("20060102_150405"))
		w.Header().Set("Content-Type", "text/csv")
		w.Header().Set("Content-Disposition", "attachment; filename="+fileName)

		// ▼▼▼【ここを修正】BOMを書き込む行を削除 ▼▼▼
		// w.Write([]byte{0xEF, 0xBB, 0xBF})
		// ▲▲▲【修正ここまで】▲▲▲

		csvWriter := csv.NewWriter(w)
		defer csvWriter.Flush()

		headers := []string{"product_code", "product_name", "maker_name", "package_spec", "purchase_price", "supplier_wholesale"}
		csvWriter.Write(headers)

		for _, m := range allMasters {
			tempJcshms := model.JCShms{
				JC037: m.PackageForm,
				JC039: m.YjUnitName,
				JC044: m.YjPackUnitQty,
				JA006: sql.NullFloat64{Float64: m.JanPackInnerQty, Valid: true},
				JA008: sql.NullFloat64{Float64: m.JanPackUnitQty, Valid: true},
				JA007: sql.NullString{String: fmt.Sprintf("%d", m.JanUnitCode), Valid: true},
			}
			formattedSpec := units.FormatPackageSpec(&tempJcshms)

			record := []string{
				fmt.Sprintf("=%q", m.ProductCode),
				m.ProductName,
				m.MakerName,
				formattedSpec,
				strconv.FormatFloat(m.PurchasePrice, 'f', 2, 64),
				m.SupplierWholesale,
			}
			csvWriter.Write(record)
		}
	}
}


----- C:\Users\wasab\OneDrive\デスクトップ\WASABI\product\handler.go -----
// C:\Users\wasab\OneDrive\デスクトップ\WASABI\product\handler.go
package product

import (
	"database/sql"
	"encoding/json"
	"net/http"
	"strings"
	"time"
	"wasabi/config"
	"wasabi/db"
	"wasabi/mappers"
	"wasabi/model"
)

var kanaRowMap = map[string][]string{
	"ア": {"ア", "イ", "ウ", "エ", "オ"},
	"カ": {"カ", "キ", "ク", "ケ", "コ"},
	"サ": {"サ", "シ", "ス", "セ", "ソ"},
	"タ": {"タ", "チ", "ツ", "テ", "ト"},
	"ナ": {"ナ", "ニ", "ヌ", "ネ", "ノ"},
	"ハ": {"ハ", "ヒ", "フ", "ヘ", "ホ"},
	"マ": {"マ", "ミ", "ム", "メ", "モ"},
	"ヤ": {"ヤ", "ユ", "ヨ"},
	"ラ": {"ラ", "リ", "ル", "レ", "ロ"},
	"ワ": {"ワ", "ヰ", "ヱ", "ヲ", "ン"},
}

func toKatakana(s string) string {
	var res string
	for _, r := range s {
		if r >= 'ぁ' && r <= 'ゔ' {
			res += string(r + 0x60)
		} else {
			res += string(r)
		}
	}
	return res
}
func toHiragana(s string) string {
	var res string
	for _, r := range s {
		if r >= 'ァ' && r <= 'ヴ' {
			res += string(r - 0x60)
		} else {
			res += string(r)
		}
	}
	return res
}

var kanaVariants = map[rune][]rune{
	'ア': {'ァ'}, 'イ': {'ィ'}, 'ウ': {'ゥ'}, 'エ': {'ェ'}, 'オ': {'ォ'},
	'カ': {'ガ'}, 'キ': {'ギ'}, 'ク': {'グ'}, 'ケ': {'ゲ'}, 'コ': {'ゴ'},
	'サ': {'ザ'}, 'シ': {'ジ'}, 'ス': {'ズ'}, 'セ': {'ゼ'}, 'ソ': {'ゾ'},
	'タ': {'ダ'}, 'チ': {'ヂ'}, 'ツ': {'ッ', 'ヅ'}, 'テ': {'デ'}, 'ト': {'ド'},
	'ハ': {'バ', 'パ'}, 'ヒ': {'ビ', 'ピ'}, 'フ': {'ブ', 'プ'}, 'ヘ': {'ベ', 'ペ'}, 'ホ': {'ボ', 'ポ'},
	'ヤ': {'ャ'}, 'ユ': {'ュ'}, 'ヨ': {'ョ'},
	'ワ': {'ヮ'},
}

func SearchProductsHandler(conn *sql.DB) http.HandlerFunc {
	handler := func(w http.ResponseWriter, r *http.Request) {
		q := r.URL.Query()
		dosageForm := q.Get("dosageForm")
		kanaInitial := q.Get("kanaInitial")
		searchQuery := q.Get("q")
		isDeadStockOnly := q.Get("deadStockOnly") == "true"
		drugTypesParam := q.Get("drugTypes")
		shelfNumber := q.Get("shelfNumber")
		var results []model.ProductMasterView

		if isDeadStockOnly {
			cfg, err := config.LoadConfig()
			if err != nil {
				http.Error(w, "設定ファイルの読み込みに失敗しました: "+err.Error(), http.StatusInternalServerError)
				return
			}
			now := time.Now()
			endDate := "99991231"
			startDate := now.AddDate(0, 0, -cfg.CalculationPeriodDays)
			filters := model.DeadStockFilters{
				StartDate:        startDate.Format("20060102"),
				EndDate:          endDate,
				ExcludeZeroStock: true,
				KanaName:         searchQuery,
				DosageForm:       dosageForm,
				ShelfNumber:      shelfNumber,
			}

			deadStockGroups, dsErr := db.GetDeadStockList(conn, filters)
			if dsErr != nil {
				http.Error(w, "Failed to get dead stock list: "+dsErr.Error(), http.StatusInternalServerError)
				return
			}
			seenYjCodes := make(map[string]bool)
			for _, group := range deadStockGroups {
				for _, pkg := range group.PackageGroups {
					for _, prod := range pkg.Products {
						if !seenYjCodes[prod.YjCode] {
							master := prod.ProductMaster
							view := mappers.ToProductMasterView(&master)
							results = append(results, view)
							seenYjCodes[master.YjCode] = true
						}
					}
				}
			}
		} else {
			query := `SELECT ` + db.SelectColumns + ` FROM product_master p WHERE p.yj_code != ''`
			var args []interface{}
			if dosageForm != "" {
				query += " AND p.usage_classification LIKE ?"
				args = append(args, "%"+dosageForm+"%")
			}
			if kanaInitial != "" {
				if kanaChars, ok := kanaRowMap[toKatakana(kanaInitial)]; ok {
					var conditions []string
					for _, charStr := range kanaChars {
						baseRunes := []rune(charStr)
						if len(baseRunes) == 0 {
							continue
						}
						baseRune := baseRunes[0]
						charsToTest := []rune{baseRune}
						if variants, found := kanaVariants[baseRune]; found {
							charsToTest = append(charsToTest, variants...)
						}
						for _, char := range charsToTest {
							kataChar, hiraChar := string(char), toHiragana(string(char))
							conditions = append(conditions, "p.kana_name LIKE ? OR p.kana_name LIKE ?")
							args = append(args, kataChar+"%", hiraChar+"%")
						}
					}
					if len(conditions) > 0 {
						query += " AND (" + strings.Join(conditions, " OR ") + ")"
					}
				}
			}
			if drugTypesParam != "" {
				drugTypes := strings.Split(drugTypesParam, ",")
				if len(drugTypes) > 0 && drugTypes[0] != "" {
					var conditions []string
					flagMap := map[string]string{
						"poison": "p.flag_poison = 1", "deleterious": "p.flag_deleterious = 1",
						"narcotic": "p.flag_narcotic = 1", "psychotropic1": "p.flag_psychotropic = 1",
						"psychotropic2": "p.flag_psychotropic = 2", "psychotropic3": "p.flag_psychotropic = 3",
					}
					for _, dt := range drugTypes {
						if cond, ok := flagMap[dt]; ok {
							conditions = append(conditions, cond)
						}
					}
					if len(conditions) > 0 {
						query += " AND (" + strings.Join(conditions, " OR ") + ")"
					}
				}
			}
			if searchQuery != "" {
				query += " AND (p.kana_name LIKE ? OR p.product_name LIKE ?)"
				args = append(args, "%"+searchQuery+"%", "%"+searchQuery+"%")
			}
			if shelfNumber != "" {
				query += " AND p.shelf_number LIKE ?"
				args = append(args, "%"+shelfNumber+"%")
			}
			query += ` ORDER BY
				CASE
					WHEN TRIM(p.usage_classification) = '内' OR TRIM(p.usage_classification) = '1' THEN 1
					WHEN TRIM(p.usage_classification) = '外' OR TRIM(p.usage_classification) = '2' THEN 2
					WHEN TRIM(p.usage_classification) = '注' OR TRIM(p.usage_classification) = '3' THEN 3
					WHEN TRIM(p.usage_classification) = '歯' OR TRIM(p.usage_classification) = '4' THEN 4
					WHEN TRIM(p.usage_classification) = '機' OR TRIM(p.usage_classification) = '5' THEN 5
					WHEN TRIM(p.usage_classification) = '他' OR TRIM(p.usage_classification) = '6' THEN 6
					ELSE 7
				END,
				p.kana_name`
			rows, queryErr := conn.Query(query, args...)
			if queryErr != nil {
				http.Error(w, "Failed to search products: "+queryErr.Error(), http.StatusInternalServerError)
				return
			}
			defer rows.Close()
			seenYjCodes := make(map[string]bool)
			for rows.Next() {
				master, scanErr := db.ScanProductMaster(rows)
				if scanErr != nil {
					http.Error(w, "Failed to scan product: "+scanErr.Error(), http.StatusInternalServerError)
					return
				}
				if !seenYjCodes[master.YjCode] {
					view := mappers.ToProductMasterView(master)
					results = append(results, view)
					seenYjCodes[master.YjCode] = true
				}
			}
		}
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(results)
	}
	return handler
}

type ProductLedgerResponse struct {
	LedgerTransactions []model.LedgerTransaction `json:"ledgerTransactions"`
	PrecompDetails     []model.TransactionRecord `json:"precompDetails"`
}

// ▼▼▼【ここから修正】▼▼▼
func GetProductLedgerHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		productCode := strings.TrimPrefix(r.URL.Path, "/api/ledger/product/")
		if productCode == "" {
			http.Error(w, "Product code is required", http.StatusBadRequest)
			return
		}

		// 対象製品のマスター情報を取得してYJコードを得る
		master, err := db.GetProductMasterByCode(conn, productCode)
		if err != nil {
			http.Error(w, "Failed to get master for product: "+err.Error(), http.StatusInternalServerError)
			return
		}
		if master == nil {
			http.Error(w, "Product master not found", http.StatusNotFound)
			return
		}

		// 期間設定 (過去30日)
		endDate := time.Now()
		startDate := endDate.AddDate(0, 0, -30)

		// 修正済みのGetStockLedgerを呼び出す
		filters := model.AggregationFilters{
			StartDate: startDate.Format("20060102"),
			EndDate:   endDate.Format("20060102"),
			YjCode:    master.YjCode,
		}
		ledgerGroups, err := db.GetStockLedger(conn, filters)
		if err != nil {
			http.Error(w, "Failed to get stock ledger for product: "+err.Error(), http.StatusInternalServerError)
			return
		}

		// 結果から該当製品の取引履歴を抽出する
		var ledgerTxs []model.LedgerTransaction
		for _, group := range ledgerGroups {
			for _, pkg := range group.PackageLedgers {
				for _, m := range pkg.Masters {
					if m.ProductCode == productCode {
						ledgerTxs = pkg.Transactions
						goto Found
					}
				}
			}
		}
	Found:

		// 予製情報を取得
		precomps, err := db.GetPreCompoundingDetailsByProductCodes(conn, []string{productCode})
		if err != nil {
			http.Error(w, "Failed to get precomp details: "+err.Error(), http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(ProductLedgerResponse{
			LedgerTransactions: ledgerTxs,
			PrecompDetails:     precomps,
		})
	}
}

// ▲▲▲【修正ここまで】▲▲▲

func GetMasterByCodeHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		productCode := strings.TrimPrefix(r.URL.Path, "/api/master/by_code/")
		if productCode == "" {
			http.Error(w, "Product code is required", http.StatusBadRequest)
			return
		}

		master, err := db.GetProductMasterByCode(conn, productCode)
		if err != nil {
			http.Error(w, "Failed to get product by code: "+err.Error(), http.StatusInternalServerError)
			return
		}

		if master == nil {
			http.Error(w, "Product not found", http.StatusNotFound)
			return
		}

		masterView := mappers.ToProductMasterView(master)

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(masterView)
	}
}


----- C:\Users\wasab\OneDrive\デスクトップ\WASABI\reprocess\handler.go -----
package reprocess

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"wasabi/db"
	"wasabi/mappers"
	"wasabi/model"
)

// ProcessTransactionsHandler は全ての取引データを最新のマスター情報で更新します。
func ProcessTransactionsHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// 全ての製品マスターをメモリにロード（高速化のため）
		allMasters, err := db.GetAllProductMasters(conn)
		if err != nil {
			http.Error(w, "Failed to fetch all product masters: "+err.Error(), http.StatusInternalServerError)
			return
		}
		// ▼▼▼【ここを修正】▼▼▼
		mastersMap := make(map[string]*model.ProductMaster)
		// ▲▲▲【修正ここまで】▲▲▲
		for _, m := range allMasters {
			mastersMap[m.ProductCode] = m
		}

		// 全ての取引レコードを取得
		rows, err := conn.Query("SELECT " + db.TransactionColumns + " FROM transaction_records")
		if err != nil {
			http.Error(w, "Failed to fetch all transaction records: "+err.Error(), http.StatusInternalServerError)
			return
		}
		defer rows.Close()

		var allRecords []model.TransactionRecord
		for rows.Next() {
			rec, err := db.ScanTransactionRecord(rows)
			if err != nil {
				http.Error(w, "Failed to scan transaction record: "+err.Error(), http.StatusInternalServerError)
				return
			}
			allRecords = append(allRecords, *rec)
		}

		if len(allRecords) == 0 {
			w.Header().Set("Content-Type", "application/json")
			json.NewEncoder(w).Encode(map[string]string{"message": "再計算対象の取引データはありませんでした。"})
			return
		}

		// バッチ処理で更新
		const batchSize = 500
		updatedCount := 0
		for i := 0; i < len(allRecords); i += batchSize {
			end := i + batchSize
			if end > len(allRecords) {
				end = len(allRecords)
			}
			batch := allRecords[i:end]

			tx, err := conn.Begin()
			if err != nil {
				http.Error(w, "Failed to start transaction: "+err.Error(), http.StatusInternalServerError)
				return
			}

			for _, rec := range batch {
				master, ok := mastersMap[rec.JanCode]
				if !ok {
					continue
				}

				// 1. 最新のマスター情報をレコードにマッピング
				mappers.MapProductMasterToTransaction(&rec, master)

				// 2. 数量を再計算
				if rec.JanQuantity > 0 && master.JanPackInnerQty > 0 {
					rec.YjQuantity = rec.JanQuantity * master.JanPackInnerQty
				} else if rec.YjQuantity > 0 && rec.JanQuantity == 0 && master.JanPackInnerQty > 0 {
					rec.JanQuantity = rec.YjQuantity / master.JanPackInnerQty
				}

				// 3. 金額を再計算 (取引種別に応じてロジックを分岐)
				switch rec.Flag {
				case 1: // 納品
					// rec.PurchasePriceには「取引時点での包装納入価」が保存されているはず。
					// もしそれが0で、rec.UnitPriceに古い箱単価が入っている場合はそれを使用する。
					packagePurchasePrice := rec.PurchasePrice
					if packagePurchasePrice <= 0 && rec.UnitPrice > 0 {
						packagePurchasePrice = rec.UnitPrice
					}

					// 正しいYJ単位の単価を再計算
					if master.YjPackUnitQty > 0 && packagePurchasePrice > 0 {
						rec.UnitPrice = packagePurchasePrice / master.YjPackUnitQty
					}
					// 金額を再計算
					rec.Subtotal = rec.YjQuantity * rec.UnitPrice

				case 0, 3, 4, 5: // 棚卸、処方など
					rec.UnitPrice = master.NhiPrice // 薬価を単価とする
					rec.Subtotal = rec.YjQuantity * rec.UnitPrice

				default: // その他
					// 数量の変更を反映するため金額は再計算するが、単価は維持する
					rec.Subtotal = rec.YjQuantity * rec.UnitPrice
				}

				// 4. 処理ステータスを更新
				if rec.ProcessFlagMA == "PROVISIONAL" && master.Origin == "JCSHMS" {
					rec.ProcessFlagMA = "COMPLETE"
				}

				// 5. データベースを更新
				if err := db.UpdateFullTransactionInTx(tx, &rec); err != nil {
					tx.Rollback()
					http.Error(w, fmt.Sprintf("Failed to update record ID %d: %v", rec.ID, err), http.StatusInternalServerError)
					return
				}
				updatedCount++
			}

			if err := tx.Commit(); err != nil {
				tx.Rollback()
				http.Error(w, "Failed to commit transaction: "+err.Error(), http.StatusInternalServerError)
				return
			}
			log.Printf("Processed %d/%d records...", updatedCount, len(allRecords))
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]string{
			"message": fmt.Sprintf("全 %d 件の取引データを最新のマスター情報で更新しました。", updatedCount),
		})
	}
}


----- C:\Users\wasab\OneDrive\デスクトップ\WASABI\returns\handler.go -----
// C:\Users\wasab\OneDrive\デスクトップ\WASABI\returns\handler.go

package returns

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"net/http"
	"sort"
	"strconv"
	"strings"
	"time"
	"wasabi/config"
	"wasabi/db"
	"wasabi/model"
)

// GenerateReturnCandidatesHandler は返品可能リストを生成します
func GenerateReturnCandidatesHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		q := r.URL.Query()

		coefficient, err := strconv.ParseFloat(q.Get("coefficient"), 64)
		if err != nil {
			coefficient = 1.5
		}

		cfg, err := config.LoadConfig()
		if err != nil {
			http.Error(w, "設定ファイルの読み込みに失敗しました: "+err.Error(), http.StatusInternalServerError)
			return
		}

		now := time.Now()
		endDate := "99991231"
		startDate := now.AddDate(0, 0, -cfg.CalculationPeriodDays)
		startDateStr := startDate.Format("20060102")

		filters := model.AggregationFilters{
			StartDate:   startDateStr,
			EndDate:     endDate,
			KanaName:    q.Get("kanaName"),
			DosageForm:  q.Get("dosageForm"),
			ShelfNumber: q.Get("shelfNumber"),
			Coefficient: coefficient,
		}

		// ステップ1: 過去のデータから使用量を分析し、発注点を計算する
		yjGroups, err := db.GetStockLedger(conn, filters)
		if err != nil {
			http.Error(w, "Failed to get stock ledger: "+err.Error(), http.StatusInternalServerError)
			return
		}

		// ステップ2: 「今現在」のリアルタイム在庫を取得する
		currentStockMap, err := db.GetAllCurrentStockMap(conn)
		if err != nil {
			http.Error(w, "Failed to get current stock map: "+err.Error(), http.StatusInternalServerError)
			return
		}

		var returnCandidates []model.StockLedgerYJGroup
		for _, group := range yjGroups {
			var returnablePackages []model.StockLedgerPackageGroup
			isGroupAdded := false

			for _, pkg := range group.PackageLedgers {
				// ステップ3: 包装ごとに「今現在」の在庫を計算する
				var currentStockForPackage float64
				var productCodesInPackage []string
				for _, master := range pkg.Masters {
					currentStockForPackage += currentStockMap[master.ProductCode]
					productCodesInPackage = append(productCodesInPackage, master.ProductCode)
				}

				trueEffectiveBalance := currentStockForPackage

				// ステップ4: 「発注点」と「今現在の有効在庫」を比較する
				if len(pkg.Masters) > 0 {
					yjPackUnitQty := pkg.Masters[0].YjPackUnitQty
					// ▼▼▼【ここから修正】▼▼▼
					// 「発注点 > 0」の条件を削除
					if trueEffectiveBalance > (pkg.ReorderPoint + yjPackUnitQty) {
						// ▲▲▲【修正ここまで】▲▲▲

						pkg.EffectiveEndingBalance = trueEffectiveBalance

						if len(productCodesInPackage) > 0 {
							deliveryHistory, err := getDeliveryHistory(conn, productCodesInPackage, startDateStr, endDate)
							if err != nil {
								fmt.Printf("WARN: Failed to get delivery history for package %s: %v\n", pkg.PackageKey, err)
							}
							pkg.DeliveryHistory = deliveryHistory
						}

						returnablePackages = append(returnablePackages, pkg)
						isGroupAdded = true
					}
				}
			}

			if isGroupAdded {
				newGroup := group
				newGroup.PackageLedgers = returnablePackages
				returnCandidates = append(returnCandidates, newGroup)
			}
		}

		// 返品候補リストを剤型優先、次にカナ名順でソートする
		sort.Slice(returnCandidates, func(i, j int) bool {
			prio := map[string]int{
				"1": 1, "内": 1, "2": 2, "外": 2, "3": 3, "注": 3,
				"4": 4, "歯": 4, "5": 5, "機": 5, "6": 6, "他": 6,
			}

			var masterI, masterJ *model.ProductMaster
			if len(returnCandidates[i].PackageLedgers) > 0 && len(returnCandidates[i].PackageLedgers[0].Masters) > 0 {
				masterI = returnCandidates[i].PackageLedgers[0].Masters[0]
			}
			if len(returnCandidates[j].PackageLedgers) > 0 && len(returnCandidates[j].PackageLedgers[0].Masters) > 0 {
				masterJ = returnCandidates[j].PackageLedgers[0].Masters[0]
			}

			if masterI == nil || masterJ == nil {
				return returnCandidates[i].YjCode < returnCandidates[j].YjCode
			}

			prioI, okI := prio[strings.TrimSpace(masterI.UsageClassification)]
			if !okI {
				prioI = 7
			}
			prioJ, okJ := prio[strings.TrimSpace(masterJ.UsageClassification)]
			if !okJ {
				prioJ = 7
			}

			if prioI != prioJ {
				return prioI < prioJ
			}
			return masterI.KanaName < masterJ.KanaName
		})

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(returnCandidates)
	}
}

func getDeliveryHistory(conn *sql.DB, productCodes []string, startDate, endDate string) ([]model.TransactionRecord, error) {
	placeholders := strings.Repeat("?,", len(productCodes)-1) + "?"
	query := fmt.Sprintf(`SELECT `+db.TransactionColumns+` FROM transaction_records 
		WHERE flag = 1 AND jan_code IN (%s) AND transaction_date BETWEEN ? AND ? 
		ORDER BY transaction_date DESC, id DESC`, placeholders)

	args := make([]interface{}, 0, len(productCodes)+2)
	for _, code := range productCodes {
		args = append(args, code)
	}
	args = append(args, startDate, endDate)

	rows, err := conn.Query(query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var records []model.TransactionRecord
	for rows.Next() {
		r, err := db.ScanTransactionRecord(rows)
		if err != nil {
			return nil, err
		}
		records = append(records, *r)
	}
	return records, nil
}


----- C:\Users\wasab\OneDrive\デスクトップ\WASABI\search\handler.go -----
// C:\Users\wasab\OneDrive\デスクトップ\WASABI\search\handler.go
package search

import (
	"database/sql"
	"encoding/json"
	"net/http"
	"wasabi/db" // ▼▼▼【ここに追加】▼▼▼
	"wasabi/mappers"
)

/**
 * @brief 製品名・カナ名でJCSHMSマスターを検索するAPIハンドラ (/api/products/search)
 */
func SearchJcshmsByNameHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		query := r.URL.Query().Get("q")
		if len(query) < 2 {
			http.Error(w, "Query must be at least 2 characters", http.StatusBadRequest)
			return
		}
		results, err := db.SearchJcshmsByName(conn, query)
		if err != nil {
			http.Error(w, "Failed to search products", http.StatusInternalServerError)
			return
		}
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(results)
	}
}

/**
 * @brief 製品名・カナ名で製品マスター全体を検索するAPIハンドラ (/api/masters/search_all)
 */
func SearchAllMastersHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		query := r.URL.Query().Get("q")
		if len(query) < 2 {
			http.Error(w, "Query must be at least 2 characters", http.StatusBadRequest)
			return
		}
		results, err := db.SearchAllProductMastersByName(conn, query)
		if err != nil {
			http.Error(w, "Failed to search masters", http.StatusInternalServerError)
			return
		}
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(results)
	}
}

/**
 * @brief YJコードに紐づく製品マスターのリストを取得するAPIハンドラ (/api/masters/by_yj_code)
 */
func GetMastersByYjCodeHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		yjCode := r.URL.Query().Get("yj_code")
		if yjCode == "" {
			http.Error(w, "yj_code parameter is required", http.StatusBadRequest)
			return
		}
		results, err := db.GetProductMastersByYjCode(conn, yjCode)
		if err != nil {
			http.Error(w, "Failed to get masters by yj_code", http.StatusInternalServerError)
			return
		}
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(results)
	}
}

// GetProductByGS1Handler はGS1コードを元に製品情報を検索し、製品マスター全体を返します。
func GetProductByGS1Handler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		gs1Code := r.URL.Query().Get("gs1_code")
		if gs1Code == "" {
			http.Error(w, "gs1_code is required", http.StatusBadRequest)
			return
		}

		master, err := db.GetProductMasterByGS1Code(conn, gs1Code)
		if err != nil {
			http.Error(w, "Failed to get product by gs1 code: "+err.Error(), http.StatusInternalServerError)
			return
		}

		if master == nil {
			http.Error(w, "Product not found", http.StatusNotFound)
			return
		}

		// ▼▼▼【ここから修正】共通変換関数を使用 ▼▼▼
		masterView := mappers.ToProductMasterView(master)
		// ▲▲▲【修正ここまで】▲▲▲

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(masterView)
	}
}


----- C:\Users\wasab\OneDrive\デスクトップ\WASABI\sequence\handler.go -----
// C:\Users\wasab\OneDrive\デスクトップ\WASABI\sequence\handler.go

package sequence

import (
	"database/sql"
	"encoding/json"
	"net/http"
	"strings"
	"wasabi/db"
)

// GetNextSequenceHandler は、指定されたシーケンスの次の値を返します。
func GetNextSequenceHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// URLからシーケンス名を取得 (例: /api/sequence/next/MA2Y -> MA2Y)
		sequenceName := strings.TrimPrefix(r.URL.Path, "/api/sequence/next/")
		if sequenceName == "" {
			http.Error(w, "Sequence name is required.", http.StatusBadRequest)
			return
		}

		var prefix string
		var padding int

		// シーケンス名に応じた設定
		switch sequenceName {
		case "MA2Y":
			prefix = "MA2Y"
			padding = 8
		case "CL":
			prefix = "CL"
			padding = 4
		default:
			http.Error(w, "Unknown sequence name.", http.StatusBadRequest)
			return
		}

		tx, err := conn.Begin()
		if err != nil {
			http.Error(w, "Failed to start transaction", http.StatusInternalServerError)
			return
		}
		defer tx.Rollback()

		nextCode, err := db.NextSequenceInTx(tx, sequenceName, prefix, padding)
		if err != nil {
			http.Error(w, "Failed to get next sequence: "+err.Error(), http.StatusInternalServerError)
			return
		}

		if err := tx.Commit(); err != nil {
			http.Error(w, "Failed to commit transaction", http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]string{"nextCode": nextCode})
	}
}


----- C:\Users\wasab\OneDrive\デスクトップ\WASABI\settings\handler.go -----
package settings

import (
	"database/sql"
	"encoding/json"
	"net/http"
	"strings"
	"wasabi/config"
	"wasabi/db"
	"wasabi/model"
)

// GetSettingsHandler returns the current settings.
func GetSettingsHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		cfg, err := config.LoadConfig()
		if err != nil {
			http.Error(w, "Failed to load settings: "+err.Error(), http.StatusInternalServerError)
			return
		}
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(cfg)
	}
}

// SaveSettingsHandler saves the settings.
// SaveSettingsHandler saves the settings.
func SaveSettingsHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var payload config.Config
		if err := json.NewDecoder(r.Body).Decode(&payload); err != nil {
			http.Error(w, "Invalid request body", http.StatusBadRequest)
			return
		}

		currentSettings, err := config.LoadConfig()
		if err != nil {
			http.Error(w, "Failed to load current settings", http.StatusInternalServerError)
			return
		}

		currentSettings.EmednetUserID = payload.EmednetUserID
		currentSettings.EmednetPassword = payload.EmednetPassword
		currentSettings.EdeUserID = payload.EdeUserID
		currentSettings.EdePassword = payload.EdePassword
		currentSettings.UsageFolderPath = payload.UsageFolderPath
		currentSettings.CalculationPeriodDays = payload.CalculationPeriodDays
		// ▼▼▼【ここに追加】▼▼▼
		currentSettings.EdgePath = payload.EdgePath // Edgeパスをマージ
		// ▲▲▲【追加ここまで】▲▲▲

		if err := config.SaveConfig(currentSettings); err != nil {
			http.Error(w, "Failed to save settings: "+err.Error(), http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]string{"message": "設定を保存しました。"})
	}
}

// WholesalersHandler は卸業者に関するリクエストを処理します。
func WholesalersHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		switch r.Method {
		case http.MethodGet:
			wholesalers, err := db.GetAllWholesalers(conn)
			if err != nil {
				http.Error(w, "Failed to get wholesalers", http.StatusInternalServerError)
				return
			}
			w.Header().Set("Content-Type", "application/json")
			json.NewEncoder(w).Encode(wholesalers)

		case http.MethodPost:
			var payload model.Wholesaler
			if err := json.NewDecoder(r.Body).Decode(&payload); err != nil {
				http.Error(w, "Invalid request body", http.StatusBadRequest)
				return
			}
			if payload.Code == "" || payload.Name == "" {
				http.Error(w, "Code and Name are required", http.StatusBadRequest)
				return
			}
			if err := db.CreateWholesaler(conn, payload.Code, payload.Name); err != nil {
				http.Error(w, "Failed to create wholesaler", http.StatusInternalServerError)
				return
			}
			w.WriteHeader(http.StatusCreated)
			json.NewEncoder(w).Encode(map[string]string{"message": "卸業者を追加しました。"})

		case http.MethodDelete:
			code := strings.TrimPrefix(r.URL.Path, "/api/settings/wholesalers/")
			if code == "" {
				http.Error(w, "Wholesaler code is required", http.StatusBadRequest)
				return
			}
			if err := db.DeleteWholesaler(conn, code); err != nil {
				http.Error(w, "Failed to delete wholesaler", http.StatusInternalServerError)
				return
			}
			json.NewEncoder(w).Encode(map[string]string{"message": "卸業者を削除しました。"})

		default:
			http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
		}
	}
}

// ClearTransactionsHandler は全ての取引データを削除するリクエストを処理します。
func ClearTransactionsHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		if r.Method != http.MethodPost {
			http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
			return
		}

		if err := db.ClearAllTransactions(conn); err != nil {
			http.Error(w, "Failed to clear all transactions: "+err.Error(), http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]string{"message": "全ての取引データを削除しました。"})
	}
}

func ClearMastersHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		if r.Method != http.MethodPost {
			http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
			return
		}

		tx, err := conn.Begin()
		if err != nil {
			http.Error(w, "Failed to start transaction", http.StatusInternalServerError)
			return
		}
		defer tx.Rollback()

		if err := db.ClearAllProductMasters(tx); err != nil {
			http.Error(w, "Failed to clear all product masters: "+err.Error(), http.StatusInternalServerError)
			return
		}

		if err := tx.Commit(); err != nil {
			http.Error(w, "Failed to commit transaction", http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]string{"message": "全ての製品マスターを削除しました。"})
	}
}

// GetUsagePathHandlerは設定からusageFolderPathの値のみを返します。
func GetUsagePathHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		cfg, err := config.LoadConfig()
		if err != nil {
			http.Error(w, "設定ファイルの読み込みに失敗しました: "+err.Error(), http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]string{
			"path": cfg.UsageFolderPath,
		})
	}
}


----- C:\Users\wasab\OneDrive\デスクトップ\WASABI\static\css\inout.css -----
.inout-view-container {
    display: flex;
    flex-direction: column;
    gap: 16px;
}

.inout-header-controls {
    display: flex;
    flex-wrap: wrap;
    gap: 10px 16px;
    padding: 16px;
    border: 1px solid #000;
    background-color: #f7f7f7;
    align-items: flex-end;
}

.inout-header-controls .field-group {
    display: flex;
    flex-direction: column;
    gap: 4px;
}
.inout-header-controls .field-group label {
    font-size: 12px;
    font-weight: bold;
}
.inout-header-controls .field-group input,
.inout-header-controls .field-group select {
    padding: 6px;
    border: 1px solid #000;
    font-size: 14px;
    min-width: 150px;
}
.inout-header-controls .buttons-group {
    display: flex;
    gap: 8px;
    margin-left: auto;
}

.inout-details-header {
    text-align: right;
}

----- C:\Users\wasab\OneDrive\デスクトップ\WASABI\static\css\styles.css -----
/* C:\Users\wasab\OneDrive\デスクトップ\WASABI\static\css\styles.css (全体) */
* { margin: 0; padding: 0; box-sizing: border-box; }
  @page {
    size: A4 portrait; /* */
    margin: 1cm; /* */
  }
body { font-family: sans-serif;
padding: 10px; background-color: #f4f4f4; }
.hidden { display: none !important; }

/* モーダル表示中にbodyのスクロールを禁止する */
.modal-open {
    overflow: hidden;
}

header {
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    gap: 2px 4px;
    padding: 2px;
    border-bottom: 1px solid #ccc;
    margin-bottom: 5px;
    background-color: #ffffff;
    position: sticky;
    top: 0;
    z-index: 100;
} /* */

.btn {
    font-size: inherit;      /* 文字サイズを通常のHTMLと同じにする */ /* */
    padding: 2px 5px;        /* 余白を上下に2px、左右に5pxに設定 */ /* */
    min-width: 75px;         /* ボタンの最小幅を75pxに設定 */ /* */
    text-align: center;      /* 文字を中央揃えにする */ /* */
    vertical-align: middle;  /* 隣接する要素との垂直方向の位置を調整 */ /* */
    background-color: #e9ecef; /* */
    border: 1px solid #ced4da; /* */
    border-radius: 4px; /* */
    cursor: pointer; /* */
}

.btn:hover { background-color: #dee2e6; } /* */

.filter-container, .inout-header-controls {
    gap: 5px 10px; /* */
    padding: 5px; /* */
    margin-bottom: 5px; /* */
}

table { border-collapse: collapse; width: 100%; table-layout: fixed; } /* */
th, td { border: 1px solid black; padding: 4px; vertical-align: middle; } /* */
th { text-align: center; background-color: #f0f0f0; } /* */
.yj-jan-code { overflow: hidden;
white-space: nowrap; text-overflow: ellipsis; } /* */
.left { text-align: left; } /* */
.right { text-align: right; } /* */

.data-table td input[type="text"],
.data-table td input[type="number"] {
    width: 100%; /* */
    border: 1px solid #999; /* */
    padding: 4px; /* */
    font-size: 11pt; /* */
}

#loading-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); display: flex;
flex-direction: column; justify-content: center; align-items: center; z-index: 9999; color: white; } /* */
.spinner { border: 5px solid #f3f3f3; border-top: 5px solid #0d6efd; border-radius: 50%; width: 50px; height: 50px; animation: spin 1s linear infinite; margin-bottom: 10px; } /* */
@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } } /* */

.notification-box { position: fixed;
top: -100px; left: 50%; transform: translateX(-50%); padding: 15px 25px; border-radius: 5px; color: white; font-size: 16px; z-index: 10000; transition: top 0.5s; } /* */
.notification-box.show { top: 20px; } /* */
.notification-box.success { background-color: #198754; } /* */
.notification-box.error { background-color: #ff0019; } /* */

.modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.6); display: flex; align-items: center; justify-content: center; z-index: 2000; } /* */
.modal-content { background-color: #ffffff; border: 1px solid #000000; padding: 20px; width: 80%; max-width: 900px; max-height: 90vh; display: flex; flex-direction: column; } /* */
.modal-header { display: flex;
justify-content: space-between; align-items: center; margin-bottom: 15px; } /* */
.close-button { font-size: 24px; border: none; background: none; cursor: pointer; } /* */

.modal-body {
    flex-grow: 1; /* 親要素(.modal-content)の高さに合わせて伸縮 */ /* */
    overflow-y: auto; /* 内容がはみ出したら縦スクロールバーを表示 */ /* */
}

.view-title, .view-subtitle, .modal-title {
    font-size: 1em; /* */
    font-weight: bold; /* */
    margin: 0; /* */
    padding: 5px 0; /* */
}

.agg-yj-header { background-color: #343a40; color: white; padding: 4px; margin-top: 10px; font-weight: bold; font-size: 1em; display: flex; align-items: center; } /* */
.agg-pkg-header { background-color: #e9ecef; padding: 4px; border: 1px solid #ccc; border-bottom: none; font-weight: bold; font-size: 1em; } /* */
.agg-yj-header .product-name { margin-left: 20px; flex-grow: 1; } /* */

.tx-return, .tx-return td {
    color: #dc3545; /* 赤色 */ /* */
    font-weight: bold; /* */
}

.tx-inventory, .tx-inventory td {
    color: #0d6efd; /* 青色 */ /* */
    font-weight: bold; /* */
}

.provisional-order-item {
    background-color: #e9ecef !important; /* 薄いグレー */ /* */
    color: #6c757d; /* やや薄い文字色 */ /* */
}

/* ▼▼▼【ここから修正】▼▼▼ */
.provisional-order-item td:not(.order-actions-cell) {
    text-decoration: line-through; /* 取り消し線 */ /* */
}
/* ▲▲▲【修正ここまで】▲▲▲ */ /* */

.provisional-order-item select:disabled,
.provisional-order-item input:disabled {
    background-color: #f8f9fa; /* 背景を少し明るく */ /* */
    cursor: not-allowed; /* 操作不可カーソル */ /* */
}

/* ▼▼▼【ここに追加】▼▼▼ */
.adopted-item td {
    color: red; /* */
    font-weight: bold; /* */
}
/* ▲▲▲【追加ここまで】▲▲▲ */ /* */

/* ▼▼▼ [ここから追加] ボタンのビビッドカラー設定 ▼▼▼ */
.btn-red { background-color: #ff0000; color: white; border-color: #d90000; } /* */
.btn-red:hover { background-color: #d90000; } /* */

.btn-rose { background-color: #ff007f; color: white; border-color: #d9006c; } /* */
.btn-rose:hover { background-color: #d9006c; } /* */

.btn-magenta { background-color: #ff00ff; color: white; border-color: #d900d9; } /* */
.btn-magenta:hover { background-color: #d900d9; } /* */

.btn-violet { background-color: #7f00ff; color: white; border-color: #6c00d9; } /* */
.btn-violet:hover { background-color: #6c00d9; } /* */

.btn-blue { background-color: #0000ff; color: white; border-color: #0000d9; } /* */
.btn-blue:hover { background-color: #0000d9; } /* */

.btn-azure { background-color: #007fff; color: white;
border-color: #006cd9; } /* */
.btn-azure:hover { background-color: #006cd9; } /* */

.btn-cyan { background-color: #00ffff; color: black; border-color: #00d9d9; } /* */
.btn-cyan:hover { background-color: #00d9d9; } /* */

.btn-spring-green { background-color: #00ff7f; color: black; border-color: #00d96c; } /* */
.btn-spring-green:hover { background-color: #00d96c; } /* */

.btn-green { background-color: #00ff00; color: black; border-color: #00d900; } /* */
.btn-green:hover { background-color: #00d900; } /* */

.btn-chartreuse { background-color: #7fff00; color: black; border-color: #6cd900; } /* */
.btn-chartreuse:hover { background-color: #6cd900; } /* */

.btn-yellow { background-color: #ffff00; color: black; border-color: #d9d900; } /* */
.btn-yellow:hover { background-color: #d9d900; } /* */

.btn-orange { background-color: #ff7f00; color: white; border-color: #d96c00; } /* */
.btn-orange:hover { background-color: #d96c00; } /* */
/* ▲▲▲ [追加ここまで] ▲▲▲ */ /* */

#scanned-items-list {
    background-color: #f8f9fa; /* */
}
.scanned-item {
    display: flex; /* */
    justify-content: space-between; /* */
    padding: 4px 8px; /* */
    border-bottom: 1px solid #e9ecef; /* */
}
.scanned-item:last-child {
    border-bottom: none; /* */
}
.scanned-item-name {
    flex-grow: 1; /* */
    white-space: nowrap; /* */
    overflow: hidden; /* */
    text-overflow: ellipsis; /* */
    margin-right: 10px; /* */
}
.scanned-item-count {
    font-weight: bold; /* */
}
.processing-indicator:not(.hidden) {
    display: block !important; /* */
}

/* ▼▼▼【ここに追加】▼▼▼ */
.scanned-item {
    display: flex; /* */
    justify-content: space-between; /* */
    align-items: center; /* 垂直方向中央揃え */ /* */
    padding: 4px 8px; /* */
    border-bottom: 1px solid #e9ecef; /* */
    font-size: 12px; /* 少し小さく */ /* */
}
.scanned-item:last-child {
    border-bottom: none; /* */
}
.scanned-item-name {
    flex-grow: 1; /* */
    white-space: nowrap; /* */
    overflow: hidden; /* */
    text-overflow: ellipsis; /* */
    margin-right: 10px; /* */
}
.scanned-item-count {
    font-weight: bold; /* */
    min-width: 30px; /* カウント部分の幅を確保 */ /* */
    text-align: right; /* */
}
#shelf-scanned-list .scanned-item-name {
    color: #555; /* */
}
#shelf-scanned-list .scanned-item-name.resolved {
    color: #000; /* 品目名が解決したら黒文字に */ /* */
    font-weight: normal; /* */
}
/* ▲▲▲【追加ここまで】▲▲▲ */ /* */

/* ▼▼▼ [修正点] 印刷用CSSを汎用的な仕組みに全面的に書き換え ▼▼▼ */
@media print {
  /* ページ設定: A4横向き */
  @page {
    size: A4 landscape; /* */
    margin: 1cm; /* */
  }

  /* 基本設定 */
  body {
    padding: 0 !important; /* */
    background-color: #fff !important; /* */
  }

  /* 印刷時に不要な要素（ヘッダーや操作ボタンなど）を非表示 */
  #search-modal, #loading-overlay, #notification-box,
  header, .btn, input, select, .filter-container, .inout-header-controls, .inout-details-header,
  .controls-grid, .settings-form-container, .entry-controls, .product-header .btn, .buttons-group,
  #valuation-print-controls {
    display: none !important; /* */
  }

  /* mainタグ配下のビューを一旦すべて非表示に */
  main > div {
    display: none !important; /* */
  }

  /* 「print-this-view」クラスが付いたビューのみを表示させる */
  main > div.print-this-view {
    display: block !important; /* */
    border: none !important; /* */
    padding: 0 !important; /* */
  }

  /* ▼▼▼ [修正点] 印刷対象エリア内の不要な要素を非表示にする設定を追加 ▼▼▼ */
  .print-this-view #deadstock-output-container {
    display: none !important; /* */
  }

  .print-this-view #deadstock-print-area {
    display: block !important; /* */
  }
  /* ▲▲▲ 修正ここまで ▲▲▲ */ /* */


  /* 印刷するビュー内の要素のスタイルを統一 */
  .print-this-view, .print-this-view * {
    font-size: 9pt !important; /* */
    color: black !important; /* */
    background-color: transparent !important; /* */
  }


  /* テーブルのスタイル */
  .print-this-view table,
  .print-this-view th,
  .print-this-view td {
    border: 1px solid #000; /* */
    padding: 2px 4px !important; /* */
  }

  .print-this-view table {
    width: 100%; /* */
    border-collapse: collapse; /* */
    margin-top: 5px !important; /* */
  }

  /* 印刷時の改ページ制御 */
  .print-this-view .agg-yj-header:first-child {
      page-break-before: auto; /* */
  }
  .print-this-view thead {
    display: table-header-group; /* */
  }
  .print-this-view tr {
    page-break-inside: avoid; /* */
  }
    /* ▼▼▼【ここに追加】▼▼▼ */
  /* デッドストックリストの印刷時に、期間前取引履歴を非表示にする */
  .print-this-view .recent-history-container {
    display: none !important; /* */
  }

  /* ▲▲▲【追加ここまで】▲▲▲ */ /* */
}
/* ▲▲▲ 修正ここまで ▲▲▲ */ /* */

/* ----- 在庫評価画面用のスタイル ----- */
#valuation-output-container {
  /* 幅いっぱいに広がるように */
  width: 100%;
  /* 等幅フォントを指定 */
  font-family: monospace;
  /* 文字サイズ: ここは調整が必要です (後述) */
  font-size: 10pt; /* まずは固定値で試す */
  /* white-space: normal; はデフォルトなので通常不要 */
  background-color: #f0f8ff; /* 薄い青背景 */
  border: 2px solid #333;   /* 枠線 */
  box-sizing: border-box;
  padding: 10px; /* 内側の余白 */
  margin-top: 10px;
}

/* 各行のスタイル調整 (必要に応じて) */
#valuation-output-container .item-row {
  /* 行間の調整などが必要な場合はここに追加 */
  line-height: 1.4; /* 例: 少し行間を広げる */
}

/* グループヘッダーのスタイル調整 (必要に応じて) */
#valuation-output-container .agg-yj-header {
  font-family: sans-serif; /* ヘッダーは通常のフォントに戻すなど */
  font-size: 10pt; /* 文字サイズを合わせる */
  background-color: #e0e0e0; /* 背景色を変更 */
  border: 1px solid #333;
  margin-top: 5px;
}
/* ----- 在庫評価画面用のスタイル ここまで ----- */

/* ▼▼▼【ここから追加】 予製中断時のスタイル ▼▼▼ */
#precomp-details-container.is-inactive {
    opacity: 0.5; /* 半透明にする */ /* */
    pointer-events: none; /* クリックなどの操作を無効化 */ /* */
}
#precomp-details-container.is-inactive::before {
    content: "中断中"; /* */
    position: absolute; /* */
    top: 50%; /* */
    left: 50%; /* */
    transform: translate(-50%, -50%) rotate(-15deg); /* */
    font-size: 3em; /* */
    color: rgba(220, 53, 69, 0.5); /* 赤系の半透明 */ /* */
    font-weight: bold; /* */
    z-index: 10; /* */
    pointer-events: none; /* 文字自体はクリックできないように */ /* */
}
/* ▲▲▲【追加ここまで】▲▲▲ */ /* */

/* ----- ▼▼▼【ここから追加】 集計画面用のスタイル ▼▼▼ ----- */
#aggregation-output-container {
  /* 幅いっぱいに広がるように */
  width: 100%;
  /* 等幅フォントを指定 */
  font-family: monospace;
  /* 文字サイズ: ここは調整が必要です */
  font-size: 10pt; /* まずは固定値で試す */
  background-color: #f0f8ff; /* 薄い青背景 */
  border: 2px solid #333;   /* 枠線 */
  box-sizing: border-box;
  padding: 10px; /* 内側の余白 */
  margin-top: 10px;
}

/* 集計画面内のテーブル文字サイズも合わせる */
#aggregation-output-container table,
#aggregation-output-container table th,
#aggregation-output-container table td {
  font-family: monospace;
  font-size: 10pt; /* コンテナと同じサイズに */
}

/* 集計画面のヘッダーは通常のフォントに戻す場合 */
#aggregation-output-container .agg-yj-header,
#aggregation-output-container .agg-pkg-header {
  font-family: sans-serif;
  font-size: 10pt; /* 文字サイズは合わせる */
}

/* 必要に応じて集計テーブルの列幅を調整 */
#aggregation-output-container .data-table .col-1 { width: 3%; }
#aggregation-output-container .data-table .col-2 { width: 8%; }
#aggregation-output-container .data-table .col-3 { width: 8%; } /* YJ/JAN */
#aggregation-output-container .data-table .col-4 { width: 15%; } /* 製品名/包装 */
#aggregation-output-container .data-table .col-5 { width: 15%; } /* 製品名/メーカー */
#aggregation-output-container .data-table .col-6 { width: 5%; } /* 個数/剤型 */
#aggregation-output-container .data-table .col-7 { width: 7%; } /* YJ数量/JAN数量 */
#aggregation-output-container .data-table .col-8 { width: 7%; } /* YJ包装数/JAN包装数 */
#aggregation-output-container .data-table .col-9 { width: 5%; } /* YJ単位/JAN単位 */
#aggregation-output-container .data-table .col-10 { width: 7%; } /* 単価/金額 */
#aggregation-output-container .data-table .col-11 { width: 5%; } /* 税額/税率 */
#aggregation-output-container .data-table .col-12 { width: 5%; } /* 期限/ロット */
#aggregation-output-container .data-table .col-13 { width: 7%; } /* 得意先/伝票番号 */
#aggregation-output-container .data-table .col-14 { width: 3%; } /* 行/MA */
/* ----- ▲▲▲【追加ここまで】 集計画面用のスタイル ▲▲▲ ----- */

----- C:\Users\wasab\OneDrive\デスクトップ\WASABI\static\index.html -----
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WASABI - DAT Import</title>
    <link rel="stylesheet" href="/static/css/styles.css">
    <link rel="stylesheet" href="/static/css/colors.css">
    <script src="/static/js/app.js" type="module"></script>
</head>
<body>

<div id="loading-overlay" class="hidden">
    <div class="spinner"></div>
    <span id="loading-message">処理中...</span>
</div>

<div id="notification-box" class="notification-box"></div>

<header id="main-header">
    <button id="datBtn" class="btn btn-azure">納品・返品 (DATアップロード)</button>
    <input type="file" id="datFileInput" accept=".dat, .txt" style="display: none;" multiple>
</header>

<main>
    <div id="upload-view" class="view active">
        <h3 id="upload-view-title" style="margin-top: 0;">DATファイル アップロード</h3>
        <p>上の「納品・返品」ボタンを押して、DATファイルを選択してください。</p>
        
        <div id="upload-output-container" style="margin-top: 10px;">
            </div>
    </div>
</main>

</body>
</html>

----- C:\Users\wasab\OneDrive\デスクトップ\WASABI\stock\handler.go -----
package stock

import (
	"database/sql"
	"encoding/json"
	"net/http"
	"wasabi/db"
)

// GetCurrentStockHandler はJANコード指定で現在の理論在庫を返します。
func GetCurrentStockHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		janCode := r.URL.Query().Get("jan_code")
		if janCode == "" {
			http.Error(w, "jan_code parameter is required", http.StatusBadRequest)
			return
		}

		stock, err := db.CalculateCurrentStockForProduct(conn, janCode)
		if err != nil {
			http.Error(w, "Failed to calculate stock: "+err.Error(), http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]float64{"stock": stock})
	}
}

// ▼▼▼ [修正点] 全製品の在庫を返すハンドラを末尾に追加 ▼▼▼
// GetAllCurrentStockHandler は全製品の現在の理論在庫を返します。
func GetAllCurrentStockHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		stockMap, err := db.GetAllCurrentStockMap(conn)
		if err != nil {
			http.Error(w, "Failed to calculate all stocks: "+err.Error(), http.StatusInternalServerError)
			return
		}
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(stockMap)
	}
}

// ▲▲▲ 修正ここまで ▲▲▲


----- C:\Users\wasab\OneDrive\デスクトップ\WASABI\transaction\handler.go -----
// C:\Users\wasab\OneDrive\デスクトップ\WASABI\transaction\handler.go

package transaction

import (
	"database/sql"
	"encoding/json"
	"net/http"
	"strconv" // strconvをインポート
	"strings"
	"wasabi/db"
)

// GetReceiptsHandler returns a list of receipt numbers for a given date.
func GetReceiptsHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		date := r.URL.Query().Get("date")
		if date == "" {
			http.Error(w, "Date parameter is required", http.StatusBadRequest)
			return
		}
		// Assuming you will add GetReceiptNumbersByDate to db package
		receipts, err := db.GetReceiptNumbersByDate(conn, date)
		if err != nil {
			http.Error(w, "Failed to get receipt numbers", http.StatusInternalServerError)
			return
		}
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(receipts)
	}
}

// GetTransactionHandler returns all line items for a given receipt number.
func GetTransactionHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		receiptNumber := strings.TrimPrefix(r.URL.Path, "/api/transaction/")
		if receiptNumber == "" {
			http.Error(w, "Receipt number is required", http.StatusBadRequest)
			return
		}
		records, err := db.GetTransactionsByReceiptNumber(conn, receiptNumber)
		if err != nil {
			http.Error(w, "Failed to get transaction details", http.StatusInternalServerError)
			return
		}
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(records)
	}
}

// DeleteTransactionHandler handles the deletion of all records for a given receipt number.
func DeleteTransactionHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		receiptNumber := strings.TrimPrefix(r.URL.Path, "/api/transaction/delete/")
		if receiptNumber == "" {
			http.Error(w, "Receipt number is required", http.StatusBadRequest)
			return
		}
		tx, err := conn.Begin()
		if err != nil {
			http.Error(w, "Failed to start transaction", http.StatusInternalServerError)
			return
		}
		defer tx.Rollback()

		if err := db.DeleteTransactionsByReceiptNumberInTx(tx, receiptNumber); err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}

		if err := tx.Commit(); err != nil {
			http.Error(w, "Failed to commit transaction", http.StatusInternalServerError)
			return
		}
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]string{"message": "Deleted successfully"})
	}
}

// ▼▼▼【ここから追加】▼▼▼

// GetInventoryByDateHandler は指定された日付の棚卸レコードを返します。
func GetInventoryByDateHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		date := r.URL.Query().Get("date")
		if date == "" {
			http.Error(w, "date parameter is required", http.StatusBadRequest)
			return
		}
		records, err := db.GetInventoryTransactionsByDate(conn, date)
		if err != nil {
			http.Error(w, "Failed to get inventory transactions by date", http.StatusInternalServerError)
			return
		}
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(records)
	}
}

// DeleteTransactionByIDHandler はIDを指定して単一の取引レコードを削除します。
func DeleteTransactionByIDHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// URLからIDを取得 (e.g., /api/transaction/delete_by_id/123)
		idStr := strings.TrimPrefix(r.URL.Path, "/api/transaction/delete_by_id/")
		id, err := strconv.Atoi(idStr)
		if err != nil {
			http.Error(w, "Invalid transaction ID", http.StatusBadRequest)
			return
		}

		tx, err := conn.Begin()
		if err != nil {
			http.Error(w, "Failed to start transaction", http.StatusInternalServerError)
			return
		}
		defer tx.Rollback()

		if err := db.DeleteTransactionByIDInTx(tx, id); err != nil {
			http.Error(w, "Failed to delete transaction: "+err.Error(), http.StatusInternalServerError)
			return
		}

		if err := tx.Commit(); err != nil {
			http.Error(w, "Failed to commit transaction", http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]string{"message": "レコードを削除しました。"})
	}
}

// ▲▲▲【追加ここまで】▲▲▲


----- C:\Users\wasab\OneDrive\デスクトップ\WASABI\units\handler.go -----
package units

import (
	"encoding/json"
	"net/http"
)

// GetTaniMapHandlerは、ロード済みの単位マップを返します。
func GetTaniMapHandler() http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		if internalMap == nil {
			json.NewEncoder(w).Encode(make(map[string]string))
			return
		}
		json.NewEncoder(w).Encode(internalMap)
	}
}

----- C:\Users\wasab\OneDrive\デスクトップ\WASABI\units\units.go -----
// C:\Users\wasab\OneDrive\デスクトップ\WASABI\units\units.go

package units

import (
	"encoding/csv"
	"fmt"
	"io"
	"os"
	"wasabi/model"

	"golang.org/x/text/encoding/japanese"
	"golang.org/x/text/transform"
)

var internalMap map[string]string
var reverseMap map[string]string

// FormatPackageSpecは、JCSHMSのデータから仕様通りの包装文字列を生成します。
func FormatPackageSpec(jcshms *model.JCShms) string {
	if jcshms == nil {
		return ""
	}

	yjUnitName := ResolveName(jcshms.JC039)
	pkg := fmt.Sprintf("%s %g%s", jcshms.JC037, jcshms.JC044, yjUnitName)

	if jcshms.JA006.Valid && jcshms.JA008.Valid && jcshms.JA008.Float64 != 0 {
		resolveJanUnitName := func(code string) string {
			if code != "0" && code != "" {
				return ResolveName(code)
			}
			return "" // 0か空の場合は単位を省略
		}

		janUnitName := resolveJanUnitName(jcshms.JA007.String)

		pkg += fmt.Sprintf(" (%g%s×%g%s)",
			jcshms.JA006.Float64,
			yjUnitName,
			jcshms.JA008.Float64,
			janUnitName,
		)
	}
	return pkg
}

// ▼▼▼ [修正点] 「簡易包装」を生成する新しい関数を末尾に追加 ▼▼▼
// FormatSimplePackageSpec は、「包装形態 + 内包装数量 + YJ単位名」の簡易的な包装文字列を生成します。
func FormatSimplePackageSpec(jcshms *model.JCShms) string {
	if jcshms == nil {
		return ""
	}

	// 内包装数量が存在し、0より大きい場合のみ文字列を組み立てる
	if jcshms.JA006.Valid && jcshms.JA006.Float64 > 0 {
		yjUnitName := ResolveName(jcshms.JC039)
		return fmt.Sprintf("%s %g%s", jcshms.JC037, jcshms.JA006.Float64, yjUnitName)
	}

	// 条件に合わない場合は、包装形態のみを返すなどのフォールバック
	// ここでは、より情報量が多い詳細包装を返す
	return FormatPackageSpec(jcshms)
}

// ▲▲▲ 修正ここまで ▲▲▲

// (LoadTANIFile, ResolveName, ResolveCode functions are unchanged)
func LoadTANIFile(path string) (map[string]string, error) {
	file, err := os.Open(path)
	if err != nil {
		return nil, fmt.Errorf("LoadTANIFile: open %s: %w", path, err)
	}
	defer file.Close()

	decoder := japanese.ShiftJIS.NewDecoder()
	reader := csv.NewReader(transform.NewReader(file, decoder))
	reader.LazyQuotes = true
	reader.FieldsPerRecord = -1

	m := make(map[string]string)
	for {
		record, err := reader.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			return nil, fmt.Errorf("LoadTANIFile: read %s: %w", path, err)
		}
		if len(record) < 2 {
			continue
		}
		code := record[0]
		name := record[1]
		m[code] = name
	}
	internalMap = m

	reverseMap = make(map[string]string)
	for code, name := range internalMap {
		reverseMap[name] = code
	}

	return m, nil
}

func ResolveName(code string) string {
	if internalMap == nil {
		return code
	}
	if name, ok := internalMap[code]; ok {
		return name
	}
	return code
}

func ResolveCode(name string) string {
	if reverseMap == nil {
		return ""
	}
	if code, ok := reverseMap[name]; ok {
		return code
	}
	return ""
}


----- C:\Users\wasab\OneDrive\デスクトップ\WASABI\usage\handler.go -----
package usage

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"mime/multipart"
	"net/http"
	"os"
	"strings"
	"wasabi/config"
	"wasabi/db"
	"wasabi/mappers"
	"wasabi/mastermanager"
	"wasabi/model"
	"wasabi/parsers"
)

const insertTransactionQuery = `
INSERT OR REPLACE INTO transaction_records (
    transaction_date, client_code, receipt_number, line_number, flag,
    jan_code, yj_code, product_name, kana_name, usage_classification, package_form, package_spec, maker_name,
    dat_quantity, jan_pack_inner_qty, jan_quantity, jan_pack_unit_qty, jan_unit_name, jan_unit_code,
    yj_quantity, yj_pack_unit_qty, yj_unit_name, unit_price, purchase_price, supplier_wholesale,
    subtotal, tax_amount, tax_rate, expiry_date, lot_number, flag_poison,
    flag_deleterious, flag_narcotic, flag_psychotropic, flag_stimulant,
    flag_stimulant_raw, process_flag_ma
) VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)`

// UploadUsageHandler は自動または手動でのUSAGEファイルアップロードを処理します。
func UploadUsageHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var file io.Reader
		var err error

		if strings.Contains(r.Header.Get("Content-Type"), "multipart/form-data") {
			log.Println("Processing manual USAGE file upload...")
			var f multipart.File
			f, _, err = r.FormFile("file")
			if err != nil {
				http.Error(w, "ファイルの取得に失敗しました: "+err.Error(), http.StatusBadRequest)
				return
			}
			defer f.Close()
			file = f
		} else {
			log.Println("Processing automatic USAGE file import...")
			cfg, cfgErr := config.LoadConfig()
			if cfgErr != nil {
				http.Error(w, "設定ファイルの読み込みに失敗: "+cfgErr.Error(), http.StatusInternalServerError)
				return
			}
			if cfg.UsageFolderPath == "" {
				http.Error(w, "USAGEファイル取込パスが設定されていません。", http.StatusBadRequest)
				return
			}

			rawPath := cfg.UsageFolderPath
			// ▼▼▼【ここが修正箇所】パスの前後の空白と " を自動的に削除 ▼▼▼
			unquotedPath := strings.Trim(strings.TrimSpace(rawPath), "\"")
			// ▲▲▲【修正ここまで】▲▲▲

			filePath := strings.ReplaceAll(unquotedPath, "\\", "/")

			log.Printf("Opening specified USAGE file: %s", filePath)
			f, fErr := os.Open(filePath)
			if fErr != nil {
				displayError := fmt.Sprintf("設定されたパスのファイルを開けませんでした。\nパス: %s\nエラー: %v", filePath, fErr)
				http.Error(w, displayError, http.StatusInternalServerError)
				return
			}
			defer f.Close()
			file = f
		}

		processedRecords, procErr := processUsageFile(conn, file)
		if procErr != nil {
			http.Error(w, procErr.Error(), http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		json.NewEncoder(w).Encode(map[string]interface{}{
			"records": processedRecords,
		})
	}
}

// processUsageFile はファイルストリームから処方データを解析しDBに登録する共通関数です。
func processUsageFile(conn *sql.DB, file io.Reader) ([]model.TransactionRecord, error) {
	parsed, err := parsers.ParseUsage(file)
	if err != nil {
		return nil, fmt.Errorf("USAGEファイルの解析に失敗しました: %w", err)
	}

	var originalJournalMode string
	conn.QueryRow("PRAGMA journal_mode").Scan(&originalJournalMode)
	conn.Exec("PRAGMA journal_mode = MEMORY;")
	conn.Exec("PRAGMA synchronous = OFF;")
	defer func() {
		conn.Exec("PRAGMA synchronous = FULL;")
		conn.Exec(fmt.Sprintf("PRAGMA journal_mode = %s;", originalJournalMode))
	}()

	filtered := removeUsageDuplicates(parsed)
	if len(filtered) == 0 {
		return []model.TransactionRecord{}, nil
	}

	tx, err := conn.Begin()
	if err != nil {
		return nil, fmt.Errorf("トランザクションの開始に失敗: %w", err)
	}
	defer tx.Rollback()

	minDate, maxDate := "99999999", "00000000"
	for _, rec := range filtered {
		if rec.Date < minDate {
			minDate = rec.Date
		}
		if rec.Date > maxDate {
			maxDate = rec.Date
		}
	}

	if err := db.DeleteUsageTransactionsInDateRange(tx, minDate, maxDate); err != nil {
		return nil, fmt.Errorf("既存の処方データ削除に失敗: %w", err)
	}

	var keyList, janList []string
	keySet, janSet := make(map[string]struct{}), make(map[string]struct{})
	for _, rec := range filtered {
		if rec.JanCode != "" && rec.JanCode != "0000000000000" {
			if _, seen := janSet[rec.JanCode]; !seen {
				janSet[rec.JanCode] = struct{}{}
				janList = append(janList, rec.JanCode)
			}
		}
		key := rec.JanCode
		if key == "" || key == "0000000000000" {
			key = fmt.Sprintf("9999999999999%s", rec.ProductName)
		}
		if _, seen := keySet[key]; !seen {
			keySet[key] = struct{}{}
			keyList = append(keyList, key)
		}
	}

	mastersMap, err := db.GetProductMastersByCodesMap(tx, keyList)
	if err != nil {
		return nil, err
	}
	jcshmsMap, err := db.GetJcshmsByCodesMap(tx, janList)
	if err != nil {
		return nil, err
	}

	stmt, err := tx.Prepare(insertTransactionQuery)
	if err != nil {
		return nil, err
	}
	defer stmt.Close()

	var finalRecords []model.TransactionRecord
	for _, rec := range filtered {
		ar := model.TransactionRecord{
			TransactionDate: rec.Date, Flag: 3, JanCode: rec.JanCode,
			YjCode: rec.YjCode, ProductName: rec.ProductName,
			YjQuantity: rec.YjQuantity, YjUnitName: rec.YjUnitName,
		}
		master, err := mastermanager.FindOrCreate(tx, rec.JanCode, rec.ProductName, mastersMap, jcshmsMap)
		if err != nil {
			return nil, err
		}

		mappers.MapProductMasterToTransaction(&ar, master)
		if master.Origin == "JCSHMS" {
			ar.ProcessFlagMA = "COMPLETE"
		} else {
			ar.ProcessFlagMA = "PROVISIONAL"
		}

		_, err = stmt.Exec(
			ar.TransactionDate, ar.ClientCode, ar.ReceiptNumber, ar.LineNumber, ar.Flag,
			ar.JanCode, ar.YjCode, ar.ProductName, ar.KanaName, ar.UsageClassification, ar.PackageForm, ar.PackageSpec, ar.MakerName,
			ar.DatQuantity, ar.JanPackInnerQty, ar.JanQuantity, ar.JanPackUnitQty, ar.JanUnitName, ar.JanUnitCode,
			ar.YjQuantity, ar.YjPackUnitQty, ar.YjUnitName, ar.UnitPrice, ar.PurchasePrice, ar.SupplierWholesale,
			ar.Subtotal, ar.TaxAmount, ar.TaxRate, ar.ExpiryDate, ar.LotNumber, ar.FlagPoison,
			ar.FlagDeleterious, ar.FlagNarcotic, ar.FlagPsychotropic, ar.FlagStimulant,
			ar.FlagStimulantRaw, ar.ProcessFlagMA,
		)
		if err != nil {
			return nil, fmt.Errorf("failed to insert record for JAN %s: %w", ar.JanCode, err)
		}

		finalRecords = append(finalRecords, ar)
	}

	if err := tx.Commit(); err != nil {
		return nil, fmt.Errorf("トランザクションのコミットに失敗: %w", err)
	}
	return finalRecords, nil
}

func removeUsageDuplicates(records []model.UnifiedInputRecord) []model.UnifiedInputRecord {
	seen := make(map[string]struct{})
	var result []model.UnifiedInputRecord
	for _, r := range records {
		key := fmt.Sprintf("%s|%s|%s|%s", r.Date, r.JanCode, r.YjCode, r.ProductName)
		if _, ok := seen[key]; ok {
			continue
		}
		seen[key] = struct{}{}
		result = append(result, r)
	}
	return result
}


----- C:\Users\wasab\OneDrive\デスクトップ\WASABI\valuation\handler.go -----
// C:\Users\wasab\OneDrive\デスクトップ\WASABI\valuation\handler.go

package valuation

import (
	"bytes"
	"database/sql"
	"encoding/json"
	"fmt"
	"net/http"
	"strconv"
	"strings"
	"wasabi/db"
	"wasabi/model"

	"github.com/jung-kurt/gofpdf"
	"github.com/xuri/excelize/v2"
)

// (GetValuationHandler と ExportValuationHandler は変更ありません)
func GetValuationHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		q := r.URL.Query()
		filters := model.ValuationFilters{
			Date:                q.Get("date"),
			KanaName:            q.Get("kanaName"),
			UsageClassification: q.Get("dosageForm"),
		} //
		if filters.Date == "" {
			http.Error(w, "Date parameter is required", http.StatusBadRequest)
			return
		} //
		results, err := db.GetInventoryValuation(conn, filters)
		if err != nil {
			http.Error(w, "Failed to get inventory valuation: "+err.Error(), http.StatusInternalServerError)
			return
		} //
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(results) //
	}
}

func ExportValuationHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		q := r.URL.Query()
		filters := model.ValuationFilters{
			Date:                q.Get("date"),
			KanaName:            q.Get("kanaName"),
			UsageClassification: q.Get("dosageForm"),
		} //
		if filters.Date == "" {
			http.Error(w, "Date parameter is required", http.StatusBadRequest)
			return
		} //
		results, err := db.GetInventoryValuation(conn, filters)
		if err != nil {
			http.Error(w, "Failed to get inventory valuation for export: "+err.Error(), http.StatusInternalServerError)
			return
		} //
		f := excelize.NewFile() //
		sheetName := "在庫評価一覧"
		index, _ := f.NewSheet(sheetName)
		f.SetActiveSheet(index)
		f.DeleteSheet("Sheet1") //
		headers := []string{"剤型", "製品名", "包装", "在庫数", "YJ単位", "薬価金額", "納入価金額"}
		headerStyle, _ := f.NewStyle(&excelize.Style{
			Font:      &excelize.Font{Bold: true},
			Fill:      excelize.Fill{Type: "pattern", Color: []string{"#F0F0F0"}, Pattern: 1},
			Alignment: &excelize.Alignment{Horizontal: "center"},
		}) //
		for i, h := range headers {
			cell, _ := excelize.CoordinatesToCellName(i+1, 1)
			f.SetCellValue(sheetName, cell, h)
			f.SetCellStyle(sheetName, cell, cell, headerStyle) //
		}
		currencyStyle, _ := f.NewStyle(&excelize.Style{NumFmt: 2}) //
		ucMap := map[string]string{"1": "内", "2": "外", "3": "歯", "4": "注", "5": "機", "6": "他"}
		rowNum := 2
		var grandTotalNhi, grandTotalPurchase float64 //
		for _, group := range results {
			ucName := ucMap[strings.TrimSpace(group.UsageClassification)]
			if ucName == "" {
				ucName = group.UsageClassification
			} //
			for _, row := range group.DetailRows {
				stockStr := fmt.Sprintf("%.2f", row.Stock)
				f.SetCellValue(sheetName, "A"+strconv.Itoa(rowNum), ucName)
				f.SetCellValue(sheetName, "B"+strconv.Itoa(rowNum), row.ProductName)        //
				f.SetCellValue(sheetName, "C"+strconv.Itoa(rowNum), row.PackageSpec)        //
				f.SetCellValue(sheetName, "D"+strconv.Itoa(rowNum), stockStr)               //
				f.SetCellValue(sheetName, "E"+strconv.Itoa(rowNum), row.YjUnitName)         //
				f.SetCellValue(sheetName, "F"+strconv.Itoa(rowNum), row.TotalNhiValue)      //
				f.SetCellValue(sheetName, "G"+strconv.Itoa(rowNum), row.TotalPurchaseValue) //
				rowNum++
			}
			grandTotalNhi += group.TotalNhiValue           //
			grandTotalPurchase += group.TotalPurchaseValue //
		}
		f.SetCellValue(sheetName, "E"+strconv.Itoa(rowNum+1), "総合計")                                  //
		f.SetCellValue(sheetName, "F"+strconv.Itoa(rowNum+1), grandTotalNhi)                          //
		f.SetCellValue(sheetName, "G"+strconv.Itoa(rowNum+1), grandTotalPurchase)                     //
		totalStyle, _ := f.NewStyle(&excelize.Style{Font: &excelize.Font{Bold: true}})                //
		f.SetCellStyle(sheetName, "E"+strconv.Itoa(rowNum+1), "G"+strconv.Itoa(rowNum+1), totalStyle) //
		f.SetCellStyle(sheetName, "F2", "G"+strconv.Itoa(rowNum+1), currencyStyle)                    //
		fileName := fmt.Sprintf("在庫評価一覧_%s.xlsx", filters.Date)
		w.Header().Set("Content-Type", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet")
		w.Header().Set("Content-Disposition", "attachment; filename="+fileName) //
		if err := f.Write(w); err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
		} //
	}
}

// ExportValuationPDFHandler は在庫評価レポートをPDFファイルとしてエクスポートします。
func ExportValuationPDFHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		q := r.URL.Query()
		filters := model.ValuationFilters{
			Date:                q.Get("date"),
			KanaName:            q.Get("kanaName"),
			UsageClassification: q.Get("dosageForm"),
		} //

		if filters.Date == "" {
			http.Error(w, "Date parameter is required", http.StatusBadRequest)
			return
		} //

		results, err := db.GetInventoryValuation(conn, filters)
		if err != nil {
			http.Error(w, "Failed to get inventory valuation for export: "+err.Error(), http.StatusInternalServerError)
			return
		} //

		pdf := gofpdf.New("P", "mm", "A4", "") //
		pdf.AddPage()                          //

		pdf.SetLineWidth(0.2)                   //
		fontPath := "SOU/ipaexg.ttf"            //
		pdf.AddUTF8Font("ipaexg", "", fontPath) //

		pdf.SetFont("ipaexg", "", 14)                           //
		pdf.Cell(0, 10, fmt.Sprintf("%s 在庫評価一覧", filters.Date)) //
		pdf.Ln(15)                                              //

		pdf.SetFont("ipaexg", "", 9) //

		const (
			pageWidth          = 210.0
			pageHeight         = 297.0
			leftMargin         = 10.0
			topMargin          = 10.0
			rightMargin        = 10.0
			bottomMargin       = 15.0
			contentWidth       = pageWidth - leftMargin - rightMargin
			productNameWidth   = 70.0
			packageSpecWidth   = 55.0
			stockWidth         = 25.0
			nhiPriceWidth      = 20.0
			purchasePriceWidth = 20.0
			lineHt             = 5.0
		)
		pdf.SetMargins(leftMargin, topMargin, rightMargin)
		pdf.SetAutoPageBreak(false, bottomMargin) // 自動改ページは無効化

		// ヘッダーを描画する関数
		drawHeader := func() {
			pdf.SetFont("ipaexg", "", 9)
			pdf.SetFillColor(240, 240, 240)                                          //
			pdf.CellFormat(productNameWidth, 7, "製品名", "1", 0, "C", true, 0, "")     //
			pdf.CellFormat(packageSpecWidth, 7, "包装", "1", 0, "C", true, 0, "")      //
			pdf.CellFormat(stockWidth, 7, "在庫数", "1", 0, "C", true, 0, "")           //
			pdf.CellFormat(nhiPriceWidth, 7, "薬価金額", "1", 0, "C", true, 0, "")       //
			pdf.CellFormat(purchasePriceWidth, 7, "納入価金額", "1", 0, "C", true, 0, "") //
			pdf.Ln(7)
		}
		drawHeader()

		var grandTotalNhi float64                                                              //
		var grandTotalPurchase float64                                                         //
		ucMap := map[string]string{"1": "内", "2": "外", "3": "歯", "4": "注", "5": "機", "6": "他"} //

		for _, group := range results {
			// グループヘッダーの高さを見積もり、改ページチェック
			groupHeaderHeight := 8.0
			if pdf.GetY()+groupHeaderHeight > (pageHeight - bottomMargin) {
				pdf.AddPage()
				drawHeader()
			}

			ucName := ucMap[strings.TrimSpace(group.UsageClassification)]
			if ucName == "" {
				ucName = group.UsageClassification
			} //

			pdf.SetFont("ipaexg", "", 10)                                                                          //
			pdf.SetFillColor(220, 220, 220)                                                                        //
			pdf.CellFormat(contentWidth, groupHeaderHeight, fmt.Sprintf("■ %s", ucName), "1", 1, "L", true, 0, "") //
			pdf.SetFont("ipaexg", "", 9)

			for _, row := range group.DetailRows { //
				// 複数行になる可能性のあるテキストを行リストに分割
				productNameLines := pdf.SplitLines([]byte(row.ProductName), productNameWidth-2) //
				packageSpecLines := pdf.SplitLines([]byte(row.PackageSpec), packageSpecWidth-2) //

				// 必要な行数を計算 (製品名と包装で多い方に合わせる)
				lineCount := len(productNameLines)
				if len(packageSpecLines) > lineCount {
					lineCount = len(packageSpecLines)
				} //

				// この行に必要な高さを計算 (最低でも7mmは確保)
				requiredHeight := float64(lineCount) * lineHt
				if requiredHeight < 7.0 {
					requiredHeight = 7.0
				} //

				// 改ページが必要かチェック
				if pdf.GetY()+requiredHeight > (pageHeight - bottomMargin) { //
					pdf.AddPage()
					drawHeader() //
				}

				startX := pdf.GetX()
				startY := pdf.GetY()

				// 各セルをCellFormatで描画 (罫線も指定)
				// 製品名 (左・右罫線)
				pdf.Rect(startX, startY, productNameWidth, requiredHeight, "D") // 外枠を描画
				pdf.SetX(startX + 1)                                            // 少し内側から描画開始
				pdf.MultiCell(productNameWidth-2, lineHt, row.ProductName, "", "L", false)
				pdf.SetXY(startX+productNameWidth, startY) // 次のセルの開始位置へ

				// 包装 (右罫線のみ、Rectで描画済みなので不要)
				pdf.Rect(startX+productNameWidth, startY, packageSpecWidth, requiredHeight, "D")
				pdf.SetX(startX + productNameWidth + 1)
				pdf.MultiCell(packageSpecWidth-2, lineHt, row.PackageSpec, "", "L", false)
				pdf.SetXY(startX+productNameWidth+packageSpecWidth, startY)

				// 在庫数 (右罫線 + 中央揃え)
				stockText := fmt.Sprintf("%.2f %s", row.Stock, row.YjUnitName)                     //
				pdf.CellFormat(stockWidth, requiredHeight, stockText, "BR", 0, "RM", false, 0, "") //

				// 薬価金額 (右罫線 + 右揃え)
				nhiText := fmt.Sprintf("%s", formatCurrency(row.TotalNhiValue))                    //
				pdf.CellFormat(nhiPriceWidth, requiredHeight, nhiText, "BR", 0, "R", false, 0, "") //

				// 納入価金額 (右罫線 + 右揃え)
				purchaseText := fmt.Sprintf("円%s", formatCurrency(row.TotalPurchaseValue))                   //
				pdf.CellFormat(purchasePriceWidth, requiredHeight, purchaseText, "BR", 1, "R", false, 0, "") //

				// 描画後のY座標を更新 (SetXYやCellFormat(...,1,...)で自動更新されるが念のため)
				// pdf.SetY(startY + requiredHeight)
			}
			grandTotalNhi += group.TotalNhiValue           //
			grandTotalPurchase += group.TotalPurchaseValue //
		}

		// 総合計の行の改ページチェック
		totalHeight := 8.0
		if pdf.GetY()+totalHeight > (pageHeight - bottomMargin) {
			pdf.AddPage()
			drawHeader()
		}

		pdf.SetFont("ipaexg", "", 10)                                                                                //
		pdf.SetFillColor(240, 240, 240)                                                                              //
		pdf.CellFormat(productNameWidth+packageSpecWidth+stockWidth, 8, "総合計", "1", 0, "R", true, 0, "")             //
		pdf.CellFormat(nhiPriceWidth, 8, fmt.Sprintf("%s", formatCurrency(grandTotalNhi)), "1", 0, "R", true, 0, "") //
		// ▼▼▼ 修正箇所 ▼▼▼
		pdf.CellFormat(purchasePriceWidth, 8, "円"+formatCurrency(grandTotalPurchase), "1", 1, "R", true, 0, "") //
		// ▲▲▲ 修正ここまで ▲▲▲

		var buffer bytes.Buffer
		if err := pdf.Output(&buffer); err != nil {
			http.Error(w, "PDFの生成に失敗しました: "+err.Error(), http.StatusInternalServerError)
			return
		} //

		fileName := fmt.Sprintf("在庫評価一覧_%s.pdf", filters.Date)                                  //
		w.Header().Set("Content-Type", "application/pdf")                                       //
		w.Header().Set("Content-Disposition", fmt.Sprintf("inline; filename=\"%s\"", fileName)) //
		w.Header().Set("Content-Length", strconv.Itoa(len(buffer.Bytes())))                     //

		if _, err := buffer.WriteTo(w); err != nil {
			http.Error(w, "PDFの送信に失敗しました: "+err.Error(), http.StatusInternalServerError)
		} //
	}
}

func formatCurrency(value float64) string {
	s := strconv.FormatFloat(value, 'f', 0, 64)
	if value < 0 {
		s = s[1:]
	} //
	n := len(s)
	if n <= 3 {
		if value < 0 {
			return "-" + s
		}
		return s //
	}
	start := (n-1)%3 + 1
	var parts []string
	parts = append(parts, s[:start])
	for i := start; i < n; i += 3 {
		parts = append(parts, s[i:i+3])
	} //
	result := strings.Join(parts, ",") //
	if value < 0 {
		return "-" + result
	} //
	return result
}


----- C:\Users\wasab\OneDrive\デスクトップ\WASABI\main.go -----
// C:\Users\wasab\OneDrive\デスクトップ\WASABI\main.go
package main

import (
	"database/sql"
	"log"
	"net/http"
	"os/exec"
	"runtime"

	_ "github.com/mattn/go-sqlite3"

	// DAT読み取り機能に必要なパッケージのみをインポート
	"wasabi/dat"
	"wasabi/db"
	"wasabi/loader"
	"wasabi/units"
)

func main() {
	conn, err := sql.Open("sqlite3", "./wasabi.db")
	if err != nil {
		log.Fatalf("db open error: %v", err)
	}
	// データベース設定
	conn.Exec("PRAGMA journal_mode = WAL;")
	conn.Exec("PRAGMA busy_timeout = 5000;")
	conn.SetMaxOpenConns(1)
	conn.SetMaxIdleConns(1)
	defer conn.Close()

	// DBスキーマとJCSHMS/JANCODEマスタのロード (DAT処理に必須)
	if err := loader.InitDatabase(conn); err != nil {
		log.Fatalf("master data initialization failed: %v", err)
	}

	// マイグレーションの適用 (DAT処理に必須)
	if err := db.ApplyMigrations(conn); err != nil {
		log.Fatalf("database migration failed: %v", err)
	}

	// 単位マスタのロード (DAT処理結果のHTML表示に必須)
	if _, err := units.LoadTANIFile("SOU/TANI.CSV"); err != nil {
		log.Fatalf("tani master init failed: %v", err)
	}
	log.Println("Master data loaded successfully.")

	mux := http.NewServeMux()

	// --- DAT読み取り機能に必要なエンドポイント ---
	// 1. HTMLを返すDATアップロードハンドラ
	mux.HandleFunc("/api/dat/upload_html", dat.UploadDatAsHTMLHandler(conn))

	// 2. 単位マップ（HTMLテンプレートのヘルパーがGo側で使うため、JS用ではないが初期化は必要）
	// ※ units.LoadTANIFile でロード済み

	// --- 静的ファイル配信 (HTML, JS, CSS) ---
	// これがないとブラウザで画面が開けない
	mux.Handle("/static/", http.StripPrefix("/static/", http.FileServer(http.Dir("./static"))))
	mux.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		http.ServeFile(w, r, "./static/index.html")
	})

	// --- サーバー起動 ---
	port := ":8080"
	log.Printf("Server starting on http://localhost%s", port)
	go openBrowser("http://localhost" + port)
	if err := http.ListenAndServe(port, mux); err != nil {
		log.Fatalf("server failed to start: %v", err)
	}
}

// openBrowser はデフォルトのブラウザでURLを開きます。
func openBrowser(url string) {
	var err error
	switch runtime.GOOS {
	case "windows":
		err = exec.Command("rundll32", "url.dll,FileProtocolHandler", url).Start()
	case "darwin":
		err = exec.Command("open", url).Start()
	default:
		err = exec.Command("xdg-open", url).Start()
	}
	if err != nil {
		log.Printf("failed to open browser: %v", err)
	}
}


----- C:\Users\wasab\OneDrive\デスクトップ\WASABI\schema.sql -----
-- C:\Users\wasab\OneDrive\デスクトップ\WASABI\schema.sql

-- 得意先マスターテーブル
CREATE TABLE IF NOT EXISTS client_master (
  client_code TEXT PRIMARY KEY,
  client_name TEXT NOT NULL UNIQUE
);
-- 卸業者マスターテーブル 
CREATE TABLE IF NOT EXISTS wholesalers (
  wholesaler_code TEXT PRIMARY KEY,
  wholesaler_name TEXT NOT NULL
);
-- 製品マスターテーブル (最終確定版) 
CREATE TABLE IF NOT EXISTS product_master (
    -- 基本情報
    product_code TEXT PRIMARY KEY,
    yj_code TEXT,
    gs1_code TEXT,                       -- 調剤包装単位コード (JC122)
    product_name TEXT,                   -- (役割変更) 規格を含まない基本製品名 (商品名 JC018)
    kana_name TEXT,
    maker_name TEXT,
    
   
    -- 製品仕様情報 
    specification TEXT,                     -- 規格容量 (JC020)
    usage_classification TEXT,
    package_form TEXT,
    yj_unit_name TEXT,
    yj_pack_unit_qty REAL,
    jan_pack_inner_qty REAL,
    jan_unit_code INTEGER,
    jan_pack_unit_qty REAL,
    origin TEXT,
    
    -- 価格情報
    nhi_price REAL,
    purchase_price REAL,
    
    -- 管理フラグ・情報
    flag_poison INTEGER, 
    flag_deleterious INTEGER,
    flag_narcotic INTEGER,
    flag_psychotropic INTEGER,
    flag_stimulant INTEGER,
    flag_stimulant_raw INTEGER,
    is_order_stopped INTEGER DEFAULT 0,
    supplier_wholesale TEXT,

    -- ユーザー定義項目
    group_code TEXT,
    shelf_number TEXT,
    category TEXT,
    user_notes TEXT
);
-- 取引記録テーブル 
CREATE TABLE IF NOT EXISTS transaction_records (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  transaction_date TEXT,
  client_code TEXT,
  receipt_number TEXT,
  line_number TEXT,
  flag INTEGER,
  jan_code TEXT,
  yj_code TEXT,
  product_name TEXT, -- 注意: ここには取引時点での規格込み名称が保存される
  kana_name TEXT,
  usage_classification TEXT,
  package_form TEXT,
  package_spec TEXT,
  maker_name TEXT,
  dat_quantity REAL,
  jan_pack_inner_qty REAL,
  jan_quantity REAL,
  jan_pack_unit_qty REAL,
  jan_unit_name TEXT,
  jan_unit_code TEXT,
  yj_quantity REAL,
  yj_pack_unit_qty REAL,
  yj_unit_name TEXT,
  unit_price REAL,
  purchase_price REAL,
  supplier_wholesale TEXT,
  subtotal REAL,
  tax_amount REAL,
  tax_rate REAL, 
  expiry_date TEXT,
  lot_number TEXT,
  flag_poison INTEGER,
  flag_deleterious INTEGER,
  flag_narcotic INTEGER,
  flag_psychotropic INTEGER,
  flag_stimulant INTEGER,
  flag_stimulant_raw INTEGER,
  process_flag_ma TEXT
);
-- 予製レコードテーブル 
CREATE TABLE IF NOT EXISTS precomp_records (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  transaction_date TEXT,
  client_code TEXT,
  receipt_number TEXT,
  line_number TEXT,
  jan_code TEXT,
  yj_code TEXT,
  product_name TEXT,
  kana_name TEXT,
  usage_classification TEXT,
  package_form TEXT,
  package_spec TEXT,
  maker_name TEXT,
  jan_pack_inner_qty REAL,
  jan_quantity REAL,
  jan_pack_unit_qty REAL,
  jan_unit_name TEXT,
  jan_unit_code TEXT,
  yj_quantity REAL,
  yj_pack_unit_qty REAL,
  yj_unit_name TEXT,
  purchase_price REAL,
  supplier_wholesale TEXT,
  created_at TEXT NOT NULL,
  status TEXT NOT NULL DEFAULT 'active',
  UNIQUE(client_code, jan_code)
);
-- ▼▼▼【ここから修正】▼▼▼ 
-- 発注残管理テーブル
CREATE TABLE IF NOT EXISTS backorders (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  order_date TEXT NOT NULL,
  yj_code TEXT NOT NULL,
  product_name TEXT,
  package_form TEXT NOT NULL,
  jan_pack_inner_qty REAL NOT NULL,
  yj_unit_name TEXT NOT NULL,
  order_quantity REAL NOT NULL,
  remaining_quantity REAL NOT NULL,
  wholesaler_code TEXT,
  yj_pack_unit_qty REAL,
  jan_pack_unit_qty REAL,
  jan_unit_code INTEGER
);
-- ▲▲▲【修正ここまで】▲▲▲ 

-- 手入力用ロット・期限情報テーブル
CREATE TABLE IF NOT EXISTS dead_stock_list (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  product_code TEXT NOT NULL,
  yj_code TEXT,
  package_form TEXT,
  jan_pack_inner_qty REAL,
  yj_unit_name TEXT,
  stock_quantity_jan REAL NOT NULL,
  expiry_date TEXT,
  lot_number TEXT,
  created_at TEXT NOT NULL,
  UNIQUE(product_code, expiry_date, lot_number)
);
-- JCSHMSマスター (SOU/JCSHMS.CSV から読み込み) 
CREATE TABLE IF NOT EXISTS jcshms (
  JC000 TEXT, JC001 TEXT, JC002 TEXT, JC003 TEXT, JC004 TEXT, JC005 TEXT, JC006 TEXT, JC007 TEXT, JC008 TEXT, JC009 TEXT,
  JC010 TEXT, JC011 TEXT, JC012 TEXT, JC013 TEXT, JC014 TEXT, JC015 TEXT, JC016 TEXT, JC017 TEXT, JC018 TEXT, JC019 TEXT,
  JC020 TEXT, JC021 TEXT, JC022 TEXT, JC023 TEXT, JC024 TEXT, JC025 TEXT, JC026 TEXT, JC027 TEXT, JC028 TEXT, JC029 TEXT,
  JC030 TEXT, JC031 TEXT, JC032 TEXT, JC033 TEXT, JC034 TEXT, JC035 TEXT, JC036 TEXT, JC037 TEXT, JC038 TEXT, JC039 TEXT,
  JC040 TEXT, JC041 TEXT, JC042 TEXT, JC043 TEXT, JC044 REAL, JC045 TEXT, JC046 TEXT, JC047 TEXT, JC048 TEXT, JC049 TEXT, 
  JC050 REAL, JC051 TEXT, JC052 TEXT, JC053 TEXT, JC054 TEXT, JC055 TEXT, JC056 TEXT, JC057 TEXT, JC058 TEXT, JC059 TEXT,
  JC060 TEXT, JC061 INTEGER, JC062 INTEGER, JC063 INTEGER, JC064 INTEGER, JC065 INTEGER, JC066 INTEGER, JC067 TEXT, JC068 TEXT, JC069 TEXT,
  JC070 TEXT, JC071 TEXT, JC072 TEXT, JC073 TEXT, JC074 TEXT, JC075 TEXT, JC076 TEXT, JC077 TEXT, JC078 TEXT, JC079 TEXT,
  JC080 TEXT, JC081 TEXT, JC082 TEXT, JC083 TEXT, JC084 TEXT, JC085 TEXT, JC086 TEXT, JC087 TEXT, JC088 TEXT, JC089 TEXT,
  JC090 TEXT, JC091 TEXT, JC092 TEXT, JC093 TEXT, JC094 TEXT, JC095 TEXT, JC096 TEXT, JC097 TEXT, JC098 TEXT, JC099 TEXT, 
  JC100 TEXT, JC101 TEXT, JC102 TEXT, JC103 TEXT, JC104 TEXT, JC105 TEXT, JC106 TEXT, JC107 TEXT, JC108 TEXT, JC109 TEXT,
  JC110 TEXT, JC111 TEXT, JC112 TEXT, JC113 TEXT, JC114 TEXT, JC115 TEXT, JC116 TEXT, JC117 TEXT, JC118 TEXT, JC119 TEXT,
  -- ▼▼▼【ここから修正】▼▼▼
  JC120 TEXT, JC121 TEXT, JC122 TEXT, JC123 TEXT, JC124 REAL,
  -- ▲▲▲【修正ここまで】▲▲▲
  PRIMARY KEY(JC000)
);
-- JANCODEマスター (SOU/JANCODE.CSV から読み込み) 
CREATE TABLE IF NOT EXISTS jancode (
  JA000 TEXT, JA001 TEXT, JA002 TEXT, JA003 TEXT, JA004 TEXT, JA005 TEXT, JA006 REAL, JA007 TEXT, JA008 REAL, JA009 TEXT,
  JA010 TEXT, JA011 TEXT, JA012 TEXT, JA013 TEXT, JA014 TEXT, JA015 TEXT, JA016 TEXT, JA017 TEXT, JA018 TEXT, JA019 TEXT,
  JA020 TEXT, JA021 TEXT, JA022 TEXT, JA023 TEXT, JA024 TEXT, JA025 TEXT, JA026 TEXT, JA027 TEXT, JA028 TEXT, JA029 TEXT,
  PRIMARY KEY(JA001)
);
-- 自動採番用シーケンステーブル 
CREATE TABLE IF NOT EXISTS code_sequences (
  name TEXT PRIMARY KEY,
  last_no INTEGER NOT NULL
);
INSERT OR IGNORE INTO code_sequences(name, last_no) VALUES ('MA2Y', 0); 
INSERT OR IGNORE INTO code_sequences(name, last_no) VALUES ('CL', 0);
-- パフォーマンス向上のためのインデックス 
CREATE UNIQUE INDEX IF NOT EXISTS idx_transactions_unique_slip
  ON transaction_records(transaction_date, client_code, receipt_number, line_number)
  WHERE receipt_number != '';
CREATE INDEX IF NOT EXISTS idx_transactions_jan_code ON transaction_records (jan_code); 
CREATE INDEX IF NOT EXISTS idx_transactions_date ON transaction_records (transaction_date);
CREATE INDEX IF NOT EXISTS idx_transactions_flag ON transaction_records (flag); 
CREATE INDEX IF NOT EXISTS idx_product_master_kana_name ON product_master (kana_name);
CREATE INDEX IF NOT EXISTS idx_tx_jan_date ON transaction_records(jan_code, transaction_date); 
CREATE INDEX IF NOT EXISTS idx_transactions_receipt_number ON transaction_records (receipt_number);
CREATE INDEX IF NOT EXISTS idx_transactions_process_flag_ma ON transaction_records (process_flag_ma); 
CREATE INDEX IF NOT EXISTS idx_transactions_flag_date ON transaction_records (flag, transaction_date);

